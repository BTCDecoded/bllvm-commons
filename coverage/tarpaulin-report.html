<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","user","src","BTCDecoded","governance-app","src","config.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::env;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AppConfig {\n    pub database_url: String,\n    pub github_app_id: u64,\n    pub github_private_key_path: String,\n    pub github_webhook_secret: String,\n    pub governance_repo: String,\n    pub server_host: String,\n    pub server_port: u16,\n}\n\nimpl AppConfig {\n    pub fn load() -\u003e Result\u003cSelf, Box\u003cdyn std::error::Error\u003e\u003e {\n        let database_url = env::var(\"DATABASE_URL\")\n            .unwrap_or_else(|_| \"sqlite://governance.db\".to_string());\n        \n        let github_app_id = env::var(\"GITHUB_APP_ID\")\n            .unwrap_or_else(|_| \"123456\".to_string())\n            .parse()?;\n        \n        let github_private_key_path = env::var(\"GITHUB_PRIVATE_KEY_PATH\")\n            .unwrap_or_else(|_| \"/path/to/private-key.pem\".to_string());\n        \n        let github_webhook_secret = env::var(\"GITHUB_WEBHOOK_SECRET\")\n            .unwrap_or_else(|_| \"your_webhook_secret_here\".to_string());\n        \n        let governance_repo = env::var(\"GOVERNANCE_REPO\")\n            .unwrap_or_else(|_| \"BTCDecoded/governance\".to_string());\n        \n        let server_host = env::var(\"SERVER_HOST\")\n            .unwrap_or_else(|_| \"0.0.0.0\".to_string());\n        \n        let server_port = env::var(\"SERVER_PORT\")\n            .unwrap_or_else(|_| \"3000\".to_string())\n            .parse()?;\n\n        Ok(AppConfig {\n            database_url,\n            github_app_id,\n            github_private_key_path,\n            github_webhook_secret,\n            governance_repo,\n            server_host,\n            server_port,\n        })\n    }\n}\n\n\n\n\n","traces":[{"line":16,"address":[4548176,4549984,4549959],"length":1,"stats":{"Line":0}},{"line":17,"address":[3673761],"length":1,"stats":{"Line":0}},{"line":18,"address":[3672960,3672976],"length":1,"stats":{"Line":0}},{"line":20,"address":[3674030,3674080,3673927,3673824],"length":1,"stats":{"Line":0}},{"line":21,"address":[3848557,3848908],"length":1,"stats":{"Line":0}},{"line":24,"address":[3674137],"length":1,"stats":{"Line":0}},{"line":25,"address":[3674168],"length":1,"stats":{"Line":0}},{"line":27,"address":[19637427,19637455,19635008],"length":1,"stats":{"Line":0}},{"line":28,"address":[3832534,3832160,3832540],"length":1,"stats":{"Line":0}},{"line":30,"address":[3674303],"length":1,"stats":{"Line":0}},{"line":31,"address":[3673424,3673408],"length":1,"stats":{"Line":0}},{"line":33,"address":[3674405],"length":1,"stats":{"Line":0}},{"line":34,"address":[4302432,4302448],"length":1,"stats":{"Line":0}},{"line":36,"address":[3674829,3674617,3674507,3674704],"length":1,"stats":{"Line":0}},{"line":37,"address":[20466065,20466209,20466284],"length":1,"stats":{"Line":0}},{"line":40,"address":[3832690],"length":1,"stats":{"Line":0}},{"line":41,"address":[3674901],"length":1,"stats":{"Line":0}},{"line":42,"address":[20464712,20464847],"length":1,"stats":{"Line":0}},{"line":43,"address":[3674940],"length":1,"stats":{"Line":0}},{"line":44,"address":[3674988],"length":1,"stats":{"Line":0}},{"line":45,"address":[3675036],"length":1,"stats":{"Line":0}},{"line":46,"address":[3675084],"length":1,"stats":{"Line":0}},{"line":47,"address":[3832864],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","home","user","src","BTCDecoded","governance-app","src","crypto","mod.rs"],"content":"pub mod signatures;\npub mod multisig;\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","src","crypto","multisig.rs"],"content":"use std::collections::HashMap;\nuse crate::crypto::signatures::SignatureManager;\nuse crate::error::GovernanceError;\n\npub struct MultisigManager {\n    signature_manager: SignatureManager,\n}\n\nimpl MultisigManager {\n    pub fn new() -\u003e Self {\n        Self {\n            signature_manager: SignatureManager::new(),\n        }\n    }\n\n    pub fn verify_multisig(\n        \u0026self,\n        message: \u0026str,\n        signatures: \u0026[(String, String)], // (signer, signature)\n        public_keys: \u0026HashMap\u003cString, String\u003e, // username -\u003e public_key\n        required_threshold: (usize, usize), // (required, total)\n    ) -\u003e Result\u003cbool, GovernanceError\u003e {\n        let (required, total) = required_threshold;\n        let mut valid_signatures = 0;\n        let mut verified_signers = Vec::new();\n\n        for (signer, signature) in signatures {\n            if let Some(public_key_str) = public_keys.get(signer) {\n                // Parse public key\n                let public_key = public_key_str.parse::\u003csecp256k1::PublicKey\u003e()\n                    .map_err(|e| GovernanceError::CryptoError(format!(\"Invalid public key for {}: {}\", signer, e)))?;\n\n                // Parse signature\n                let sig = signature.parse::\u003csecp256k1::ecdsa::Signature\u003e()\n                    .map_err(|e| GovernanceError::CryptoError(format!(\"Invalid signature from {}: {}\", signer, e)))?;\n\n                // Verify signature\n                if self.signature_manager.verify_signature(message, \u0026sig, \u0026public_key)? {\n                    valid_signatures += 1;\n                    verified_signers.push(signer.clone());\n                }\n            }\n        }\n\n        if valid_signatures \u003e= required {\n            Ok(true)\n        } else {\n            Err(GovernanceError::ThresholdError(format!(\n                \"Multisig threshold not met. Required: {}/{} signatures, Valid: {}/{}\",\n                required,\n                total,\n                valid_signatures,\n                signatures.len()\n            )))\n        }\n    }\n\n    pub fn get_verified_signers(\n        \u0026self,\n        message: \u0026str,\n        signatures: \u0026[(String, String)],\n        public_keys: \u0026HashMap\u003cString, String\u003e,\n    ) -\u003e Result\u003cVec\u003cString\u003e, GovernanceError\u003e {\n        let mut verified_signers = Vec::new();\n\n        for (signer, signature) in signatures {\n            if let Some(public_key_str) = public_keys.get(signer) {\n                let public_key = public_key_str.parse::\u003csecp256k1::PublicKey\u003e()\n                    .map_err(|e| GovernanceError::CryptoError(format!(\"Invalid public key for {}: {}\", signer, e)))?;\n\n                let sig = signature.parse::\u003csecp256k1::ecdsa::Signature\u003e()\n                    .map_err(|e| GovernanceError::CryptoError(format!(\"Invalid signature from {}: {}\", signer, e)))?;\n\n                if self.signature_manager.verify_signature(message, \u0026sig, \u0026public_key)? {\n                    verified_signers.push(signer.clone());\n                }\n            }\n        }\n\n        Ok(verified_signers)\n    }\n}\n\nimpl Default for MultisigManager {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n\n\n\n","traces":[{"line":10,"address":[4831312],"length":1,"stats":{"Line":0}},{"line":12,"address":[3415249],"length":1,"stats":{"Line":0}},{"line":16,"address":[3417237,3417231,3415264],"length":1,"stats":{"Line":0}},{"line":24,"address":[3415418],"length":1,"stats":{"Line":0}},{"line":25,"address":[4831494],"length":1,"stats":{"Line":0}},{"line":27,"address":[3415460,3415543],"length":1,"stats":{"Line":0}},{"line":28,"address":[3415673,3416215],"length":1,"stats":{"Line":0}},{"line":30,"address":[3416363,3416427,3416274,3417229],"length":1,"stats":{"Line":0}},{"line":31,"address":[3712512,3712542],"length":1,"stats":{"Line":0}},{"line":34,"address":[3416738,3416585,3416674,3417227],"length":1,"stats":{"Line":0}},{"line":35,"address":[3416651,3416706],"length":1,"stats":{"Line":0}},{"line":38,"address":[3417206,3416930],"length":1,"stats":{"Line":0}},{"line":39,"address":[3417078,3417147],"length":1,"stats":{"Line":0}},{"line":40,"address":[3417113,3417167],"length":1,"stats":{"Line":0}},{"line":45,"address":[3415837,3415696],"length":1,"stats":{"Line":0}},{"line":46,"address":[4831890],"length":1,"stats":{"Line":0}},{"line":48,"address":[3415842,3415738],"length":1,"stats":{"Line":0}},{"line":53,"address":[3415722],"length":1,"stats":{"Line":0}},{"line":58,"address":[3418697,3417264,3418691],"length":1,"stats":{"Line":0}},{"line":64,"address":[3417359],"length":1,"stats":{"Line":0}},{"line":66,"address":[4833533,4833450],"length":1,"stats":{"Line":0}},{"line":67,"address":[3417599,3417733],"length":1,"stats":{"Line":0}},{"line":68,"address":[4833945,4833856,4834753,4834009],"length":1,"stats":{"Line":0}},{"line":69,"address":[3713056,3713086],"length":1,"stats":{"Line":0}},{"line":71,"address":[3418103,3418192,3418687,3418256],"length":1,"stats":{"Line":0}},{"line":72,"address":[4834233,4834288],"length":1,"stats":{"Line":0}},{"line":74,"address":[3418448,3418666],"length":1,"stats":{"Line":0}},{"line":75,"address":[3418593],"length":1,"stats":{"Line":0}},{"line":80,"address":[3417624],"length":1,"stats":{"Line":0}},{"line":85,"address":[3418720],"length":1,"stats":{"Line":0}},{"line":86,"address":[3418721],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["/","home","user","src","BTCDecoded","governance-app","src","crypto","signatures.rs"],"content":"use secp256k1::{PublicKey, Secp256k1, SecretKey, ecdsa::Signature};\nuse sha2::{Digest, Sha256};\nuse crate::error::GovernanceError;\n\npub struct SignatureManager {\n    secp: Secp256k1\u003csecp256k1::All\u003e,\n}\n\nimpl SignatureManager {\n    pub fn new() -\u003e Self {\n        Self {\n            secp: Secp256k1::new(),\n        }\n    }\n\n    pub fn create_signature(\n        \u0026self,\n        message: \u0026str,\n        secret_key: \u0026SecretKey,\n    ) -\u003e Result\u003cSignature, GovernanceError\u003e {\n        let message_hash = Sha256::digest(message.as_bytes());\n        let message_hash = secp256k1::Message::from_digest_slice(\u0026message_hash)\n            .map_err(|e| GovernanceError::CryptoError(format!(\"Invalid message hash: {}\", e)))?;\n\n        Ok(self.secp.sign_ecdsa(\u0026message_hash, secret_key))\n    }\n\n    pub fn verify_signature(\n        \u0026self,\n        message: \u0026str,\n        signature: \u0026Signature,\n        public_key: \u0026PublicKey,\n    ) -\u003e Result\u003cbool, GovernanceError\u003e {\n        let message_hash = Sha256::digest(message.as_bytes());\n        let message_hash = secp256k1::Message::from_digest_slice(\u0026message_hash)\n            .map_err(|e| GovernanceError::CryptoError(format!(\"Invalid message hash: {}\", e)))?;\n\n        match self.secp.verify_ecdsa(\u0026message_hash, signature, public_key) {\n            Ok(_) =\u003e Ok(true),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    pub fn public_key_from_secret(\u0026self, secret_key: \u0026SecretKey) -\u003e PublicKey {\n        PublicKey::from_secret_key(\u0026self.secp, secret_key)\n    }\n}\n\nimpl Default for SignatureManager {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n\n\n\n","traces":[{"line":10,"address":[3522400],"length":1,"stats":{"Line":0}},{"line":12,"address":[3522401],"length":1,"stats":{"Line":0}},{"line":16,"address":[3522416],"length":1,"stats":{"Line":0}},{"line":21,"address":[3522500],"length":1,"stats":{"Line":0}},{"line":22,"address":[3522565,3522666,3522518],"length":1,"stats":{"Line":0}},{"line":23,"address":[4063433,4063408],"length":1,"stats":{"Line":0}},{"line":25,"address":[3522810],"length":1,"stats":{"Line":0}},{"line":28,"address":[3522880],"length":1,"stats":{"Line":0}},{"line":34,"address":[4627330],"length":1,"stats":{"Line":0}},{"line":35,"address":[3522996,3523153,3523043],"length":1,"stats":{"Line":0}},{"line":36,"address":[3523022,3523089],"length":1,"stats":{"Line":0}},{"line":38,"address":[3523312],"length":1,"stats":{"Line":0}},{"line":39,"address":[3523375],"length":1,"stats":{"Line":0}},{"line":40,"address":[3523357],"length":1,"stats":{"Line":0}},{"line":44,"address":[3523408],"length":1,"stats":{"Line":0}},{"line":45,"address":[3523429],"length":1,"stats":{"Line":0}},{"line":50,"address":[3523456],"length":1,"stats":{"Line":0}},{"line":51,"address":[3523457],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":18},{"path":["/","home","user","src","BTCDecoded","governance-app","src","database","mod.rs"],"content":"pub mod models;\npub mod queries;\npub mod schema;\n\nuse sqlx::SqlitePool;\n\n#[derive(Clone)]\npub struct Database {\n    pool: SqlitePool,\n}\n\nimpl Database {\n    pub async fn new(database_url: \u0026str) -\u003e Result\u003cSelf, sqlx::Error\u003e {\n        let pool = SqlitePool::connect(database_url).await?;\n        Ok(Database { pool })\n    }\n\n    pub async fn new_in_memory() -\u003e Result\u003cSelf, sqlx::Error\u003e {\n        let pool = SqlitePool::connect(\"sqlite::memory:\").await?;\n        let db = Database { pool };\n        db.run_migrations().await?;\n        Ok(db)\n    }\n\n    pub async fn run_migrations(\u0026self) -\u003e Result\u003c(), sqlx::Error\u003e {\n        sqlx::migrate!(\"./migrations\").run(\u0026self.pool).await?;\n        Ok(())\n    }\n\n    pub async fn create_pull_request(\n        \u0026self,\n        repo_name: \u0026str,\n        pr_number: i32,\n        head_sha: \u0026str,\n        layer: i32,\n    ) -\u003e Result\u003c(), sqlx::Error\u003e {\n        sqlx::query(\n            r#\"\n            INSERT INTO pull_requests (repo_name, pr_number, opened_at, layer, head_sha)\n            VALUES (?, ?, CURRENT_TIMESTAMP, ?, ?)\n            ON CONFLICT (repo_name, pr_number) DO UPDATE SET\n                head_sha = EXCLUDED.head_sha,\n                updated_at = CURRENT_TIMESTAMP\n            \"#\n        )\n        .bind(repo_name)\n        .bind(pr_number)\n        .bind(layer)\n        .bind(head_sha)\n        .execute(\u0026self.pool)\n        .await?;\n        \n        Ok(())\n    }\n\n    pub async fn update_review_status(\n        \u0026self,\n        _repo_name: \u0026str,\n        _pr_number: i32,\n        _reviewer: \u0026str,\n        _state: \u0026str,\n    ) -\u003e Result\u003c(), sqlx::Error\u003e {\n        // This would update review status in the database\n        // Implementation depends on specific review tracking requirements\n        Ok(())\n    }\n\n    pub async fn add_signature(\n        \u0026self,\n        _repo_name: \u0026str,\n        _pr_number: i32,\n        _signer: \u0026str,\n        _signature: \u0026str,\n    ) -\u003e Result\u003c(), sqlx::Error\u003e {\n        // Add signature to the pull request\n        // This would involve updating the signatures JSONB field\n        Ok(())\n    }\n\n    pub async fn log_governance_event(\n        \u0026self,\n        event_type: \u0026str,\n        repo_name: Option\u003c\u0026str\u003e,\n        pr_number: Option\u003ci32\u003e,\n        maintainer: Option\u003c\u0026str\u003e,\n        details: \u0026serde_json::Value,\n    ) -\u003e Result\u003c(), sqlx::Error\u003e {\n        sqlx::query(\n            r#\"\n            INSERT INTO governance_events (event_type, repo_name, pr_number, maintainer, details)\n            VALUES (?, ?, ?, ?, ?)\n            \"#\n        )\n        .bind(event_type)\n        .bind(repo_name)\n        .bind(pr_number)\n        .bind(maintainer)\n        .bind(serde_json::to_string(details).unwrap_or_default())\n        .execute(\u0026self.pool)\n        .await?;\n        \n        Ok(())\n    }\n\n    pub async fn get_pull_request(\n        \u0026self,\n        _repo_name: \u0026str,\n        _pr_number: i32,\n    ) -\u003e Result\u003cOption\u003ccrate::database::models::PullRequest\u003e, sqlx::Error\u003e {\n        // This would retrieve a pull request from the database\n        // For now, return None as a placeholder\n        Ok(None)\n    }\n\n    pub async fn get_governance_events(\n        \u0026self,\n        _limit: i64,\n    ) -\u003e Result\u003cVec\u003ccrate::database::models::GovernanceEvent\u003e, sqlx::Error\u003e {\n        // This would retrieve governance events from the database\n        // For now, return empty vector as a placeholder\n        Ok(vec![])\n    }\n}\n\n\n\n\n","traces":[{"line":13,"address":[3471840,3471853],"length":1,"stats":{"Line":0}},{"line":14,"address":[3362493,3362640,3362563,3362459,3363062],"length":1,"stats":{"Line":0}},{"line":15,"address":[3362988],"length":1,"stats":{"Line":0}},{"line":18,"address":[3363122,3363072,3363271,3363379,3363207,3363941],"length":1,"stats":{"Line":0}},{"line":19,"address":[3363171,3363327,3363234,3363405,3363925],"length":1,"stats":{"Line":0}},{"line":20,"address":[3363767],"length":1,"stats":{"Line":0}},{"line":21,"address":[3363790,3363947,3363249,3363871],"length":1,"stats":{"Line":0}},{"line":22,"address":[3364297],"length":1,"stats":{"Line":0}},{"line":25,"address":[3365284,3364617,3364499,3365151,3364763,3364464],"length":1,"stats":{"Line":0}},{"line":26,"address":[3562137,3562153],"length":1,"stats":{"Line":0}},{"line":27,"address":[3365198],"length":1,"stats":{"Line":0}},{"line":30,"address":[3471920],"length":1,"stats":{"Line":0}},{"line":46,"address":[3365649],"length":1,"stats":{"Line":0}},{"line":47,"address":[3365696],"length":1,"stats":{"Line":0}},{"line":48,"address":[3365723],"length":1,"stats":{"Line":0}},{"line":49,"address":[3365740],"length":1,"stats":{"Line":0}},{"line":50,"address":[3365788],"length":1,"stats":{"Line":0}},{"line":51,"address":[3845193,3845267,3844683,3844915,3844949,3844996],"length":1,"stats":{"Line":0}},{"line":53,"address":[3366271],"length":1,"stats":{"Line":0}},{"line":56,"address":[3472016],"length":1,"stats":{"Line":0}},{"line":65,"address":[3366506],"length":1,"stats":{"Line":0}},{"line":68,"address":[3472128],"length":1,"stats":{"Line":0}},{"line":77,"address":[3366730],"length":1,"stats":{"Line":0}},{"line":80,"address":[3472240],"length":1,"stats":{"Line":0}},{"line":94,"address":[3367205],"length":1,"stats":{"Line":0}},{"line":95,"address":[3367258],"length":1,"stats":{"Line":0}},{"line":96,"address":[3846393],"length":1,"stats":{"Line":0}},{"line":97,"address":[3367322],"length":1,"stats":{"Line":0}},{"line":98,"address":[3367457,3367342,3367361,3367160,3367618],"length":1,"stats":{"Line":0}},{"line":99,"address":[3367493],"length":1,"stats":{"Line":0}},{"line":100,"address":[3367869,3367949,3367147,3367563,3367597,3367672],"length":1,"stats":{"Line":0}},{"line":102,"address":[3368063],"length":1,"stats":{"Line":0}},{"line":105,"address":[3472400],"length":1,"stats":{"Line":0}},{"line":112,"address":[3368261],"length":1,"stats":{"Line":0}},{"line":115,"address":[3472448],"length":1,"stats":{"Line":0}},{"line":121,"address":[3368531,3368460],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","home","user","src","BTCDecoded","governance-app","src","database","models.rs"],"content":"use serde::{Deserialize, Serialize};\nuse chrono::{DateTime, Utc};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PullRequest {\n    pub id: i32,\n    pub repo_name: String,\n    pub pr_number: i32,\n    pub opened_at: DateTime\u003cUtc\u003e,\n    pub layer: i32,\n    pub head_sha: String,\n    pub signatures: Vec\u003cSignature\u003e,\n    pub governance_status: String,\n    pub linked_prs: Vec\u003ci32\u003e,\n    pub emergency_mode: bool,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub updated_at: DateTime\u003cUtc\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Signature {\n    pub signer: String,\n    pub signature: String,\n    pub timestamp: DateTime\u003cUtc\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Maintainer {\n    pub id: i32,\n    pub github_username: String,\n    pub public_key: String,\n    pub layer: i32,\n    pub active: bool,\n    pub last_updated: DateTime\u003cUtc\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EmergencyKeyholder {\n    pub id: i32,\n    pub github_username: String,\n    pub public_key: String,\n    pub active: bool,\n    pub last_updated: DateTime\u003cUtc\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GovernanceEvent {\n    pub id: i32,\n    pub event_type: String,\n    pub repo_name: Option\u003cString\u003e,\n    pub pr_number: Option\u003ci32\u003e,\n    pub maintainer: Option\u003cString\u003e,\n    pub details: serde_json::Value,\n    pub timestamp: DateTime\u003cUtc\u003e,\n}\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","src","database","queries.rs"],"content":"use sqlx::SqlitePool;\nuse crate::database::models::*;\n\npub struct Queries;\n\nimpl Queries {\n    pub async fn get_pull_request(\n        _pool: \u0026SqlitePool,\n        _repo_name: \u0026str,\n        _pr_number: i32,\n    ) -\u003e Result\u003cOption\u003cPullRequest\u003e, sqlx::Error\u003e {\n        // TODO: Implement with proper SQLite query\n        Ok(None)\n    }\n\n    pub async fn get_maintainers_for_layer(\n        _pool: \u0026SqlitePool,\n        _layer: i32,\n    ) -\u003e Result\u003cVec\u003cMaintainer\u003e, sqlx::Error\u003e {\n        // TODO: Implement with proper SQLite query\n        Ok(vec![])\n    }\n\n    pub async fn get_emergency_keyholders(\n        _pool: \u0026SqlitePool,\n    ) -\u003e Result\u003cVec\u003cEmergencyKeyholder\u003e, sqlx::Error\u003e {\n        // TODO: Implement with proper SQLite query\n        Ok(vec![])\n    }\n\n    pub async fn get_governance_events(\n        _pool: \u0026SqlitePool,\n        _limit: i64,\n    ) -\u003e Result\u003cVec\u003cGovernanceEvent\u003e, sqlx::Error\u003e {\n        // TODO: Implement with proper SQLite query\n        Ok(vec![])\n    }\n}","traces":[{"line":7,"address":[3420672],"length":1,"stats":{"Line":0}},{"line":13,"address":[3360149],"length":1,"stats":{"Line":0}},{"line":16,"address":[3420720],"length":1,"stats":{"Line":0}},{"line":21,"address":[3360346,3360417],"length":1,"stats":{"Line":0}},{"line":24,"address":[3420752],"length":1,"stats":{"Line":0}},{"line":28,"address":[3360607,3360679],"length":1,"stats":{"Line":0}},{"line":31,"address":[3420768],"length":1,"stats":{"Line":0}},{"line":36,"address":[3360963,3360892],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","home","user","src","BTCDecoded","governance-app","src","database","schema.rs"],"content":"// Database schema definitions and migrations\n// This module contains the SQL schema for the governance app database\n\npub const INITIAL_SCHEMA: \u0026str = include_str!(\"../../migrations/001_initial_schema.sql\");\npub const EMERGENCY_MODE_SCHEMA: \u0026str = include_str!(\"../../migrations/002_emergency_mode.sql\");\npub const AUDIT_LOG_SCHEMA: \u0026str = include_str!(\"../../migrations/003_audit_log.sql\");\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","src","enforcement","merge_block.rs"],"content":"use crate::error::GovernanceError;\n\npub struct MergeBlocker;\n\nimpl MergeBlocker {\n    pub fn should_block_merge(\n        review_period_met: bool,\n        signatures_met: bool,\n        emergency_mode: bool,\n    ) -\u003e Result\u003cbool, GovernanceError\u003e {\n        // In emergency mode, only signature threshold matters\n        if emergency_mode {\n            Ok(!signatures_met)\n        } else {\n            // Normal mode: both review period and signatures must be met\n            Ok(!(review_period_met \u0026\u0026 signatures_met))\n        }\n    }\n\n    pub fn get_block_reason(\n        review_period_met: bool,\n        signatures_met: bool,\n        emergency_mode: bool,\n    ) -\u003e String {\n        if emergency_mode {\n            if !signatures_met {\n                \"Emergency mode: Signature threshold not met\".to_string()\n            } else {\n                \"Emergency mode: All requirements met\".to_string()\n            }\n        } else {\n            if !review_period_met \u0026\u0026 !signatures_met {\n                \"Both review period and signature requirements not met\".to_string()\n            } else if !review_period_met {\n                \"Review period requirement not met\".to_string()\n            } else if !signatures_met {\n                \"Signature threshold requirement not met\".to_string()\n            } else {\n                \"All governance requirements met\".to_string()\n            }\n        }\n    }\n}\n\n\n\n\n","traces":[{"line":6,"address":[4128592],"length":1,"stats":{"Line":0}},{"line":12,"address":[3384944,3384983],"length":1,"stats":{"Line":0}},{"line":13,"address":[3384967],"length":1,"stats":{"Line":0}},{"line":16,"address":[3384952,3384985],"length":1,"stats":{"Line":0}},{"line":20,"address":[3385040],"length":1,"stats":{"Line":0}},{"line":25,"address":[3385092],"length":1,"stats":{"Line":0}},{"line":26,"address":[3385110],"length":1,"stats":{"Line":0}},{"line":27,"address":[3385266],"length":1,"stats":{"Line":0}},{"line":29,"address":[3385291],"length":1,"stats":{"Line":0}},{"line":32,"address":[3385100,3385127],"length":1,"stats":{"Line":0}},{"line":33,"address":[3385148],"length":1,"stats":{"Line":0}},{"line":34,"address":[3385137],"length":1,"stats":{"Line":0}},{"line":35,"address":[3385181],"length":1,"stats":{"Line":0}},{"line":36,"address":[3385205],"length":1,"stats":{"Line":0}},{"line":37,"address":[3385216],"length":1,"stats":{"Line":0}},{"line":39,"address":[3385241],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","user","src","BTCDecoded","governance-app","src","enforcement","mod.rs"],"content":"pub mod status_checks;\npub mod merge_block;\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","src","enforcement","status_checks.rs"],"content":"use chrono::{DateTime, Utc};\nuse crate::validation::review_period::ReviewPeriodValidator;\nuse crate::validation::threshold::ThresholdValidator;\nuse crate::validation::emergency::{EmergencyTier, ActiveEmergency};\n\npub struct StatusCheckGenerator;\n\nimpl StatusCheckGenerator {\n    pub fn generate_review_period_status(\n        opened_at: DateTime\u003cUtc\u003e,\n        required_days: i64,\n        emergency_mode: bool,\n    ) -\u003e String {\n        let remaining_days = ReviewPeriodValidator::get_remaining_days(\n            opened_at,\n            required_days,\n            emergency_mode,\n        );\n\n        if remaining_days \u003e 0 {\n            let earliest_merge = ReviewPeriodValidator::get_earliest_merge_date(\n                opened_at,\n                required_days,\n                emergency_mode,\n            );\n\n            format!(\n                \"‚ùå Governance: Review Period Not Met\\nRequired: {} days | Elapsed: {} days\\nEarliest merge: {}\",\n                required_days,\n                (Utc::now() - opened_at).num_days(),\n                earliest_merge.format(\"%Y-%m-%d\")\n            )\n        } else {\n            \"‚úÖ Governance: Review Period Met\".to_string()\n        }\n    }\n\n    pub fn generate_signature_status(\n        current_signatures: usize,\n        required_signatures: usize,\n        total_maintainers: usize,\n        signers: \u0026[String],\n        pending: \u0026[String],\n    ) -\u003e String {\n        if current_signatures \u003e= required_signatures {\n            \"‚úÖ Governance: Signatures Complete\".to_string()\n        } else {\n            ThresholdValidator::format_threshold_status(\n                current_signatures,\n                required_signatures,\n                total_maintainers,\n                signers,\n                pending,\n            )\n        }\n    }\n\n    pub fn generate_combined_status(\n        review_period_met: bool,\n        signatures_met: bool,\n        review_period_status: \u0026str,\n        signature_status: \u0026str,\n    ) -\u003e String {\n        if review_period_met \u0026\u0026 signatures_met {\n            \"‚úÖ Governance: All Requirements Met - Ready to Merge\".to_string()\n        } else {\n            format!(\n                \"‚ùå Governance: Requirements Not Met\\n\\n{}\\n\\n{}\",\n                review_period_status,\n                signature_status\n            )\n        }\n    }\n\n    /// Generate status check message for active emergency tier\n    pub fn generate_emergency_status(emergency: \u0026ActiveEmergency) -\u003e String {\n        let tier = emergency.tier;\n        let emoji = tier.emoji();\n        let name = tier.name();\n        let (sig_required, sig_total) = tier.signature_threshold();\n        let review_days = tier.review_period_days();\n        let remaining = emergency.remaining_duration();\n        \n        let expiration_text = if remaining.num_hours() \u003c 24 {\n            format!(\"‚è∞ Expires in {} hours\", remaining.num_hours())\n        } else {\n            format!(\"Expires in {} days\", remaining.num_days())\n        };\n\n        let extension_text = if emergency.can_extend() {\n            let max_ext = tier.max_extensions();\n            let used_ext = emergency.extension_count;\n            format!(\n                \"\\nüìã Extensions: {} of {} used (can extend by {} days)\",\n                used_ext,\n                max_ext,\n                tier.extension_duration_days()\n            )\n        } else if tier.allows_extensions() \u0026\u0026 emergency.extension_count \u003e= tier.max_extensions() {\n            \"\\n‚ö†Ô∏è Maximum extensions reached\".to_string()\n        } else {\n            \"\\nüö´ Extensions not allowed for this tier\".to_string()\n        };\n\n        format!(\n            \"{} Emergency Tier Active: {}\\n\\\n            üìä Requirements: {}-of-{} signatures, {} day review period\\n\\\n            {}{}\\n\\\n            \\n\\\n            Reason: {}\\n\\\n            Activated by: {} on {}\",\n            emoji,\n            name,\n            sig_required,\n            sig_total,\n            review_days,\n            expiration_text,\n            extension_text,\n            emergency.reason,\n            emergency.activated_by,\n            emergency.activated_at.format(\"%Y-%m-%d %H:%M UTC\")\n        )\n    }\n\n    /// Generate status check for emergency tier expiration warning\n    pub fn generate_emergency_expiration_warning(emergency: \u0026ActiveEmergency) -\u003e String {\n        let remaining = emergency.remaining_duration();\n        let tier = emergency.tier;\n        let emoji = tier.emoji();\n\n        if remaining.num_hours() \u003c 24 {\n            format!(\n                \"‚ö†Ô∏è {} Emergency Tier Expiring Soon\\n\\\n                ‚è∞ Less than 24 hours remaining\\n\\\n                Expires at: {}\\n\\\n                \\n\\\n                {}\",\n                emoji,\n                emergency.expires_at.format(\"%Y-%m-%d %H:%M UTC\"),\n                if emergency.can_extend() {\n                    format!(\n                        \"Extension available: requires {}-of-{} signatures\",\n                        tier.extension_threshold().0,\n                        tier.extension_threshold().1\n                    )\n                } else {\n                    \"Extensions not available for this tier\".to_string()\n                }\n            )\n        } else if remaining.num_days() \u003c 3 {\n            format!(\n                \"‚ö†Ô∏è {} Emergency Tier Expiring Soon\\n\\\n                ‚è∞ {} days remaining\\n\\\n                Expires at: {}\",\n                emoji,\n                remaining.num_days(),\n                emergency.expires_at.format(\"%Y-%m-%d %H:%M UTC\")\n            )\n        } else {\n            String::new()\n        }\n    }\n\n    /// Generate combined status with emergency tier\n    pub fn generate_combined_status_with_emergency(\n        review_period_met: bool,\n        signatures_met: bool,\n        review_period_status: \u0026str,\n        signature_status: \u0026str,\n        emergency: Option\u003c\u0026ActiveEmergency\u003e,\n    ) -\u003e String {\n        let base_status = if review_period_met \u0026\u0026 signatures_met {\n            \"‚úÖ Governance: All Requirements Met - Ready to Merge\".to_string()\n        } else {\n            format!(\n                \"‚ùå Governance: Requirements Not Met\\n\\n{}\\n\\n{}\",\n                review_period_status,\n                signature_status\n            )\n        };\n\n        if let Some(emerg) = emergency {\n            let emergency_status = Self::generate_emergency_status(emerg);\n            let expiration_warning = Self::generate_emergency_expiration_warning(emerg);\n            \n            if expiration_warning.is_empty() {\n                format!(\"{}\\n\\n---\\n\\n{}\", emergency_status, base_status)\n            } else {\n                format!(\n                    \"{}\\n\\n---\\n\\n{}\\n\\n---\\n\\n{}\",\n                    emergency_status,\n                    expiration_warning,\n                    base_status\n                )\n            }\n        } else {\n            base_status\n        }\n    }\n\n    /// Generate post-emergency requirements status\n    pub fn generate_post_emergency_requirements(\n        tier: EmergencyTier,\n        post_mortem_published: bool,\n        post_mortem_deadline: DateTime\u003cUtc\u003e,\n        security_audit_completed: bool,\n        security_audit_deadline: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    ) -\u003e String {\n        let mut status = format!(\"üìã Post-Emergency Requirements for {}\\n\\n\", tier.name());\n\n        // Post-mortem status\n        let pm_status = if post_mortem_published {\n            \"‚úÖ Post-mortem published\"\n        } else if Utc::now() \u003e post_mortem_deadline {\n            \"‚ùå Post-mortem OVERDUE\"\n        } else {\n            let days_remaining = (post_mortem_deadline - Utc::now()).num_days();\n            if days_remaining \u003c 7 {\n                \"‚ö†Ô∏è Post-mortem due soon\"\n            } else {\n                \"‚è≥ Post-mortem pending\"\n            }\n        };\n        \n        status.push_str(\u0026format!(\n            \"{}\\nDeadline: {}\\n\",\n            pm_status,\n            post_mortem_deadline.format(\"%Y-%m-%d\")\n        ));\n\n        // Security audit status (if required)\n        if tier.requires_security_audit() {\n            if let Some(audit_deadline) = security_audit_deadline {\n                let audit_status = if security_audit_completed {\n                    \"‚úÖ Security audit completed\"\n                } else if Utc::now() \u003e audit_deadline {\n                    \"‚ùå Security audit OVERDUE\"\n                } else {\n                    let days_remaining = (audit_deadline - Utc::now()).num_days();\n                    if days_remaining \u003c 14 {\n                        \"‚ö†Ô∏è Security audit due soon\"\n                    } else {\n                        \"‚è≥ Security audit pending\"\n                    }\n                };\n                \n                status.push_str(\u0026format!(\n                    \"\\n{}\\nDeadline: {}\",\n                    audit_status,\n                    audit_deadline.format(\"%Y-%m-%d\")\n                ));\n            }\n        }\n\n        status\n    }\n}\n\n\n\n","traces":[{"line":9,"address":[3585173,3584528],"length":1,"stats":{"Line":0}},{"line":16,"address":[4004400],"length":1,"stats":{"Line":0}},{"line":20,"address":[3584629],"length":1,"stats":{"Line":0}},{"line":23,"address":[3584672],"length":1,"stats":{"Line":0}},{"line":27,"address":[3584948,3584876],"length":1,"stats":{"Line":0}},{"line":30,"address":[3584727],"length":1,"stats":{"Line":0}},{"line":31,"address":[3584836],"length":1,"stats":{"Line":0}},{"line":34,"address":[3584640],"length":1,"stats":{"Line":0}},{"line":38,"address":[3585200],"length":1,"stats":{"Line":0}},{"line":45,"address":[3585320],"length":1,"stats":{"Line":0}},{"line":46,"address":[3585386],"length":1,"stats":{"Line":0}},{"line":58,"address":[3585424],"length":1,"stats":{"Line":0}},{"line":64,"address":[3585714,3585509],"length":1,"stats":{"Line":0}},{"line":65,"address":[4005552],"length":1,"stats":{"Line":0}},{"line":67,"address":[3585517],"length":1,"stats":{"Line":0}},{"line":76,"address":[4007417,4005584,4007411],"length":1,"stats":{"Line":0}},{"line":77,"address":[3585790],"length":1,"stats":{"Line":0}},{"line":78,"address":[3585797],"length":1,"stats":{"Line":0}},{"line":79,"address":[3585817],"length":1,"stats":{"Line":0}},{"line":80,"address":[4005661],"length":1,"stats":{"Line":0}},{"line":81,"address":[4005679],"length":1,"stats":{"Line":0}},{"line":82,"address":[3585874],"length":1,"stats":{"Line":0}},{"line":84,"address":[4005712],"length":1,"stats":{"Line":0}},{"line":85,"address":[3586057],"length":1,"stats":{"Line":0}},{"line":87,"address":[3585908],"length":1,"stats":{"Line":0}},{"line":90,"address":[3586206,3586265],"length":1,"stats":{"Line":0}},{"line":91,"address":[3586292,3586482],"length":1,"stats":{"Line":0}},{"line":92,"address":[3586489],"length":1,"stats":{"Line":0}},{"line":93,"address":[3586534],"length":1,"stats":{"Line":0}},{"line":97,"address":[3586504],"length":1,"stats":{"Line":0}},{"line":99,"address":[3586276,3586310,3586352],"length":1,"stats":{"Line":0}},{"line":100,"address":[3586471,3586387],"length":1,"stats":{"Line":0}},{"line":102,"address":[3586316,3586418],"length":1,"stats":{"Line":0}},{"line":105,"address":[4006675,4006249],"length":1,"stats":{"Line":0}},{"line":121,"address":[3586437],"length":1,"stats":{"Line":0}},{"line":126,"address":[3588181,3588175,3587616],"length":1,"stats":{"Line":0}},{"line":127,"address":[3587654],"length":1,"stats":{"Line":0}},{"line":128,"address":[3587673],"length":1,"stats":{"Line":0}},{"line":129,"address":[3587680],"length":1,"stats":{"Line":0}},{"line":131,"address":[3587700],"length":1,"stats":{"Line":0}},{"line":132,"address":[3588644,3588194,3588303],"length":1,"stats":{"Line":0}},{"line":139,"address":[3587739],"length":1,"stats":{"Line":0}},{"line":140,"address":[3587773,3588239],"length":1,"stats":{"Line":0}},{"line":141,"address":[4008277],"length":1,"stats":{"Line":0}},{"line":143,"address":[4008105,4008205],"length":1,"stats":{"Line":0}},{"line":144,"address":[4008224],"length":1,"stats":{"Line":0}},{"line":147,"address":[4008069,4008120],"length":1,"stats":{"Line":0}},{"line":150,"address":[3587716],"length":1,"stats":{"Line":0}},{"line":151,"address":[4007762,4007690],"length":1,"stats":{"Line":0}},{"line":156,"address":[3587804],"length":1,"stats":{"Line":0}},{"line":157,"address":[4007646],"length":1,"stats":{"Line":0}},{"line":160,"address":[3587792],"length":1,"stats":{"Line":0}},{"line":165,"address":[3588896,3590059,3590053],"length":1,"stats":{"Line":0}},{"line":172,"address":[3588989,3589210],"length":1,"stats":{"Line":0}},{"line":173,"address":[4009049],"length":1,"stats":{"Line":0}},{"line":175,"address":[3589005],"length":1,"stats":{"Line":0}},{"line":182,"address":[4009186,4009080],"length":1,"stats":{"Line":0}},{"line":183,"address":[3589316],"length":1,"stats":{"Line":0}},{"line":184,"address":[4009245],"length":1,"stats":{"Line":0}},{"line":186,"address":[4009301,4009357],"length":1,"stats":{"Line":0}},{"line":187,"address":[4009701,4009443],"length":1,"stats":{"Line":0}},{"line":189,"address":[3589547,3589670],"length":1,"stats":{"Line":0}},{"line":197,"address":[3589328],"length":1,"stats":{"Line":0}},{"line":202,"address":[4011966,4009936],"length":1,"stats":{"Line":0}},{"line":209,"address":[4010011],"length":1,"stats":{"Line":0}},{"line":212,"address":[4010173,4010223],"length":1,"stats":{"Line":0}},{"line":213,"address":[4010196],"length":1,"stats":{"Line":0}},{"line":214,"address":[3590746,3590353,3590554,3590461],"length":1,"stats":{"Line":0}},{"line":215,"address":[4010351],"length":1,"stats":{"Line":0}},{"line":217,"address":[3590487,3590559],"length":1,"stats":{"Line":0}},{"line":218,"address":[4010476,4010538,4010509],"length":1,"stats":{"Line":0}},{"line":219,"address":[3590687],"length":1,"stats":{"Line":0}},{"line":221,"address":[3590658],"length":1,"stats":{"Line":0}},{"line":225,"address":[3590818,3591150],"length":1,"stats":{"Line":0}},{"line":228,"address":[4010607],"length":1,"stats":{"Line":0}},{"line":232,"address":[3591199],"length":1,"stats":{"Line":0}},{"line":233,"address":[4011105],"length":1,"stats":{"Line":0}},{"line":234,"address":[3591333,3591383],"length":1,"stats":{"Line":0}},{"line":235,"address":[4011180],"length":1,"stats":{"Line":0}},{"line":236,"address":[3591693,3591404,3591501,3591337],"length":1,"stats":{"Line":0}},{"line":237,"address":[4011298],"length":1,"stats":{"Line":0}},{"line":239,"address":[3591506,3591425],"length":1,"stats":{"Line":0}},{"line":240,"address":[3591632,3591661,3591599],"length":1,"stats":{"Line":0}},{"line":241,"address":[3591634],"length":1,"stats":{"Line":0}},{"line":243,"address":[3591605],"length":1,"stats":{"Line":0}},{"line":247,"address":[3591768,3592098],"length":1,"stats":{"Line":0}},{"line":250,"address":[3591725],"length":1,"stats":{"Line":0}},{"line":255,"address":[3591233],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":88},{"path":["/","home","user","src","BTCDecoded","governance-app","src","error.rs"],"content":"use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum GovernanceError {\n    #[error(\"Configuration error: {0}\")]\n    ConfigError(String),\n    \n    #[error(\"Database error: {0}\")]\n    DatabaseError(String),\n    \n    #[error(\"GitHub API error: {0}\")]\n    GitHubError(String),\n    \n    #[error(\"Validation error: {0}\")]\n    ValidationError(String),\n    \n    #[error(\"Cryptographic error: {0}\")]\n    CryptoError(String),\n    \n    #[error(\"Webhook processing error: {0}\")]\n    WebhookError(String),\n    \n    #[error(\"Signature verification failed: {0}\")]\n    SignatureError(String),\n    \n    #[error(\"Review period not met: {0}\")]\n    ReviewPeriodError(String),\n    \n    #[error(\"Threshold not satisfied: {0}\")]\n    ThresholdError(String),\n}\n\n// Type alias for compatibility with emergency module\npub type GovernanceAppError = GovernanceError;\n\n// Additional error variants for emergency tier system\nimpl GovernanceError {\n    pub fn invalid_emergency_tier(tier: i32) -\u003e Self {\n        Self::ValidationError(format!(\"Invalid emergency tier: {}. Must be 1, 2, or 3\", tier))\n    }\n\n    pub fn insufficient_evidence(length: usize) -\u003e Self {\n        Self::ValidationError(format!(\"Insufficient evidence: {} characters (minimum 100 required)\", length))\n    }\n\n    pub fn insufficient_signatures(required: usize, found: usize, threshold: String) -\u003e Self {\n        Self::ValidationError(format!(\n            \"Insufficient signatures: found {}, required {} (threshold: {})\",\n            found, required, threshold\n        ))\n    }\n\n    pub fn invalid_signature(msg: String) -\u003e Self {\n        Self::SignatureError(msg)\n    }\n\n    pub fn extension_not_allowed(tier: String) -\u003e Self {\n        Self::ValidationError(format!(\"Extensions not allowed for tier: {}\", tier))\n    }\n\n    pub fn max_extensions_reached(current: u32, max: u32) -\u003e Self {\n        Self::ValidationError(format!(\n            \"Maximum extensions reached: {} of {} used\",\n            current, max\n        ))\n    }\n\n    pub fn emergency_expired(id: i32) -\u003e Self {\n        Self::ValidationError(format!(\"Emergency tier {} has expired\", id))\n    }\n}\n\n// Helper functions that match emergency.rs error constructors\nimpl GovernanceError {\n    pub fn InvalidEmergencyTier(tier: i32) -\u003e Self {\n        Self::invalid_emergency_tier(tier)\n    }\n\n    pub fn InsufficientEvidence(length: usize) -\u003e Self {\n        Self::insufficient_evidence(length)\n    }\n\n    pub fn InsufficientSignatures(args: InsufficientSignaturesArgs) -\u003e Self {\n        Self::insufficient_signatures(args.required, args.found, args.threshold)\n    }\n\n    pub fn InvalidSignature(msg: String) -\u003e Self {\n        Self::invalid_signature(msg)\n    }\n\n    pub fn ExtensionNotAllowed(tier: String) -\u003e Self {\n        Self::extension_not_allowed(tier)\n    }\n\n    pub fn MaxExtensionsReached(args: MaxExtensionsReachedArgs) -\u003e Self {\n        Self::max_extensions_reached(args.current, args.max)\n    }\n\n    pub fn EmergencyExpired(id: i32) -\u003e Self {\n        Self::emergency_expired(id)\n    }\n}\n\npub struct InsufficientSignaturesArgs {\n    pub required: usize,\n    pub found: usize,\n    pub threshold: String,\n}\n\npub struct MaxExtensionsReachedArgs {\n    pub current: u32,\n    pub max: u32,\n}\n\n\n\n","traces":[{"line":34,"address":[27187010],"length":1,"stats":{"Line":0}},{"line":37,"address":[28646848,28646090,28644671],"length":1,"stats":{"Line":0}},{"line":38,"address":[26334107],"length":1,"stats":{"Line":2}},{"line":39,"address":[42773801],"length":1,"stats":{"Line":2}},{"line":42,"address":[27187282],"length":1,"stats":{"Line":0}},{"line":43,"address":[6214099],"length":1,"stats":{"Line":0}},{"line":46,"address":[15930434],"length":1,"stats":{"Line":0}},{"line":47,"address":[26332508,26333585],"length":1,"stats":{"Line":0}},{"line":48,"address":[24567500,24567738],"length":1,"stats":{"Line":0}},{"line":49,"address":[6214320],"length":1,"stats":{"Line":0}},{"line":53,"address":[38400313,38400327,38400250],"length":1,"stats":{"Line":0}},{"line":54,"address":[27185592],"length":1,"stats":{"Line":0}},{"line":57,"address":[24567803],"length":1,"stats":{"Line":0}},{"line":58,"address":[23714908],"length":1,"stats":{"Line":0}},{"line":61,"address":[21667802,21668594,21666495],"length":1,"stats":{"Line":0}},{"line":62,"address":[38816966],"length":1,"stats":{"Line":0}},{"line":63,"address":[4197277,4197088,4197118,4197232],"length":1,"stats":{"Line":0}},{"line":64,"address":[38400383],"length":1,"stats":{"Line":0}},{"line":68,"address":[3677904],"length":1,"stats":{"Line":0}},{"line":69,"address":[6228265,6228522],"length":1,"stats":{"Line":0}},{"line":74,"address":[25507883],"length":1,"stats":{"Line":0}},{"line":75,"address":[38817157],"length":1,"stats":{"Line":2}},{"line":76,"address":[27793529,27792221,27794267],"length":1,"stats":{"Line":2}},{"line":79,"address":[5033575,5035903,5035801,5030478,5030428,5035852],"length":1,"stats":{"Line":0}},{"line":80,"address":[33306408],"length":1,"stats":{"Line":0}},{"line":83,"address":[24568200],"length":1,"stats":{"Line":0}},{"line":84,"address":[5036000,5036068,5030552,5030582,5033764,5036034],"length":1,"stats":{"Line":0}},{"line":87,"address":[36397545],"length":1,"stats":{"Line":0}},{"line":88,"address":[4760114,4765597,4765563,4765529,4760084,4763292],"length":1,"stats":{"Line":0}},{"line":91,"address":[38400671],"length":1,"stats":{"Line":0}},{"line":92,"address":[25507826],"length":1,"stats":{"Line":0}},{"line":95,"address":[35694015,35693978],"length":1,"stats":{"Line":0}},{"line":96,"address":[3808852],"length":1,"stats":{"Line":0}},{"line":99,"address":[5412788],"length":1,"stats":{"Line":0}},{"line":100,"address":[3678352],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":35},{"path":["/","home","user","src","BTCDecoded","governance-app","src","github","client.rs"],"content":"use octocrab::Octocrab;\nuse crate::error::GovernanceError;\n\npub struct GitHubClient {\n    client: Octocrab,\n}\n\nimpl GitHubClient {\n    pub fn new(app_id: u64, private_key_path: \u0026str) -\u003e Result\u003cSelf, GovernanceError\u003e {\n        let key = std::fs::read_to_string(private_key_path)\n            .map_err(|e| GovernanceError::ConfigError(format!(\"Failed to read private key: {}\", e)))?;\n\n        let client = Octocrab::builder()\n            .app(app_id.into(), jsonwebtoken::EncodingKey::from_rsa_pem(key.as_bytes())\n                .map_err(|e| GovernanceError::GitHubError(format!(\"Failed to parse private key: {}\", e)))?)\n            .build()\n            .map_err(|e| GovernanceError::GitHubError(format!(\"Failed to create GitHub client: {}\", e)))?;\n\n        Ok(Self { client })\n    }\n\n    pub async fn post_status_check(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n        _sha: \u0026str,\n        _state: \u0026str,\n        _description: \u0026str,\n        _context: \u0026str,\n    ) -\u003e Result\u003c(), GovernanceError\u003e {\n        // This would post a status check to GitHub\n        // Implementation depends on specific GitHub API requirements\n        Ok(())\n    }\n\n    pub async fn get_repository_info(\n        \u0026self,\n        _owner: \u0026str,\n        _repo: \u0026str,\n    ) -\u003e Result\u003cserde_json::Value, GovernanceError\u003e {\n        // This would fetch repository information\n        // Implementation depends on specific GitHub API requirements\n        Ok(serde_json::json!({}))\n    }\n}\n\n\n\n\n","traces":[{"line":9,"address":[4546832,4547891,4547885],"length":1,"stats":{"Line":0}},{"line":10,"address":[3733873,3733736,3733776],"length":1,"stats":{"Line":0}},{"line":11,"address":[3514912,3514934],"length":1,"stats":{"Line":0}},{"line":13,"address":[3734291,3734651,3734449,3733950,3734530],"length":1,"stats":{"Line":0}},{"line":14,"address":[3734229,3734015,3734299,3734171,3734088],"length":1,"stats":{"Line":0}},{"line":15,"address":[3515203,3515168],"length":1,"stats":{"Line":0}},{"line":17,"address":[3515424,3515454],"length":1,"stats":{"Line":0}},{"line":19,"address":[3734578],"length":1,"stats":{"Line":0}},{"line":22,"address":[3734736],"length":1,"stats":{"Line":0}},{"line":33,"address":[3515908],"length":1,"stats":{"Line":0}},{"line":36,"address":[3734944],"length":1,"stats":{"Line":0}},{"line":43,"address":[3516205,3516127],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","home","user","src","BTCDecoded","governance-app","src","github","mod.rs"],"content":"pub mod client;\npub mod types;\npub mod webhooks;\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","src","github","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PullRequest {\n    pub number: u64,\n    pub title: String,\n    pub body: Option\u003cString\u003e,\n    pub head: CommitRef,\n    pub base: CommitRef,\n    pub user: User,\n    pub created_at: String,\n    pub updated_at: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CommitRef {\n    pub sha: String,\n    pub ref_field: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct User {\n    pub login: String,\n    pub id: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Repository {\n    pub name: String,\n    pub full_name: String,\n    pub owner: User,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WebhookPayload {\n    pub action: String,\n    pub pull_request: Option\u003cPullRequest\u003e,\n    pub repository: Option\u003cRepository\u003e,\n    pub issue: Option\u003cIssue\u003e,\n    pub comment: Option\u003cComment\u003e,\n    pub review: Option\u003cReview\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Issue {\n    pub number: u64,\n    pub title: String,\n    pub user: User,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Comment {\n    pub body: String,\n    pub user: User,\n    pub created_at: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Review {\n    pub state: String,\n    pub user: User,\n    pub body: Option\u003cString\u003e,\n}\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","src","github","webhooks.rs"],"content":"use serde_json::Value;\nuse crate::error::GovernanceError;\n\npub struct WebhookProcessor;\n\nimpl WebhookProcessor {\n    pub fn process_webhook(payload: \u0026Value) -\u003e Result\u003cWebhookEvent, GovernanceError\u003e {\n        let action = payload\n            .get(\"action\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"unknown\");\n\n        let event_type = match action {\n            \"opened\" | \"synchronize\" | \"reopened\" =\u003e WebhookEventType::PullRequest,\n            \"submitted\" =\u003e WebhookEventType::Review,\n            \"created\" =\u003e WebhookEventType::Comment,\n            \"push\" =\u003e WebhookEventType::Push,\n            _ =\u003e WebhookEventType::Unknown,\n        };\n\n        Ok(WebhookEvent {\n            event_type,\n            action: action.to_string(),\n            payload: payload.clone(),\n        })\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum WebhookEventType {\n    PullRequest,\n    Review,\n    Comment,\n    Push,\n    Unknown,\n}\n\n#[derive(Debug, Clone)]\npub struct WebhookEvent {\n    pub event_type: WebhookEventType,\n    pub action: String,\n    pub payload: Value,\n}\n\n\n\n\n","traces":[{"line":7,"address":[4764070,4763504,4764064],"length":1,"stats":{"Line":0}},{"line":10,"address":[3718864,3718873],"length":1,"stats":{"Line":0}},{"line":14,"address":[3743128],"length":1,"stats":{"Line":0}},{"line":15,"address":[3743287,3743233],"length":1,"stats":{"Line":0}},{"line":16,"address":[3743264,3743327],"length":1,"stats":{"Line":0}},{"line":17,"address":[3743341,3743304],"length":1,"stats":{"Line":0}},{"line":18,"address":[3743334],"length":1,"stats":{"Line":0}},{"line":21,"address":[3743448],"length":1,"stats":{"Line":0}},{"line":22,"address":[3743356],"length":1,"stats":{"Line":0}},{"line":23,"address":[3743364],"length":1,"stats":{"Line":0}},{"line":24,"address":[3743391],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","user","src","BTCDecoded","governance-app","src","lib.rs"],"content":"pub mod config;\npub mod error;\npub mod webhooks;\npub mod validation;\npub mod enforcement;\npub mod database;\npub mod crypto;\npub mod github;\n\npub use error::GovernanceError;\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","src","main.rs"],"content":"use axum::{\n    extract::State,\n    http::StatusCode,\n    response::Json,\n    routing::{get, post},\n    Router,\n};\nuse std::net::SocketAddr;\nuse tower::ServiceBuilder;\nuse tower_http::trace::TraceLayer;\nuse tracing::{info, Level};\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\nmod config;\nmod error;\nmod webhooks;\nmod validation;\nmod enforcement;\nmod database;\nmod crypto;\nmod github;\n\nuse config::AppConfig;\nuse database::Database;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Initialize tracing\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| \"governance_app=debug,tower_http=debug\".into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n\n    info!(\"Starting BTCDecoded Governance App\");\n\n    // Load configuration\n    let config = AppConfig::load()?;\n    info!(\"Configuration loaded\");\n\n    // Initialize database\n    let database = Database::new(\u0026config.database_url).await?;\n    info!(\"Database connected\");\n\n    // Run migrations\n    database.run_migrations().await?;\n    info!(\"Database migrations completed\");\n\n    // Build application\n    let app = Router::new()\n        .route(\"/health\", get(health_check))\n        .route(\"/webhooks/github\", post(webhooks::github::handle_webhook))\n        .layer(\n            ServiceBuilder::new()\n                .layer(TraceLayer::new_for_http())\n                .into_inner(),\n        )\n        .with_state((config, database));\n\n    // Start server\n    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));\n    info!(\"Server listening on {}\", addr);\n\n    let listener = tokio::net::TcpListener::bind(addr).await?;\n    axum::serve(listener, app).await?;\n\n    Ok(())\n}\n\nasync fn health_check() -\u003e Json\u003cserde_json::Value\u003e {\n    Json(serde_json::json!({\n        \"status\": \"healthy\",\n        \"service\": \"governance-app\",\n        \"timestamp\": chrono::Utc::now()\n    }))\n}\n\n\n\n\n","traces":[{"line":27,"address":[4851760,4852202,4852208],"length":1,"stats":{"Line":0}},{"line":29,"address":[3933505,3933616,3933147],"length":1,"stats":{"Line":0}},{"line":31,"address":[3933410],"length":1,"stats":{"Line":0}},{"line":32,"address":[3933475,3947616,3947632],"length":1,"stats":{"Line":0}},{"line":34,"address":[3933648,3933568,3938038,3933575],"length":1,"stats":{"Line":0}},{"line":37,"address":[3934260,3947785,3947919,3933728],"length":1,"stats":{"Line":0}},{"line":40,"address":[3934243,3938002,3935663],"length":1,"stats":{"Line":0}},{"line":41,"address":[3936479,3935962,3948345,3935879,3948479],"length":1,"stats":{"Line":0}},{"line":44,"address":[3936434,3937890,3940588,3933299,3938120],"length":1,"stats":{"Line":0}},{"line":45,"address":[3939141,3938546,3938629,3949039,3948905],"length":1,"stats":{"Line":0}},{"line":48,"address":[3933320,3940645,3946148,3939101,3940502],"length":1,"stats":{"Line":0}},{"line":49,"address":[3941561,3941029,3949599,3949465],"length":1,"stats":{"Line":0}},{"line":52,"address":[3941536,3942965,3943103,3943717,3943183,3943249,3943390,3943622,3943037],"length":1,"stats":{"Line":0}},{"line":53,"address":[3942906,3943053,3942996,3942973,3943111,3946088,3946125],"length":1,"stats":{"Line":0}},{"line":54,"address":[3943135,3942914,3946096,3943199,3946063,3943142,3943257],"length":1,"stats":{"Line":0}},{"line":56,"address":[3943273],"length":1,"stats":{"Line":0}},{"line":57,"address":[3943325],"length":1,"stats":{"Line":0}},{"line":58,"address":[3943383],"length":1,"stats":{"Line":0}},{"line":60,"address":[3943720,3943644,3943437],"length":1,"stats":{"Line":0}},{"line":63,"address":[3943735],"length":1,"stats":{"Line":0}},{"line":64,"address":[3943907,3950025,3944478,3950159],"length":1,"stats":{"Line":0}},{"line":66,"address":[3946190,3945965,3944414,3933341,3946872],"length":1,"stats":{"Line":0}},{"line":67,"address":[3946929,3947403,3946614,3933362,3946786],"length":1,"stats":{"Line":0}},{"line":69,"address":[3947251],"length":1,"stats":{"Line":0}},{"line":72,"address":[3931763,3932849,3931694,3931664,3932919,3931785],"length":1,"stats":{"Line":0}},{"line":73,"address":[3931931,3932150,3931866,3931828,3931727,3932817,3932212,3932458,3932855,3932396],"length":1,"stats":{"Line":0}},{"line":76,"address":[3932439],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","home","user","src","BTCDecoded","governance-app","src","validation","cross_layer.rs"],"content":"use serde_json::Value;\nuse crate::error::GovernanceError;\n\npub struct CrossLayerValidator;\n\nimpl CrossLayerValidator {\n    pub fn validate_cross_layer_dependencies(\n        repo_name: \u0026str,\n        changed_files: \u0026[String],\n        cross_layer_rules: \u0026[Value],\n    ) -\u003e Result\u003c(), GovernanceError\u003e {\n        for rule in cross_layer_rules {\n            if let Some(source_repo) = rule.get(\"source_repo\").and_then(|v| v.as_str()) {\n                if source_repo == repo_name {\n                    if let Some(source_pattern) = rule.get(\"source_pattern\").and_then(|v| v.as_str()) {\n                        if Self::matches_pattern(changed_files, source_pattern) {\n                            if let Some(target_repo) = rule.get(\"target_repo\").and_then(|v| v.as_str()) {\n                                if let Some(validation_type) = rule.get(\"validation_type\").and_then(|v| v.as_str()) {\n                                    return Self::validate_dependency(\n                                        target_repo,\n                                        validation_type,\n                                        rule,\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn matches_pattern(files: \u0026[String], pattern: \u0026str) -\u003e bool {\n        // Simple glob pattern matching\n        // In a real implementation, this would use a proper glob library\n        files.iter().any(|file| {\n            if pattern.contains(\"**\") {\n                let prefix = pattern.split(\"**\").next().unwrap_or(\"\");\n                file.starts_with(prefix)\n            } else if pattern.contains(\"*\") {\n                let prefix = pattern.split(\"*\").next().unwrap_or(\"\");\n                file.starts_with(prefix)\n            } else {\n                file == pattern\n            }\n        })\n    }\n\n    fn validate_dependency(\n        _target_repo: \u0026str,\n        validation_type: \u0026str,\n        _rule: \u0026Value,\n    ) -\u003e Result\u003c(), GovernanceError\u003e {\n        match validation_type {\n            \"corresponding_file_exists\" =\u003e {\n                // Check if corresponding file exists in target repo\n                // This would require GitHub API calls in a real implementation\n                Ok(())\n            }\n            \"references_latest_version\" =\u003e {\n                // Check if target repo references latest version\n                // This would require GitHub API calls in a real implementation\n                Ok(())\n            }\n            \"no_consensus_modifications\" =\u003e {\n                // Check if no consensus modifications are made\n                // This would require file content analysis\n                Ok(())\n            }\n            _ =\u003e Err(GovernanceError::ValidationError(format!(\n                \"Unknown validation type: {}\",\n                validation_type\n            ))),\n        }\n    }\n}\n\n\n\n\n","traces":[{"line":7,"address":[3707232],"length":1,"stats":{"Line":0}},{"line":12,"address":[3707340,3707325],"length":1,"stats":{"Line":0}},{"line":13,"address":[3629552,3629561],"length":1,"stats":{"Line":0}},{"line":14,"address":[4796271],"length":1,"stats":{"Line":0}},{"line":15,"address":[3629593,3629584],"length":1,"stats":{"Line":0}},{"line":16,"address":[3707671],"length":1,"stats":{"Line":0}},{"line":17,"address":[3629625,3629616],"length":1,"stats":{"Line":0}},{"line":18,"address":[3707814],"length":1,"stats":{"Line":0}},{"line":19,"address":[3707943],"length":1,"stats":{"Line":0}},{"line":31,"address":[3707473],"length":1,"stats":{"Line":0}},{"line":34,"address":[3707968],"length":1,"stats":{"Line":0}},{"line":37,"address":[3629680],"length":1,"stats":{"Line":0}},{"line":38,"address":[3629705],"length":1,"stats":{"Line":0}},{"line":39,"address":[3629788],"length":1,"stats":{"Line":0}},{"line":40,"address":[3629880],"length":1,"stats":{"Line":0}},{"line":41,"address":[4632958],"length":1,"stats":{"Line":0}},{"line":42,"address":[3629958],"length":1,"stats":{"Line":0}},{"line":43,"address":[4633272],"length":1,"stats":{"Line":0}},{"line":45,"address":[3629928],"length":1,"stats":{"Line":0}},{"line":50,"address":[4796784],"length":1,"stats":{"Line":0}},{"line":56,"address":[3708082],"length":1,"stats":{"Line":0}},{"line":59,"address":[3708150],"length":1,"stats":{"Line":0}},{"line":61,"address":[3708113],"length":1,"stats":{"Line":0}},{"line":64,"address":[3708203],"length":1,"stats":{"Line":0}},{"line":66,"address":[3708162],"length":1,"stats":{"Line":0}},{"line":69,"address":[3708407],"length":1,"stats":{"Line":0}},{"line":71,"address":[3708215],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["/","home","user","src","BTCDecoded","governance-app","src","validation","emergency.rs"],"content":"//! Emergency tier validation and management\n//!\n//! Implements the three-tiered emergency response system:\n//! - Tier 1 (Critical): 0 day review, 4-of-7 signatures, 7 day max duration\n//! - Tier 2 (Urgent): 7 day review, 5-of-7 signatures, 30 day max duration\n//! - Tier 3 (Elevated): 30 day review, 6-of-7 signatures, 90 day max duration\n\nuse chrono::{DateTime, Duration, Utc};\nuse serde::{Deserialize, Serialize};\nuse crate::error::{InsufficientSignaturesArgs, MaxExtensionsReachedArgs};\n\nuse crate::error::GovernanceAppError;\n\n/// Emergency tier classification\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum EmergencyTier {\n    /// Critical: Network-threatening (inflation bugs, consensus forks, P2P DoS)\n    Critical = 1,\n    /// Urgent: Serious security issues (memory corruption, privacy leaks, crashes)\n    Urgent = 2,\n    /// Elevated: Important but not critical (bug fixes, competitive response)\n    Elevated = 3,\n}\n\nimpl EmergencyTier {\n    /// Parse tier from integer\n    pub fn from_i32(tier: i32) -\u003e Result\u003cSelf, GovernanceAppError\u003e {\n        match tier {\n            1 =\u003e Ok(EmergencyTier::Critical),\n            2 =\u003e Ok(EmergencyTier::Urgent),\n            3 =\u003e Ok(EmergencyTier::Elevated),\n            _ =\u003e Err(GovernanceAppError::InvalidEmergencyTier(tier)),\n        }\n    }\n\n    /// Convert tier to integer\n    pub fn to_i32(\u0026self) -\u003e i32 {\n        *self as i32\n    }\n\n    /// Get review period in days for this tier\n    pub fn review_period_days(\u0026self) -\u003e u32 {\n        match self {\n            EmergencyTier::Critical =\u003e 0,\n            EmergencyTier::Urgent =\u003e 7,\n            EmergencyTier::Elevated =\u003e 30,\n        }\n    }\n\n    /// Get signature threshold (N-of-M) for this tier\n    pub fn signature_threshold(\u0026self) -\u003e (u32, u32) {\n        match self {\n            EmergencyTier::Critical =\u003e (4, 7),\n            EmergencyTier::Urgent =\u003e (5, 7),\n            EmergencyTier::Elevated =\u003e (6, 7),\n        }\n    }\n\n    /// Get activation threshold (keyholders required to activate)\n    pub fn activation_threshold(\u0026self) -\u003e (u32, u32) {\n        // All tiers require 5-of-7 emergency keyholders to activate\n        (5, 7)\n    }\n\n    /// Get maximum duration in days\n    pub fn max_duration_days(\u0026self) -\u003e u32 {\n        match self {\n            EmergencyTier::Critical =\u003e 7,\n            EmergencyTier::Urgent =\u003e 30,\n            EmergencyTier::Elevated =\u003e 90,\n        }\n    }\n\n    /// Get whether extensions are allowed\n    pub fn allows_extensions(\u0026self) -\u003e bool {\n        match self {\n            EmergencyTier::Critical =\u003e false,\n            EmergencyTier::Urgent =\u003e true,\n            EmergencyTier::Elevated =\u003e true,\n        }\n    }\n\n    /// Get maximum number of extensions allowed\n    pub fn max_extensions(\u0026self) -\u003e u32 {\n        match self {\n            EmergencyTier::Critical =\u003e 0,\n            EmergencyTier::Urgent =\u003e 1,\n            EmergencyTier::Elevated =\u003e 2,\n        }\n    }\n\n    /// Get extension duration in days\n    pub fn extension_duration_days(\u0026self) -\u003e u32 {\n        match self {\n            EmergencyTier::Critical =\u003e 0,\n            EmergencyTier::Urgent =\u003e 30,\n            EmergencyTier::Elevated =\u003e 30,\n        }\n    }\n\n    /// Get extension threshold (N-of-M)\n    pub fn extension_threshold(\u0026self) -\u003e (u32, u32) {\n        match self {\n            EmergencyTier::Critical =\u003e (0, 0), // Not applicable\n            EmergencyTier::Urgent =\u003e (6, 7),\n            EmergencyTier::Elevated =\u003e (6, 7),\n        }\n    }\n\n    /// Get post-mortem deadline in days\n    pub fn post_mortem_deadline_days(\u0026self) -\u003e u32 {\n        match self {\n            EmergencyTier::Critical =\u003e 30,\n            EmergencyTier::Urgent =\u003e 60,\n            EmergencyTier::Elevated =\u003e 90,\n        }\n    }\n\n    /// Get whether security audit is required\n    pub fn requires_security_audit(\u0026self) -\u003e bool {\n        match self {\n            EmergencyTier::Critical =\u003e true,\n            EmergencyTier::Urgent =\u003e false,\n            EmergencyTier::Elevated =\u003e false,\n        }\n    }\n\n    /// Get security audit deadline in days (if required)\n    pub fn security_audit_deadline_days(\u0026self) -\u003e Option\u003cu32\u003e {\n        match self {\n            EmergencyTier::Critical =\u003e Some(60),\n            EmergencyTier::Urgent =\u003e None,\n            EmergencyTier::Elevated =\u003e None,\n        }\n    }\n\n    /// Get tier name\n    pub fn name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            EmergencyTier::Critical =\u003e \"Critical Emergency\",\n            EmergencyTier::Urgent =\u003e \"Urgent Security Issue\",\n            EmergencyTier::Elevated =\u003e \"Elevated Priority\",\n        }\n    }\n\n    /// Get tier emoji for display\n    pub fn emoji(\u0026self) -\u003e \u0026'static str {\n        match self {\n            EmergencyTier::Critical =\u003e \"üö®\",\n            EmergencyTier::Urgent =\u003e \"‚ö†Ô∏è\",\n            EmergencyTier::Elevated =\u003e \"üì¢\",\n        }\n    }\n\n    /// Get tier description\n    pub fn description(\u0026self) -\u003e \u0026'static str {\n        match self {\n            EmergencyTier::Critical =\u003e \"Network-threatening vulnerability requiring immediate action\",\n            EmergencyTier::Urgent =\u003e \"Serious security issue requiring urgent response\",\n            EmergencyTier::Elevated =\u003e \"Important priority requiring accelerated review\",\n        }\n    }\n}\n\n/// Emergency tier activation request\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EmergencyActivation {\n    pub tier: EmergencyTier,\n    pub activated_by: String,\n    pub reason: String,\n    pub evidence: String,\n    pub signatures: Vec\u003cKeyholderSignature\u003e,\n}\n\n/// Keyholder signature for emergency activation\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KeyholderSignature {\n    pub keyholder: String,\n    pub public_key: String,\n    pub signature: String,\n    pub timestamp: DateTime\u003cUtc\u003e,\n}\n\n/// Active emergency tier\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActiveEmergency {\n    pub id: i32,\n    pub tier: EmergencyTier,\n    pub activated_by: String,\n    pub reason: String,\n    pub activated_at: DateTime\u003cUtc\u003e,\n    pub expires_at: DateTime\u003cUtc\u003e,\n    pub extended: bool,\n    pub extension_count: u32,\n}\n\nimpl ActiveEmergency {\n    /// Check if emergency has expired\n    pub fn is_expired(\u0026self) -\u003e bool {\n        Utc::now() \u003e self.expires_at\n    }\n\n    /// Get remaining duration\n    pub fn remaining_duration(\u0026self) -\u003e Duration {\n        self.expires_at - Utc::now()\n    }\n\n    /// Check if extension is allowed\n    pub fn can_extend(\u0026self) -\u003e bool {\n        self.tier.allows_extensions() \n            \u0026\u0026 self.extension_count \u003c self.tier.max_extensions()\n            \u0026\u0026 !self.is_expired()\n    }\n\n    /// Calculate new expiration if extended\n    pub fn calculate_extension_expiration(\u0026self) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        if !self.can_extend() {\n            return None;\n        }\n        \n        let extension_days = self.tier.extension_duration_days() as i64;\n        Some(self.expires_at + Duration::days(extension_days))\n    }\n}\n\n/// Emergency tier validator\npub struct EmergencyValidator;\n\nimpl EmergencyValidator {\n    /// Validate emergency activation request\n    pub fn validate_activation(\n        activation: \u0026EmergencyActivation,\n    ) -\u003e Result\u003c(), GovernanceAppError\u003e {\n        // Check minimum evidence length\n        if activation.evidence.len() \u003c 100 {\n            return Err(GovernanceAppError::InsufficientEvidence(\n                activation.evidence.len(),\n            ));\n        }\n\n        // Check signature count meets activation threshold\n        let (required, total) = activation.tier.activation_threshold();\n        if activation.signatures.len() \u003c required as usize {\n            return Err(GovernanceAppError::InsufficientSignatures(InsufficientSignaturesArgs {\n                required: required as usize,\n                found: activation.signatures.len(),\n                threshold: format!(\"{}-of-{}\", required, total),\n            }));\n        }\n\n        // Validate individual signatures\n        for sig in \u0026activation.signatures {\n            Self::validate_keyholder_signature(sig, activation)?;\n        }\n\n        Ok(())\n    }\n\n    /// Validate individual keyholder signature\n    fn validate_keyholder_signature(\n        sig: \u0026KeyholderSignature,\n        _activation: \u0026EmergencyActivation,\n    ) -\u003e Result\u003c(), GovernanceAppError\u003e {\n        // TODO: Implement actual cryptographic verification using developer-sdk\n        // For now, just basic validation\n        \n        if sig.keyholder.is_empty() {\n            return Err(GovernanceAppError::InvalidSignature(\n                \"Empty keyholder name\".to_string(),\n            ));\n        }\n\n        if sig.public_key.is_empty() {\n            return Err(GovernanceAppError::InvalidSignature(\n                \"Empty public key\".to_string(),\n            ));\n        }\n\n        if sig.signature.is_empty() {\n            return Err(GovernanceAppError::InvalidSignature(\n                \"Empty signature\".to_string(),\n            ));\n        }\n\n        Ok(())\n    }\n\n    /// Validate extension request\n    pub fn validate_extension(\n        emergency: \u0026ActiveEmergency,\n        signatures: \u0026[KeyholderSignature],\n    ) -\u003e Result\u003c(), GovernanceAppError\u003e {\n        // Check if tier allows extensions\n        if !emergency.tier.allows_extensions() {\n            return Err(GovernanceAppError::ExtensionNotAllowed(\n                emergency.tier.name().to_string(),\n            ));\n        }\n\n        // Check extension count\n        if emergency.extension_count \u003e= emergency.tier.max_extensions() {\n            return Err(GovernanceAppError::MaxExtensionsReached(MaxExtensionsReachedArgs {\n                current: emergency.extension_count,\n                max: emergency.tier.max_extensions(),\n            }));\n        }\n\n        // Check if already expired\n        if emergency.is_expired() {\n            return Err(GovernanceAppError::EmergencyExpired(emergency.id));\n        }\n\n        // Check signature count meets extension threshold\n        let (required, total) = emergency.tier.extension_threshold();\n        if signatures.len() \u003c required as usize {\n            return Err(GovernanceAppError::InsufficientSignatures(InsufficientSignaturesArgs {\n                required: required as usize,\n                found: signatures.len(),\n                threshold: format!(\"{}-of-{}\", required, total),\n            }));\n        }\n\n        Ok(())\n    }\n\n    /// Check for expired emergencies\n    pub fn check_expiration(\n        active_emergencies: \u0026[ActiveEmergency],\n    ) -\u003e Vec\u003ci32\u003e {\n        active_emergencies\n            .iter()\n            .filter(|e| e.is_expired())\n            .map(|e| e.id)\n            .collect()\n    }\n\n    /// Calculate expiration timestamp for new emergency\n    pub fn calculate_expiration(tier: EmergencyTier) -\u003e DateTime\u003cUtc\u003e {\n        let duration_days = tier.max_duration_days() as i64;\n        Utc::now() + Duration::days(duration_days)\n    }\n\n    /// Calculate post-mortem deadline\n    pub fn calculate_post_mortem_deadline(\n        tier: EmergencyTier,\n        activated_at: DateTime\u003cUtc\u003e,\n    ) -\u003e DateTime\u003cUtc\u003e {\n        let deadline_days = tier.post_mortem_deadline_days() as i64;\n        activated_at + Duration::days(deadline_days)\n    }\n\n    /// Calculate security audit deadline (if required)\n    pub fn calculate_security_audit_deadline(\n        tier: EmergencyTier,\n        activated_at: DateTime\u003cUtc\u003e,\n    ) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n        tier.security_audit_deadline_days()\n            .map(|days| activated_at + Duration::days(days as i64))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_tier_properties() {\n        // Tier 1 (Critical)\n        assert_eq!(EmergencyTier::Critical.review_period_days(), 0);\n        assert_eq!(EmergencyTier::Critical.signature_threshold(), (4, 7));\n        assert_eq!(EmergencyTier::Critical.max_duration_days(), 7);\n        assert!(!EmergencyTier::Critical.allows_extensions());\n        assert!(EmergencyTier::Critical.requires_security_audit());\n\n        // Tier 2 (Urgent)\n        assert_eq!(EmergencyTier::Urgent.review_period_days(), 7);\n        assert_eq!(EmergencyTier::Urgent.signature_threshold(), (5, 7));\n        assert_eq!(EmergencyTier::Urgent.max_duration_days(), 30);\n        assert!(EmergencyTier::Urgent.allows_extensions());\n        assert!(!EmergencyTier::Urgent.requires_security_audit());\n\n        // Tier 3 (Elevated)\n        assert_eq!(EmergencyTier::Elevated.review_period_days(), 30);\n        assert_eq!(EmergencyTier::Elevated.signature_threshold(), (6, 7));\n        assert_eq!(EmergencyTier::Elevated.max_duration_days(), 90);\n        assert!(EmergencyTier::Elevated.allows_extensions());\n        assert_eq!(EmergencyTier::Elevated.max_extensions(), 2);\n    }\n\n    #[test]\n    fn test_tier_parsing() {\n        assert_eq!(EmergencyTier::from_i32(1).unwrap(), EmergencyTier::Critical);\n        assert_eq!(EmergencyTier::from_i32(2).unwrap(), EmergencyTier::Urgent);\n        assert_eq!(EmergencyTier::from_i32(3).unwrap(), EmergencyTier::Elevated);\n        assert!(EmergencyTier::from_i32(4).is_err());\n    }\n\n    #[test]\n    fn test_active_emergency_expiration() {\n        let emergency = ActiveEmergency {\n            id: 1,\n            tier: EmergencyTier::Critical,\n            activated_by: \"alice\".to_string(),\n            reason: \"Test\".to_string(),\n            activated_at: Utc::now() - Duration::days(10),\n            expires_at: Utc::now() - Duration::days(1),\n            extended: false,\n            extension_count: 0,\n        };\n\n        assert!(emergency.is_expired());\n        assert!(!emergency.can_extend()); // Critical doesn't allow extensions\n    }\n\n    #[test]\n    fn test_active_emergency_extension() {\n        let emergency = ActiveEmergency {\n            id: 1,\n            tier: EmergencyTier::Urgent,\n            activated_by: \"alice\".to_string(),\n            reason: \"Test\".to_string(),\n            activated_at: Utc::now() - Duration::days(20),\n            expires_at: Utc::now() + Duration::days(10),\n            extended: false,\n            extension_count: 0,\n        };\n\n        assert!(!emergency.is_expired());\n        assert!(emergency.can_extend()); // Urgent allows 1 extension\n        assert!(emergency.calculate_extension_expiration().is_some());\n    }\n}\n\n\n","traces":[{"line":27,"address":[4374624],"length":1,"stats":{"Line":2}},{"line":28,"address":[3592822],"length":1,"stats":{"Line":2}},{"line":29,"address":[4374736],"length":1,"stats":{"Line":2}},{"line":30,"address":[3592938],"length":1,"stats":{"Line":2}},{"line":31,"address":[3592964],"length":1,"stats":{"Line":2}},{"line":32,"address":[4374679],"length":1,"stats":{"Line":2}},{"line":37,"address":[3593008],"length":1,"stats":{"Line":0}},{"line":38,"address":[3593013],"length":1,"stats":{"Line":0}},{"line":42,"address":[4374848],"length":1,"stats":{"Line":2}},{"line":43,"address":[3593029],"length":1,"stats":{"Line":2}},{"line":44,"address":[3593062],"length":1,"stats":{"Line":2}},{"line":45,"address":[4374896],"length":1,"stats":{"Line":2}},{"line":46,"address":[3593082],"length":1,"stats":{"Line":2}},{"line":51,"address":[4374928],"length":1,"stats":{"Line":2}},{"line":52,"address":[3593109],"length":1,"stats":{"Line":2}},{"line":53,"address":[3593142],"length":1,"stats":{"Line":2}},{"line":54,"address":[3593160],"length":1,"stats":{"Line":2}},{"line":55,"address":[3593178],"length":1,"stats":{"Line":2}},{"line":60,"address":[3593216],"length":1,"stats":{"Line":0}},{"line":66,"address":[4375056],"length":1,"stats":{"Line":2}},{"line":67,"address":[3593237],"length":1,"stats":{"Line":2}},{"line":68,"address":[3593270],"length":1,"stats":{"Line":2}},{"line":69,"address":[3593280],"length":1,"stats":{"Line":2}},{"line":70,"address":[3593290],"length":1,"stats":{"Line":2}},{"line":75,"address":[3593312],"length":1,"stats":{"Line":3}},{"line":76,"address":[4375141],"length":1,"stats":{"Line":3}},{"line":77,"address":[3593350],"length":1,"stats":{"Line":2}},{"line":78,"address":[4375181],"length":1,"stats":{"Line":2}},{"line":79,"address":[3593364],"length":1,"stats":{"Line":2}},{"line":84,"address":[4375200],"length":1,"stats":{"Line":2}},{"line":85,"address":[3593381],"length":1,"stats":{"Line":2}},{"line":86,"address":[3593414],"length":1,"stats":{"Line":0}},{"line":87,"address":[4375248],"length":1,"stats":{"Line":2}},{"line":88,"address":[4375258],"length":1,"stats":{"Line":2}},{"line":93,"address":[3593456],"length":1,"stats":{"Line":2}},{"line":94,"address":[3593461],"length":1,"stats":{"Line":2}},{"line":95,"address":[3593494],"length":1,"stats":{"Line":0}},{"line":96,"address":[4375328],"length":1,"stats":{"Line":2}},{"line":97,"address":[4375338],"length":1,"stats":{"Line":0}},{"line":102,"address":[3593536],"length":1,"stats":{"Line":0}},{"line":103,"address":[3593541],"length":1,"stats":{"Line":0}},{"line":104,"address":[3593574],"length":1,"stats":{"Line":0}},{"line":105,"address":[4375416],"length":1,"stats":{"Line":0}},{"line":106,"address":[4375434],"length":1,"stats":{"Line":0}},{"line":111,"address":[3593648],"length":1,"stats":{"Line":0}},{"line":112,"address":[3593653],"length":1,"stats":{"Line":0}},{"line":113,"address":[4375510],"length":1,"stats":{"Line":0}},{"line":114,"address":[3593696],"length":1,"stats":{"Line":0}},{"line":115,"address":[3593706],"length":1,"stats":{"Line":0}},{"line":120,"address":[3593728],"length":1,"stats":{"Line":2}},{"line":121,"address":[3593733],"length":1,"stats":{"Line":2}},{"line":122,"address":[4375590],"length":1,"stats":{"Line":2}},{"line":123,"address":[4375597],"length":1,"stats":{"Line":2}},{"line":124,"address":[3593780],"length":1,"stats":{"Line":0}},{"line":129,"address":[3593792],"length":1,"stats":{"Line":0}},{"line":130,"address":[4375621],"length":1,"stats":{"Line":0}},{"line":131,"address":[4375654],"length":1,"stats":{"Line":0}},{"line":132,"address":[3593848],"length":1,"stats":{"Line":0}},{"line":133,"address":[3593858],"length":1,"stats":{"Line":0}},{"line":138,"address":[3593888],"length":1,"stats":{"Line":0}},{"line":139,"address":[3593893],"length":1,"stats":{"Line":0}},{"line":140,"address":[3593926],"length":1,"stats":{"Line":0}},{"line":141,"address":[4375773],"length":1,"stats":{"Line":0}},{"line":142,"address":[4375796],"length":1,"stats":{"Line":0}},{"line":147,"address":[3594016],"length":1,"stats":{"Line":0}},{"line":148,"address":[4375845],"length":1,"stats":{"Line":0}},{"line":149,"address":[4375878],"length":1,"stats":{"Line":0}},{"line":150,"address":[4375901],"length":1,"stats":{"Line":0}},{"line":151,"address":[3594100],"length":1,"stats":{"Line":0}},{"line":156,"address":[3594144],"length":1,"stats":{"Line":0}},{"line":157,"address":[3594149],"length":1,"stats":{"Line":0}},{"line":158,"address":[3594182],"length":1,"stats":{"Line":0}},{"line":159,"address":[3594205],"length":1,"stats":{"Line":0}},{"line":160,"address":[3594228],"length":1,"stats":{"Line":0}},{"line":199,"address":[3594272],"length":1,"stats":{"Line":3}},{"line":200,"address":[3594286],"length":1,"stats":{"Line":3}},{"line":204,"address":[4376160],"length":1,"stats":{"Line":0}},{"line":205,"address":[3594345],"length":1,"stats":{"Line":0}},{"line":209,"address":[3594416],"length":1,"stats":{"Line":3}},{"line":210,"address":[4376267,4376254],"length":1,"stats":{"Line":5}},{"line":211,"address":[3594455],"length":1,"stats":{"Line":2}},{"line":212,"address":[3594486],"length":1,"stats":{"Line":2}},{"line":216,"address":[3594512],"length":1,"stats":{"Line":2}},{"line":217,"address":[3594544],"length":1,"stats":{"Line":2}},{"line":218,"address":[4376382],"length":1,"stats":{"Line":0}},{"line":221,"address":[4376395],"length":1,"stats":{"Line":2}},{"line":222,"address":[3594596],"length":1,"stats":{"Line":2}},{"line":231,"address":[3594672],"length":1,"stats":{"Line":0}},{"line":235,"address":[4376534],"length":1,"stats":{"Line":0}},{"line":236,"address":[3594789],"length":1,"stats":{"Line":0}},{"line":237,"address":[3594777],"length":1,"stats":{"Line":0}},{"line":242,"address":[3594730],"length":1,"stats":{"Line":0}},{"line":243,"address":[3594752],"length":1,"stats":{"Line":0}},{"line":244,"address":[4376945],"length":1,"stats":{"Line":0}},{"line":245,"address":[4376708],"length":1,"stats":{"Line":0}},{"line":246,"address":[3594892],"length":1,"stats":{"Line":0}},{"line":247,"address":[4376730],"length":1,"stats":{"Line":0}},{"line":252,"address":[4377063,4376673],"length":1,"stats":{"Line":0}},{"line":253,"address":[3595312,3595409],"length":1,"stats":{"Line":0}},{"line":256,"address":[3595384],"length":1,"stats":{"Line":0}},{"line":260,"address":[4377328],"length":1,"stats":{"Line":0}},{"line":267,"address":[4377374],"length":1,"stats":{"Line":0}},{"line":268,"address":[4377426],"length":1,"stats":{"Line":0}},{"line":269,"address":[4377403],"length":1,"stats":{"Line":0}},{"line":273,"address":[4377388],"length":1,"stats":{"Line":0}},{"line":274,"address":[4377529],"length":1,"stats":{"Line":0}},{"line":275,"address":[3595682],"length":1,"stats":{"Line":0}},{"line":279,"address":[3595667],"length":1,"stats":{"Line":0}},{"line":280,"address":[4377626],"length":1,"stats":{"Line":0}},{"line":281,"address":[4377600],"length":1,"stats":{"Line":0}},{"line":285,"address":[4377591],"length":1,"stats":{"Line":0}},{"line":289,"address":[4377712],"length":1,"stats":{"Line":0}},{"line":294,"address":[4377771],"length":1,"stats":{"Line":0}},{"line":295,"address":[3595988],"length":1,"stats":{"Line":0}},{"line":296,"address":[4377789],"length":1,"stats":{"Line":0}},{"line":301,"address":[3596050],"length":1,"stats":{"Line":0}},{"line":302,"address":[3596138],"length":1,"stats":{"Line":0}},{"line":303,"address":[3596116],"length":1,"stats":{"Line":0}},{"line":304,"address":[3596123],"length":1,"stats":{"Line":0}},{"line":309,"address":[3596096],"length":1,"stats":{"Line":0}},{"line":310,"address":[3596250],"length":1,"stats":{"Line":0}},{"line":314,"address":[3596201],"length":1,"stats":{"Line":0}},{"line":315,"address":[4378055],"length":1,"stats":{"Line":0}},{"line":316,"address":[3596574],"length":1,"stats":{"Line":0}},{"line":317,"address":[3596340],"length":1,"stats":{"Line":0}},{"line":319,"address":[3596352],"length":1,"stats":{"Line":0}},{"line":323,"address":[4378152],"length":1,"stats":{"Line":0}},{"line":327,"address":[3596720],"length":1,"stats":{"Line":0}},{"line":332,"address":[4378605],"length":1,"stats":{"Line":0}},{"line":333,"address":[4370704,4370714],"length":1,"stats":{"Line":0}},{"line":338,"address":[4378656],"length":1,"stats":{"Line":0}},{"line":339,"address":[3596853],"length":1,"stats":{"Line":0}},{"line":340,"address":[4378698],"length":1,"stats":{"Line":0}},{"line":344,"address":[3596944],"length":1,"stats":{"Line":0}},{"line":348,"address":[4378794],"length":1,"stats":{"Line":0}},{"line":349,"address":[3596989],"length":1,"stats":{"Line":0}},{"line":353,"address":[3597056],"length":1,"stats":{"Line":0}},{"line":357,"address":[3597082],"length":1,"stats":{"Line":0}},{"line":358,"address":[3511440,3511463],"length":1,"stats":{"Line":0}}],"covered":47,"coverable":139},{"path":["/","home","user","src","BTCDecoded","governance-app","src","validation","mod.rs"],"content":"pub mod signatures;\npub mod review_period;\npub mod cross_layer;\npub mod threshold;\npub mod emergency;\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","src","validation","review_period.rs"],"content":"use chrono::{DateTime, Utc, Duration};\nuse crate::error::GovernanceError;\n\npub struct ReviewPeriodValidator;\n\nimpl ReviewPeriodValidator {\n    pub fn validate_review_period(\n        opened_at: DateTime\u003cUtc\u003e,\n        required_days: i64,\n        emergency_mode: bool,\n    ) -\u003e Result\u003cbool, GovernanceError\u003e {\n        let now = Utc::now();\n        let elapsed = now - opened_at;\n        \n        // Emergency mode reduces review period to 30 days\n        let required_duration = if emergency_mode {\n            Duration::days(30)\n        } else {\n            Duration::days(required_days)\n        };\n\n        if elapsed \u003e= required_duration {\n            Ok(true)\n        } else {\n            let remaining = required_duration - elapsed;\n            Err(GovernanceError::ReviewPeriodError(format!(\n                \"Review period not met. Required: {} days, Elapsed: {} days, Remaining: {} days\",\n                required_days,\n                elapsed.num_days(),\n                remaining.num_days()\n            )))\n        }\n    }\n\n    pub fn get_earliest_merge_date(\n        opened_at: DateTime\u003cUtc\u003e,\n        required_days: i64,\n        emergency_mode: bool,\n    ) -\u003e DateTime\u003cUtc\u003e {\n        let required_duration = if emergency_mode {\n            Duration::days(30)\n        } else {\n            Duration::days(required_days)\n        };\n        \n        opened_at + required_duration\n    }\n\n    pub fn get_remaining_days(\n        opened_at: DateTime\u003cUtc\u003e,\n        required_days: i64,\n        emergency_mode: bool,\n    ) -\u003e i64 {\n        let now = Utc::now();\n        let elapsed = now - opened_at;\n        \n        let required_duration = if emergency_mode {\n            Duration::days(30)\n        } else {\n            Duration::days(required_days)\n        };\n        \n        let remaining = required_duration - elapsed;\n        remaining.num_days().max(0)\n    }\n}\n\n\n\n\n","traces":[{"line":7,"address":[4853248],"length":1,"stats":{"Line":0}},{"line":12,"address":[3607754],"length":1,"stats":{"Line":0}},{"line":13,"address":[3607770],"length":1,"stats":{"Line":0}},{"line":16,"address":[3607853],"length":1,"stats":{"Line":0}},{"line":17,"address":[3607878],"length":1,"stats":{"Line":0}},{"line":19,"address":[3607857],"length":1,"stats":{"Line":0}},{"line":22,"address":[3607897,3608369],"length":1,"stats":{"Line":0}},{"line":23,"address":[3608376],"length":1,"stats":{"Line":0}},{"line":25,"address":[3607921],"length":1,"stats":{"Line":0}},{"line":26,"address":[3607990],"length":1,"stats":{"Line":0}},{"line":29,"address":[3607954],"length":1,"stats":{"Line":0}},{"line":30,"address":[3607972],"length":1,"stats":{"Line":0}},{"line":35,"address":[4853936],"length":1,"stats":{"Line":0}},{"line":40,"address":[3608439],"length":1,"stats":{"Line":0}},{"line":41,"address":[3608463],"length":1,"stats":{"Line":0}},{"line":43,"address":[3608447],"length":1,"stats":{"Line":0}},{"line":46,"address":[3608492],"length":1,"stats":{"Line":0}},{"line":49,"address":[3608544],"length":1,"stats":{"Line":0}},{"line":54,"address":[4854113],"length":1,"stats":{"Line":0}},{"line":55,"address":[3608593],"length":1,"stats":{"Line":0}},{"line":57,"address":[3608670],"length":1,"stats":{"Line":0}},{"line":58,"address":[3608694],"length":1,"stats":{"Line":0}},{"line":60,"address":[3608678],"length":1,"stats":{"Line":0}},{"line":63,"address":[3608722],"length":1,"stats":{"Line":0}},{"line":64,"address":[3608746],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","home","user","src","BTCDecoded","governance-app","src","validation","signatures.rs"],"content":"use secp256k1::{PublicKey, Secp256k1, ecdsa::Signature};\nuse sha2::{Digest, Sha256};\nuse std::str::FromStr;\nuse crate::error::GovernanceError;\n\npub struct SignatureValidator {\n    secp: Secp256k1\u003csecp256k1::All\u003e,\n}\n\nimpl SignatureValidator {\n    pub fn new() -\u003e Self {\n        Self {\n            secp: Secp256k1::new(),\n        }\n    }\n\n    pub fn verify_signature(\n        \u0026self,\n        message: \u0026str,\n        signature: \u0026str,\n        public_key: \u0026str,\n    ) -\u003e Result\u003cbool, GovernanceError\u003e {\n        // Parse public key\n        let pub_key = PublicKey::from_str(public_key)\n            .map_err(|e| GovernanceError::CryptoError(format!(\"Invalid public key: {}\", e)))?;\n\n        // Parse signature\n        let sig = Signature::from_str(signature)\n            .map_err(|e| GovernanceError::CryptoError(format!(\"Invalid signature: {}\", e)))?;\n\n        // Hash message\n        let message_hash = Sha256::digest(message.as_bytes());\n        let message_hash = secp256k1::Message::from_digest_slice(\u0026message_hash)\n            .map_err(|e| GovernanceError::CryptoError(format!(\"Invalid message hash: {}\", e)))?;\n\n        // Verify signature\n        match self.secp.verify_ecdsa(\u0026message_hash, \u0026sig, \u0026pub_key) {\n            Ok(_) =\u003e Ok(true),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    pub fn verify_multisig_threshold(\n        \u0026self,\n        signatures: \u0026[(String, String)], // (signer, signature)\n        required_threshold: (usize, usize), // (required, total)\n        maintainer_keys: \u0026std::collections::HashMap\u003cString, String\u003e, // username -\u003e public_key\n    ) -\u003e Result\u003cbool, GovernanceError\u003e {\n        let (required, _total) = required_threshold;\n        let mut valid_signatures = 0;\n\n        for (signer, signature) in signatures {\n            if let Some(public_key) = maintainer_keys.get(signer) {\n                // Create message for signature verification\n                let message = format!(\"governance-signature:{}\", signer);\n                \n                if self.verify_signature(\u0026message, signature, public_key)? {\n                    valid_signatures += 1;\n                }\n            }\n        }\n\n        Ok(valid_signatures \u003e= required)\n    }\n}\n\nimpl Default for SignatureValidator {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n\n\n\n","traces":[{"line":11,"address":[4829200],"length":1,"stats":{"Line":0}},{"line":13,"address":[3714145],"length":1,"stats":{"Line":0}},{"line":17,"address":[3714160],"length":1,"stats":{"Line":0}},{"line":24,"address":[3714285,3714320,3714430],"length":1,"stats":{"Line":0}},{"line":25,"address":[3727984,3728009],"length":1,"stats":{"Line":0}},{"line":28,"address":[3714663,3714553,3714518],"length":1,"stats":{"Line":0}},{"line":29,"address":[3714532,3714599],"length":1,"stats":{"Line":0}},{"line":32,"address":[3714754],"length":1,"stats":{"Line":0}},{"line":33,"address":[3714825,3714775,3714935],"length":1,"stats":{"Line":0}},{"line":34,"address":[4829860,4829927],"length":1,"stats":{"Line":0}},{"line":37,"address":[3715093],"length":1,"stats":{"Line":0}},{"line":38,"address":[3715172],"length":1,"stats":{"Line":0}},{"line":39,"address":[3715154],"length":1,"stats":{"Line":0}},{"line":43,"address":[4831264,4830256,4831270],"length":1,"stats":{"Line":0}},{"line":49,"address":[3715333],"length":1,"stats":{"Line":0}},{"line":50,"address":[3715349],"length":1,"stats":{"Line":0}},{"line":52,"address":[3715361,3715382],"length":1,"stats":{"Line":0}},{"line":53,"address":[3715487,3715600],"length":1,"stats":{"Line":0}},{"line":55,"address":[3715621],"length":1,"stats":{"Line":0}},{"line":57,"address":[3715754,3716167,3715855],"length":1,"stats":{"Line":0}},{"line":58,"address":[3716169,3716132],"length":1,"stats":{"Line":0}},{"line":63,"address":[3715560],"length":1,"stats":{"Line":0}},{"line":68,"address":[3716240],"length":1,"stats":{"Line":0}},{"line":69,"address":[3716241],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","home","user","src","BTCDecoded","governance-app","src","validation","threshold.rs"],"content":"use crate::error::GovernanceError;\n\npub struct ThresholdValidator;\n\nimpl ThresholdValidator {\n    pub fn validate_threshold(\n        current_signatures: usize,\n        required_signatures: usize,\n        total_maintainers: usize,\n    ) -\u003e Result\u003cbool, GovernanceError\u003e {\n        if current_signatures \u003e= required_signatures {\n            Ok(true)\n        } else {\n            Err(GovernanceError::ThresholdError(format!(\n                \"Signature threshold not met. Required: {}/{} signatures, Current: {}/{}\",\n                required_signatures,\n                total_maintainers,\n                current_signatures,\n                total_maintainers\n            )))\n        }\n    }\n\n    pub fn get_threshold_for_layer(layer: i32) -\u003e (usize, usize) {\n        match layer {\n            1 | 2 =\u003e (6, 7),  // Constitutional layers: 6-of-7\n            3 =\u003e (4, 5),      // Implementation layer: 4-of-5\n            4 =\u003e (3, 5),      // Application layer: 3-of-5\n            5 =\u003e (2, 3),      // Extension layer: 2-of-3\n            _ =\u003e (1, 1),      // Default fallback\n        }\n    }\n\n    pub fn get_review_period_for_layer(layer: i32, emergency_mode: bool) -\u003e i64 {\n        if emergency_mode {\n            30  // Emergency mode: 30 days for all layers\n        } else {\n            match layer {\n                1 | 2 =\u003e 180,  // Constitutional layers: 180 days\n                3 =\u003e 90,       // Implementation layer: 90 days\n                4 =\u003e 60,       // Application layer: 60 days\n                5 =\u003e 14,       // Extension layer: 14 days\n                _ =\u003e 30,       // Default fallback\n            }\n        }\n    }\n\n    pub fn format_threshold_status(\n        current: usize,\n        required: usize,\n        total: usize,\n        signers: \u0026[String],\n        pending: \u0026[String],\n    ) -\u003e String {\n        format!(\n            \"‚ùå Governance: Signatures Missing\\nRequired: {}-of-{} | Current: {}/{}\\nSigned by: {}\\nPending: {}\",\n            required,\n            total,\n            current,\n            total,\n            signers.join(\", \"),\n            pending.join(\", \")\n        )\n    }\n}\n\n\n\n\n","traces":[{"line":6,"address":[3507920],"length":1,"stats":{"Line":0}},{"line":11,"address":[3507951,3508370],"length":1,"stats":{"Line":0}},{"line":12,"address":[3508376],"length":1,"stats":{"Line":0}},{"line":14,"address":[3507967],"length":1,"stats":{"Line":0}},{"line":24,"address":[4280320],"length":1,"stats":{"Line":0}},{"line":25,"address":[3508406],"length":1,"stats":{"Line":0}},{"line":26,"address":[3508461],"length":1,"stats":{"Line":0}},{"line":27,"address":[3508481],"length":1,"stats":{"Line":0}},{"line":28,"address":[3508501],"length":1,"stats":{"Line":0}},{"line":29,"address":[3508521],"length":1,"stats":{"Line":0}},{"line":30,"address":[3508441],"length":1,"stats":{"Line":0}},{"line":34,"address":[3508560],"length":1,"stats":{"Line":0}},{"line":35,"address":[3508632,3508580],"length":1,"stats":{"Line":0}},{"line":36,"address":[3508623],"length":1,"stats":{"Line":0}},{"line":38,"address":[4280508],"length":1,"stats":{"Line":0}},{"line":39,"address":[3508645],"length":1,"stats":{"Line":0}},{"line":40,"address":[4280576],"length":1,"stats":{"Line":0}},{"line":41,"address":[3508667],"length":1,"stats":{"Line":0}},{"line":42,"address":[3508678],"length":1,"stats":{"Line":0}},{"line":43,"address":[3508634],"length":1,"stats":{"Line":0}},{"line":48,"address":[3508704,3509450,3509456],"length":1,"stats":{"Line":0}},{"line":55,"address":[3508962,3508913],"length":1,"stats":{"Line":0}},{"line":61,"address":[3508831],"length":1,"stats":{"Line":0}},{"line":62,"address":[3508909],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","home","user","src","BTCDecoded","governance-app","src","webhooks","comment.rs"],"content":"use serde_json::Value;\nuse tracing::{info, warn};\n\nuse crate::database::Database;\n\npub async fn handle_comment_event(\n    database: \u0026Database,\n    payload: \u0026Value,\n) -\u003e Result\u003caxum::response::Json\u003cserde_json::Value\u003e, axum::http::StatusCode\u003e {\n    let repo_name = payload\n        .get(\"repository\")\n        .and_then(|r| r.get(\"full_name\"))\n        .and_then(|n| n.as_str())\n        .unwrap_or(\"unknown\");\n\n    let pr_number = payload\n        .get(\"issue\")\n        .and_then(|i| i.get(\"number\"))\n        .and_then(|n| n.as_u64())\n        .unwrap_or(0);\n\n    let commenter = payload\n        .get(\"comment\")\n        .and_then(|c| c.get(\"user\"))\n        .and_then(|u| u.get(\"login\"))\n        .and_then(|l| l.as_str())\n        .unwrap_or(\"unknown\");\n\n    let body = payload\n        .get(\"comment\")\n        .and_then(|c| c.get(\"body\"))\n        .and_then(|b| b.as_str())\n        .unwrap_or(\"\");\n\n    info!(\"Comment by {} on PR #{} in {}\", commenter, pr_number, repo_name);\n\n    // Check for governance signature commands\n    if body.starts_with(\"/governance-sign\") {\n        let signature = body\n            .strip_prefix(\"/governance-sign\")\n            .unwrap_or(\"\")\n            .trim();\n\n        if !signature.is_empty() {\n            info!(\"Processing governance signature from {}\", commenter);\n            \n            match database.add_signature(repo_name, pr_number as i32, commenter, signature).await {\n                Ok(_) =\u003e {\n                    info!(\"Signature added for PR #{}\", pr_number);\n                    Ok(axum::response::Json(serde_json::json!({\"status\": \"signature_added\"})))\n                }\n                Err(e) =\u003e {\n                    warn!(\"Failed to add signature: {}\", e);\n                    Err(axum::http::StatusCode::INTERNAL_SERVER_ERROR)\n                }\n            }\n        } else {\n            warn!(\"Empty signature provided by {}\", commenter);\n            Ok(axum::response::Json(serde_json::json!({\"status\": \"empty_signature\"})))\n        }\n    } else {\n        info!(\"Non-governance comment, ignoring\");\n        Ok(axum::response::Json(serde_json::json!({\"status\": \"ignored\"})))\n    }\n}\n\n\n\n\n","traces":[{"line":6,"address":[3713600],"length":1,"stats":{"Line":0}},{"line":10,"address":[3475754,3475845],"length":1,"stats":{"Line":0}},{"line":12,"address":[3491024,3491033,3475692],"length":1,"stats":{"Line":0}},{"line":13,"address":[3475715,3491065,3491056],"length":1,"stats":{"Line":0}},{"line":16,"address":[4634401,4634468],"length":1,"stats":{"Line":0}},{"line":18,"address":[3491097,3475891,3491088],"length":1,"stats":{"Line":0}},{"line":19,"address":[3475914,3491120,3491129],"length":1,"stats":{"Line":0}},{"line":22,"address":[3476238,3476147],"length":1,"stats":{"Line":0}},{"line":24,"address":[3491161,3476062,3491152],"length":1,"stats":{"Line":0}},{"line":25,"address":[3476085,3491193,3491184],"length":1,"stats":{"Line":0}},{"line":26,"address":[3491225,3476108,3491216],"length":1,"stats":{"Line":0}},{"line":29,"address":[3476396],"length":1,"stats":{"Line":0}},{"line":31,"address":[3491257,3476284,3491248],"length":1,"stats":{"Line":0}},{"line":32,"address":[3476307,3491280,3491289],"length":1,"stats":{"Line":0}},{"line":35,"address":[3476997,3491503,3476434,3491369],"length":1,"stats":{"Line":0}},{"line":38,"address":[3478723,3476957],"length":1,"stats":{"Line":0}},{"line":39,"address":[4639866],"length":1,"stats":{"Line":0}},{"line":44,"address":[3481456,3486140],"length":1,"stats":{"Line":0}},{"line":45,"address":[3491929,3481483,3481549,3492063,3482112],"length":1,"stats":{"Line":0}},{"line":47,"address":[3562612],"length":1,"stats":{"Line":0}},{"line":49,"address":[3487069,3486537,3492489,3492623],"length":1,"stats":{"Line":0}},{"line":50,"address":[3488524,3487052,3488627,3488562],"length":1,"stats":{"Line":0}},{"line":52,"address":[3486458],"length":1,"stats":{"Line":0}},{"line":53,"address":[3489659,3493183,3489140,3486506,3493049],"length":1,"stats":{"Line":0}},{"line":54,"address":[3489612],"length":1,"stats":{"Line":0}},{"line":58,"address":[3483660,3493743,3481511,3484157,3493609],"length":1,"stats":{"Line":0}},{"line":59,"address":[3485612,3486145,3485650,3484140,3485715],"length":1,"stats":{"Line":0}},{"line":62,"address":[3494303,3479319,3478822,3494169,3478729],"length":1,"stats":{"Line":0}},{"line":63,"address":[3480664,3480767,3481275,3480702,3479302],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","home","user","src","BTCDecoded","governance-app","src","webhooks","github.rs"],"content":"use axum::{\n    extract::State,\n    http::StatusCode,\n    response::Json,\n};\nuse serde_json::Value;\nuse tracing::{info, warn};\n\nuse crate::webhooks::{pull_request, review, comment};\n\npub async fn handle_webhook(\n    State((_config, database)): State\u003c(crate::config::AppConfig, crate::database::Database)\u003e,\n    Json(payload): Json\u003cValue\u003e,\n) -\u003e (StatusCode, Json\u003cValue\u003e) {\n    let event_type = payload\n        .get(\"action\")\n        .and_then(|v| v.as_str())\n        .unwrap_or(\"unknown\");\n\n    let event_name = payload\n        .get(\"action\")\n        .and_then(|v| v.as_str())\n        .unwrap_or(\"unknown\");\n\n    info!(\"Received webhook: {} - {}\", event_name, event_type);\n\n    match event_name {\n        \"opened\" | \"synchronize\" | \"reopened\" =\u003e {\n            match pull_request::handle_pull_request_event(\u0026database, \u0026payload).await {\n                Ok(response) =\u003e (StatusCode::OK, response),\n                Err(status) =\u003e (status, Json(serde_json::json!({\"error\": \"failed\"})))\n            }\n        }\n        \"submitted\" =\u003e {\n            match review::handle_review_event(\u0026database, \u0026payload).await {\n                Ok(response) =\u003e (StatusCode::OK, response),\n                Err(status) =\u003e (status, Json(serde_json::json!({\"error\": \"failed\"})))\n            }\n        }\n        \"created\" =\u003e {\n            match comment::handle_comment_event(\u0026database, \u0026payload).await {\n                Ok(response) =\u003e (StatusCode::OK, response),\n                Err(status) =\u003e (status, Json(serde_json::json!({\"error\": \"failed\"})))\n            }\n        }\n        _ =\u003e {\n            warn!(\"Unhandled webhook event: {}\", event_name);\n            (StatusCode::OK, Json(serde_json::json!({\"status\": \"ignored\"})))\n        }\n    }\n}\n\n\n\n\n","traces":[{"line":11,"address":[4303264],"length":1,"stats":{"Line":0}},{"line":15,"address":[3616542,3616310,3616627],"length":1,"stats":{"Line":0}},{"line":17,"address":[3616503,3625417,3625408],"length":1,"stats":{"Line":0}},{"line":20,"address":[3616727,3616634,3616812],"length":1,"stats":{"Line":0}},{"line":22,"address":[4366793,4358032,4366784],"length":1,"stats":{"Line":0}},{"line":25,"address":[3617384,3625663,3616819,3625529],"length":1,"stats":{"Line":0}},{"line":28,"address":[3617326,3619004,3619108],"length":1,"stats":{"Line":0}},{"line":29,"address":[4212987],"length":1,"stats":{"Line":0}},{"line":30,"address":[3622461],"length":1,"stats":{"Line":0}},{"line":31,"address":[4363986,4363766,4364051,4363948],"length":1,"stats":{"Line":0}},{"line":34,"address":[3619175],"length":1,"stats":{"Line":0}},{"line":35,"address":[3619284,3623182,3616410,3622017],"length":1,"stats":{"Line":0}},{"line":36,"address":[4364791],"length":1,"stats":{"Line":0}},{"line":37,"address":[3623628,3623590,3623408,3623693],"length":1,"stats":{"Line":0}},{"line":40,"address":[3619334,3619236],"length":1,"stats":{"Line":0}},{"line":41,"address":[3619368,3621931,3624168,3616431],"length":1,"stats":{"Line":0}},{"line":42,"address":[3624433],"length":1,"stats":{"Line":0}},{"line":43,"address":[3624679,3624576,3624394,3625361,3624614],"length":1,"stats":{"Line":0}},{"line":47,"address":[3619915,3626089,3619418,3626223,3619340],"length":1,"stats":{"Line":0}},{"line":48,"address":[3621310,3619898,3621413,3621877,3621348],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","home","user","src","BTCDecoded","governance-app","src","webhooks","mod.rs"],"content":"pub mod github;\npub mod pull_request;\npub mod review;\npub mod comment;\npub mod push;\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","src","webhooks","pull_request.rs"],"content":"use serde_json::Value;\nuse tracing::{info, warn};\n\nuse crate::database::Database;\n\npub async fn handle_pull_request_event(\n    database: \u0026Database,\n    payload: \u0026Value,\n) -\u003e Result\u003caxum::response::Json\u003cserde_json::Value\u003e, axum::http::StatusCode\u003e {\n    let repo_name = payload\n        .get(\"repository\")\n        .and_then(|r| r.get(\"full_name\"))\n        .and_then(|n| n.as_str())\n        .unwrap_or(\"unknown\");\n\n    let pr_number = payload\n        .get(\"pull_request\")\n        .and_then(|pr| pr.get(\"number\"))\n        .and_then(|n| n.as_u64())\n        .unwrap_or(0);\n\n    let head_sha = payload\n        .get(\"pull_request\")\n        .and_then(|pr| pr.get(\"head\").and_then(|h| h.get(\"sha\")))\n        .and_then(|s| s.as_str())\n        .unwrap_or(\"unknown\");\n\n    info!(\"Processing PR #{} in {}\", pr_number, repo_name);\n\n    // Determine layer based on repository\n    let layer = match repo_name {\n        repo if repo.contains(\"orange-paper\") =\u003e 1,\n        repo if repo.contains(\"consensus-proof\") =\u003e 2,\n        repo if repo.contains(\"protocol-engine\") =\u003e 3,\n        repo if repo.contains(\"reference-node\") =\u003e 4,\n        repo if repo.contains(\"developer-sdk\") =\u003e 5,\n        _ =\u003e {\n            warn!(\"Unknown repository: {}\", repo_name);\n            return Ok(axum::response::Json(serde_json::json!({\"status\": \"unknown_repo\"})));\n        }\n    };\n\n    // Store PR in database\n    match database.create_pull_request(repo_name, pr_number as i32, head_sha, layer).await {\n        Ok(_) =\u003e {\n            info!(\"PR #{} stored in database\", pr_number);\n            Ok(axum::response::Json(serde_json::json!({\"status\": \"stored\"})))\n        }\n        Err(e) =\u003e {\n            warn!(\"Failed to store PR: {}\", e);\n            Err(axum::http::StatusCode::INTERNAL_SERVER_ERROR)\n        }\n    }\n}\n\n\n\n\n","traces":[{"line":6,"address":[4306592],"length":1,"stats":{"Line":0}},{"line":10,"address":[3654947,3654856],"length":1,"stats":{"Line":0}},{"line":12,"address":[3654794,3665696,3665705],"length":1,"stats":{"Line":0}},{"line":13,"address":[3665737,3665728,3654817],"length":1,"stats":{"Line":0}},{"line":16,"address":[3655122,3655055],"length":1,"stats":{"Line":0}},{"line":18,"address":[3654993,3665760,3665769],"length":1,"stats":{"Line":0}},{"line":19,"address":[3665792,3655016,3665801],"length":1,"stats":{"Line":0}},{"line":22,"address":[3655281],"length":1,"stats":{"Line":0}},{"line":24,"address":[3665833,3665881,3665872,3655164,3665824],"length":1,"stats":{"Line":0}},{"line":25,"address":[3665904,3655187,3665913],"length":1,"stats":{"Line":0}},{"line":28,"address":[3666127,3655319,3655897,3665993],"length":1,"stats":{"Line":0}},{"line":32,"address":[3657577,3655826,3657510],"length":1,"stats":{"Line":0}},{"line":33,"address":[4902496,4902380,4902563],"length":1,"stats":{"Line":0}},{"line":34,"address":[3657754,3657638,3657821],"length":1,"stats":{"Line":0}},{"line":35,"address":[3657943,3657760,3657876],"length":1,"stats":{"Line":0}},{"line":36,"address":[3658032,3657998,3657882],"length":1,"stats":{"Line":0}},{"line":38,"address":[3666553,3666687,3658004,3658087,3658584],"length":1,"stats":{"Line":0}},{"line":39,"address":[3658567,3660077,3660039,3660142,3660653],"length":1,"stats":{"Line":0}},{"line":44,"address":[3654723,3660715,3660874],"length":1,"stats":{"Line":0}},{"line":46,"address":[3667113,3661743,3667247,3661211],"length":1,"stats":{"Line":0}},{"line":47,"address":[3663301,3663198,3661726,3663236],"length":1,"stats":{"Line":0}},{"line":49,"address":[3661132],"length":1,"stats":{"Line":0}},{"line":50,"address":[3663814,3661180,3664333,3667673,3667807],"length":1,"stats":{"Line":0}},{"line":51,"address":[3664286],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["/","home","user","src","BTCDecoded","governance-app","src","webhooks","push.rs"],"content":"use serde_json::Value;\nuse tracing::{info, warn};\n\nuse crate::database::Database;\n\npub async fn handle_push_event(\n    database: \u0026Database,\n    payload: \u0026Value,\n) -\u003e Result\u003caxum::response::Json\u003cserde_json::Value\u003e, axum::http::StatusCode\u003e {\n    let repo_name = payload\n        .get(\"repository\")\n        .and_then(|r| r.get(\"full_name\"))\n        .and_then(|n| n.as_str())\n        .unwrap_or(\"unknown\");\n\n    let pusher = payload\n        .get(\"pusher\")\n        .and_then(|p| p.get(\"name\"))\n        .and_then(|n| n.as_str())\n        .unwrap_or(\"unknown\");\n\n    let ref_name = payload\n        .get(\"ref\")\n        .and_then(|r| r.as_str())\n        .unwrap_or(\"unknown\");\n\n    info!(\"Push by {} to {} in {}\", pusher, ref_name, repo_name);\n\n    // Check if this is a direct push to main/master (potential bypass attempt)\n    if ref_name == \"refs/heads/main\" || ref_name == \"refs/heads/master\" {\n        warn!(\"Direct push to {} detected - potential governance bypass!\", ref_name);\n        \n        // Log the bypass attempt\n        match database.log_governance_event(\n            \"direct_push_detected\",\n            Some(repo_name),\n            None,\n            Some(pusher),\n            \u0026serde_json::json!({\n                \"ref\": ref_name,\n                \"pusher\": pusher,\n                \"timestamp\": chrono::Utc::now()\n            })\n        ).await {\n            Ok(_) =\u003e {\n                info!(\"Bypass attempt logged for {}\", repo_name);\n                Ok(axum::response::Json(serde_json::json!({\"status\": \"bypass_logged\"})))\n            }\n            Err(e) =\u003e {\n                warn!(\"Failed to log bypass attempt: {}\", e);\n                Err(axum::http::StatusCode::INTERNAL_SERVER_ERROR)\n            }\n        }\n    } else {\n        info!(\"Regular push to {}, ignoring\", ref_name);\n        Ok(axum::response::Json(serde_json::json!({\"status\": \"ignored\"})))\n    }\n}\n\n\n\n\n","traces":[{"line":6,"address":[3356576],"length":1,"stats":{"Line":0}},{"line":10,"address":[3682448,3682539],"length":1,"stats":{"Line":0}},{"line":12,"address":[3682386,3696048,3696057],"length":1,"stats":{"Line":0}},{"line":13,"address":[3696089,3682409,3696080],"length":1,"stats":{"Line":0}},{"line":16,"address":[4402055,4402146],"length":1,"stats":{"Line":0}},{"line":18,"address":[3682585,3696112,3696121],"length":1,"stats":{"Line":0}},{"line":19,"address":[3696144,3682608,3696153],"length":1,"stats":{"Line":0}},{"line":22,"address":[3682906,3682823],"length":1,"stats":{"Line":0}},{"line":24,"address":[3682784,3696176,3696185],"length":1,"stats":{"Line":0}},{"line":27,"address":[3696399,3682913,3696265,3683467],"length":1,"stats":{"Line":0}},{"line":30,"address":[3685193,3685274,3683420],"length":1,"stats":{"Line":0}},{"line":31,"address":[3696825,3688498,3687926,3685236,3696959],"length":1,"stats":{"Line":0}},{"line":34,"address":[3691029,3691345,3690865,3691412],"length":1,"stats":{"Line":0}},{"line":36,"address":[3688398],"length":1,"stats":{"Line":0}},{"line":37,"address":[4407838],"length":1,"stats":{"Line":0}},{"line":38,"address":[3688441],"length":1,"stats":{"Line":0}},{"line":39,"address":[3690605,3688481,3691089,3690064,3690543,3689956,3690292,3689994,3690359],"length":1,"stats":{"Line":0}},{"line":42,"address":[3690586],"length":1,"stats":{"Line":0}},{"line":44,"address":[4401723,4410430,4410801,4410467,4410599],"length":1,"stats":{"Line":0}},{"line":46,"address":[3692060,3697385,3691528,3697519],"length":1,"stats":{"Line":0}},{"line":47,"address":[3693618,3692043,3694069,3693515,3693553],"length":1,"stats":{"Line":0}},{"line":49,"address":[3691449],"length":1,"stats":{"Line":0}},{"line":50,"address":[3691497,3697945,3698079,3694671,3694152],"length":1,"stats":{"Line":0}},{"line":51,"address":[3694624],"length":1,"stats":{"Line":0}},{"line":55,"address":[3698639,3698505,3685280,3685812],"length":1,"stats":{"Line":0}},{"line":56,"address":[3687305,3687881,3687267,3685795,3687370],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","home","user","src","BTCDecoded","governance-app","src","webhooks","review.rs"],"content":"use serde_json::Value;\nuse tracing::{info, warn};\n\nuse crate::database::Database;\n\npub async fn handle_review_event(\n    database: \u0026Database,\n    payload: \u0026Value,\n) -\u003e Result\u003caxum::response::Json\u003cserde_json::Value\u003e, axum::http::StatusCode\u003e {\n    let repo_name = payload\n        .get(\"repository\")\n        .and_then(|r| r.get(\"full_name\"))\n        .and_then(|n| n.as_str())\n        .unwrap_or(\"unknown\");\n\n    let pr_number = payload\n        .get(\"pull_request\")\n        .and_then(|pr| pr.get(\"number\"))\n        .and_then(|n| n.as_u64())\n        .unwrap_or(0);\n\n    let reviewer = payload\n        .get(\"review\")\n        .and_then(|r| r.get(\"user\"))\n        .and_then(|u| u.get(\"login\"))\n        .and_then(|l| l.as_str())\n        .unwrap_or(\"unknown\");\n\n    let state = payload\n        .get(\"review\")\n        .and_then(|r| r.get(\"state\"))\n        .and_then(|s| s.as_str())\n        .unwrap_or(\"unknown\");\n\n    info!(\"Review {} by {} for PR #{} in {}\", state, reviewer, pr_number, repo_name);\n\n    // Update review status in database\n    match database.update_review_status(repo_name, pr_number as i32, reviewer, state).await {\n        Ok(_) =\u003e {\n            info!(\"Review status updated for PR #{}\", pr_number);\n            Ok(axum::response::Json(serde_json::json!({\"status\": \"updated\"})))\n        }\n        Err(e) =\u003e {\n            warn!(\"Failed to update review status: {}\", e);\n            Err(axum::http::StatusCode::INTERNAL_SERVER_ERROR)\n        }\n    }\n}\n\n\n\n\n","traces":[{"line":6,"address":[3705392],"length":1,"stats":{"Line":0}},{"line":10,"address":[3532301,3532392],"length":1,"stats":{"Line":0}},{"line":12,"address":[3540432,3540441,3532239],"length":1,"stats":{"Line":0}},{"line":13,"address":[3540473,3532262,3540464],"length":1,"stats":{"Line":0}},{"line":16,"address":[3532500,3532567],"length":1,"stats":{"Line":0}},{"line":18,"address":[3532438,3540496,3540505],"length":1,"stats":{"Line":0}},{"line":19,"address":[3540528,3540537,3532461],"length":1,"stats":{"Line":0}},{"line":22,"address":[3532694,3532785],"length":1,"stats":{"Line":0}},{"line":24,"address":[3532609,3540560,3540569],"length":1,"stats":{"Line":0}},{"line":25,"address":[3540592,3540601,3532632],"length":1,"stats":{"Line":0}},{"line":26,"address":[3540633,3540624,3532655],"length":1,"stats":{"Line":0}},{"line":29,"address":[3532976,3532893],"length":1,"stats":{"Line":0}},{"line":31,"address":[3532831,3540656,3540665],"length":1,"stats":{"Line":0}},{"line":32,"address":[3532854,3540688,3540697],"length":1,"stats":{"Line":0}},{"line":35,"address":[3540777,3540911,3533573,3532983],"length":1,"stats":{"Line":0}},{"line":38,"address":[3532168,3535427,3535517,3533498],"length":1,"stats":{"Line":0}},{"line":40,"address":[3536386,3541471,3541337,3535854],"length":1,"stats":{"Line":0}},{"line":41,"address":[3537841,3537879,3536369,3537944,3538455],"length":1,"stats":{"Line":0}},{"line":43,"address":[3535775],"length":1,"stats":{"Line":0}},{"line":44,"address":[3539063,3542031,3535823,3538544,3541897],"length":1,"stats":{"Line":0}},{"line":45,"address":[3539016],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","home","user","src","BTCDecoded","governance-app","target","debug","build","crunchy-968dda5e33cc46c6","out","lib.rs"],"content":"\n/// Unroll the given for loop\n///\n/// Example:\n///\n/// ```ignore\n/// unroll! {\n///   for i in 0..5 {\n///     println!(\"Iteration {}\", i);\n///   }\n/// }\n/// ```\n///\n/// will expand into:\n///\n/// ```ignore\n/// { println!(\"Iteration {}\", 0); }\n/// { println!(\"Iteration {}\", 1); }\n/// { println!(\"Iteration {}\", 2); }\n/// { println!(\"Iteration {}\", 3); }\n/// { println!(\"Iteration {}\", 4); }\n/// ```\n#[macro_export]\nmacro_rules! unroll {\n    (for $v:ident in 0..0 $c:block) =\u003e {};\n\n    (for $v:ident \u003c $max:tt in ($start:tt..$end:tt).step_by($val:expr) {$($c:tt)*}) =\u003e {\n        {\n            let step = $val;\n            let start = $start;\n            let end = start + ($end - start) / step;\n            unroll! {\n                for val \u003c $max in start..end {\n                    let $v: usize = ((val - start) * step) + start;\n\n                    $($c)*\n                }\n            }\n        }\n    };\n\n    (for $v:ident in ($start:tt..$end:tt).step_by($val:expr) {$($c:tt)*}) =\u003e {\n        unroll! {\n            for $v \u003c $end in ($start..$end).step_by($val) {$($c)*}\n        }\n    };\n\n    (for $v:ident in ($start:tt..$end:tt) {$($c:tt)*}) =\u003e {\n        unroll!{\n            for $v in $start..$end {$($c)*}\n        }\n    };\n\n    (for $v:ident in $start:tt..$end:tt {$($c:tt)*}) =\u003e {\n        #[allow(non_upper_case_globals)]\n        #[allow(unused_comparisons)]\n        {\n            unroll!(@$v, 0, $end, {\n                    if $v \u003e= $start {$($c)*}\n                }\n            );\n        }\n    };\n\n    (for $v:ident \u003c $max:tt in $start:tt..$end:tt $c:block) =\u003e {\n        #[allow(non_upper_case_globals)]\n        {\n            let range = $start..$end;\n            assert!(\n                $max \u003e= range.end,\n                \"`{}` out of range `{:?}`\",\n                stringify!($max),\n                range,\n            );\n            unroll!(\n                @$v,\n                0,\n                $max,\n                {\n                    if $v \u003e= range.start \u0026\u0026 $v \u003c range.end {\n                        $c\n                    }\n                }\n            );\n        }\n    };\n\n    (for $v:ident in 0..$end:tt {$($statement:tt)*}) =\u003e {\n        #[allow(non_upper_case_globals)]\n        { unroll!(@$v, 0, $end, {$($statement)*}); }\n    };\n\n    (@$v:ident, $a:expr, 0, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n    };\n\n    (@$v:ident, $a:expr, 1, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n    };\n\n    (@$v:ident, $a:expr, 2, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n    };\n\n    (@$v:ident, $a:expr, 3, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n    };\n\n    (@$v:ident, $a:expr, 4, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n    };\n\n    (@$v:ident, $a:expr, 5, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n    };\n\n    (@$v:ident, $a:expr, 6, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n    };\n\n    (@$v:ident, $a:expr, 7, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n    };\n\n    (@$v:ident, $a:expr, 8, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n    };\n\n    (@$v:ident, $a:expr, 9, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n    };\n\n    (@$v:ident, $a:expr, 10, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n    };\n\n    (@$v:ident, $a:expr, 11, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n    };\n\n    (@$v:ident, $a:expr, 12, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n    };\n\n    (@$v:ident, $a:expr, 13, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n    };\n\n    (@$v:ident, $a:expr, 14, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n        { const $v: usize = $a + 13; $c }\n    };\n\n    (@$v:ident, $a:expr, 15, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n        { const $v: usize = $a + 13; $c }\n        { const $v: usize = $a + 14; $c }\n    };\n\n    (@$v:ident, $a:expr, 16, $c:block) =\u003e {\n        { const $v: usize = $a; $c }\n        { const $v: usize = $a + 1; $c }\n        { const $v: usize = $a + 2; $c }\n        { const $v: usize = $a + 3; $c }\n        { const $v: usize = $a + 4; $c }\n        { const $v: usize = $a + 5; $c }\n        { const $v: usize = $a + 6; $c }\n        { const $v: usize = $a + 7; $c }\n        { const $v: usize = $a + 8; $c }\n        { const $v: usize = $a + 9; $c }\n        { const $v: usize = $a + 10; $c }\n        { const $v: usize = $a + 11; $c }\n        { const $v: usize = $a + 12; $c }\n        { const $v: usize = $a + 13; $c }\n        { const $v: usize = $a + 14; $c }\n        { const $v: usize = $a + 15; $c }\n    };\n\n    (@$v:ident, $a:expr, 17, $c:block) =\u003e {\n        unroll!(@$v, $a, 16, $c);\n        { const $v: usize = $a + 16; $c }\n    };\n\n    (@$v:ident, $a:expr, 18, $c:block) =\u003e {\n        unroll!(@$v, $a, 9, $c);\n        unroll!(@$v, $a + 9, 9, $c);\n    };\n\n    (@$v:ident, $a:expr, 19, $c:block) =\u003e {\n        unroll!(@$v, $a, 18, $c);\n        { const $v: usize = $a + 18; $c }\n    };\n\n    (@$v:ident, $a:expr, 20, $c:block) =\u003e {\n        unroll!(@$v, $a, 10, $c);\n        unroll!(@$v, $a + 10, 10, $c);\n    };\n\n    (@$v:ident, $a:expr, 21, $c:block) =\u003e {\n        unroll!(@$v, $a, 20, $c);\n        { const $v: usize = $a + 20; $c }\n    };\n\n    (@$v:ident, $a:expr, 22, $c:block) =\u003e {\n        unroll!(@$v, $a, 11, $c);\n        unroll!(@$v, $a + 11, 11, $c);\n    };\n\n    (@$v:ident, $a:expr, 23, $c:block) =\u003e {\n        unroll!(@$v, $a, 22, $c);\n        { const $v: usize = $a + 22; $c }\n    };\n\n    (@$v:ident, $a:expr, 24, $c:block) =\u003e {\n        unroll!(@$v, $a, 12, $c);\n        unroll!(@$v, $a + 12, 12, $c);\n    };\n\n    (@$v:ident, $a:expr, 25, $c:block) =\u003e {\n        unroll!(@$v, $a, 24, $c);\n        { const $v: usize = $a + 24; $c }\n    };\n\n    (@$v:ident, $a:expr, 26, $c:block) =\u003e {\n        unroll!(@$v, $a, 13, $c);\n        unroll!(@$v, $a + 13, 13, $c);\n    };\n\n    (@$v:ident, $a:expr, 27, $c:block) =\u003e {\n        unroll!(@$v, $a, 26, $c);\n        { const $v: usize = $a + 26; $c }\n    };\n\n    (@$v:ident, $a:expr, 28, $c:block) =\u003e {\n        unroll!(@$v, $a, 14, $c);\n        unroll!(@$v, $a + 14, 14, $c);\n    };\n\n    (@$v:ident, $a:expr, 29, $c:block) =\u003e {\n        unroll!(@$v, $a, 28, $c);\n        { const $v: usize = $a + 28; $c }\n    };\n\n    (@$v:ident, $a:expr, 30, $c:block) =\u003e {\n        unroll!(@$v, $a, 15, $c);\n        unroll!(@$v, $a + 15, 15, $c);\n    };\n\n    (@$v:ident, $a:expr, 31, $c:block) =\u003e {\n        unroll!(@$v, $a, 30, $c);\n        { const $v: usize = $a + 30; $c }\n    };\n\n    (@$v:ident, $a:expr, 32, $c:block) =\u003e {\n        unroll!(@$v, $a, 16, $c);\n        unroll!(@$v, $a + 16, 16, $c);\n    };\n\n    (@$v:ident, $a:expr, 33, $c:block) =\u003e {\n        unroll!(@$v, $a, 32, $c);\n        { const $v: usize = $a + 32; $c }\n    };\n\n    (@$v:ident, $a:expr, 34, $c:block) =\u003e {\n        unroll!(@$v, $a, 17, $c);\n        unroll!(@$v, $a + 17, 17, $c);\n    };\n\n    (@$v:ident, $a:expr, 35, $c:block) =\u003e {\n        unroll!(@$v, $a, 34, $c);\n        { const $v: usize = $a + 34; $c }\n    };\n\n    (@$v:ident, $a:expr, 36, $c:block) =\u003e {\n        unroll!(@$v, $a, 18, $c);\n        unroll!(@$v, $a + 18, 18, $c);\n    };\n\n    (@$v:ident, $a:expr, 37, $c:block) =\u003e {\n        unroll!(@$v, $a, 36, $c);\n        { const $v: usize = $a + 36; $c }\n    };\n\n    (@$v:ident, $a:expr, 38, $c:block) =\u003e {\n        unroll!(@$v, $a, 19, $c);\n        unroll!(@$v, $a + 19, 19, $c);\n    };\n\n    (@$v:ident, $a:expr, 39, $c:block) =\u003e {\n        unroll!(@$v, $a, 38, $c);\n        { const $v: usize = $a + 38; $c }\n    };\n\n    (@$v:ident, $a:expr, 40, $c:block) =\u003e {\n        unroll!(@$v, $a, 20, $c);\n        unroll!(@$v, $a + 20, 20, $c);\n    };\n\n    (@$v:ident, $a:expr, 41, $c:block) =\u003e {\n        unroll!(@$v, $a, 40, $c);\n        { const $v: usize = $a + 40; $c }\n    };\n\n    (@$v:ident, $a:expr, 42, $c:block) =\u003e {\n        unroll!(@$v, $a, 21, $c);\n        unroll!(@$v, $a + 21, 21, $c);\n    };\n\n    (@$v:ident, $a:expr, 43, $c:block) =\u003e {\n        unroll!(@$v, $a, 42, $c);\n        { const $v: usize = $a + 42; $c }\n    };\n\n    (@$v:ident, $a:expr, 44, $c:block) =\u003e {\n        unroll!(@$v, $a, 22, $c);\n        unroll!(@$v, $a + 22, 22, $c);\n    };\n\n    (@$v:ident, $a:expr, 45, $c:block) =\u003e {\n        unroll!(@$v, $a, 44, $c);\n        { const $v: usize = $a + 44; $c }\n    };\n\n    (@$v:ident, $a:expr, 46, $c:block) =\u003e {\n        unroll!(@$v, $a, 23, $c);\n        unroll!(@$v, $a + 23, 23, $c);\n    };\n\n    (@$v:ident, $a:expr, 47, $c:block) =\u003e {\n        unroll!(@$v, $a, 46, $c);\n        { const $v: usize = $a + 46; $c }\n    };\n\n    (@$v:ident, $a:expr, 48, $c:block) =\u003e {\n        unroll!(@$v, $a, 24, $c);\n        unroll!(@$v, $a + 24, 24, $c);\n    };\n\n    (@$v:ident, $a:expr, 49, $c:block) =\u003e {\n        unroll!(@$v, $a, 48, $c);\n        { const $v: usize = $a + 48; $c }\n    };\n\n    (@$v:ident, $a:expr, 50, $c:block) =\u003e {\n        unroll!(@$v, $a, 25, $c);\n        unroll!(@$v, $a + 25, 25, $c);\n    };\n\n    (@$v:ident, $a:expr, 51, $c:block) =\u003e {\n        unroll!(@$v, $a, 50, $c);\n        { const $v: usize = $a + 50; $c }\n    };\n\n    (@$v:ident, $a:expr, 52, $c:block) =\u003e {\n        unroll!(@$v, $a, 26, $c);\n        unroll!(@$v, $a + 26, 26, $c);\n    };\n\n    (@$v:ident, $a:expr, 53, $c:block) =\u003e {\n        unroll!(@$v, $a, 52, $c);\n        { const $v: usize = $a + 52; $c }\n    };\n\n    (@$v:ident, $a:expr, 54, $c:block) =\u003e {\n        unroll!(@$v, $a, 27, $c);\n        unroll!(@$v, $a + 27, 27, $c);\n    };\n\n    (@$v:ident, $a:expr, 55, $c:block) =\u003e {\n        unroll!(@$v, $a, 54, $c);\n        { const $v: usize = $a + 54; $c }\n    };\n\n    (@$v:ident, $a:expr, 56, $c:block) =\u003e {\n        unroll!(@$v, $a, 28, $c);\n        unroll!(@$v, $a + 28, 28, $c);\n    };\n\n    (@$v:ident, $a:expr, 57, $c:block) =\u003e {\n        unroll!(@$v, $a, 56, $c);\n        { const $v: usize = $a + 56; $c }\n    };\n\n    (@$v:ident, $a:expr, 58, $c:block) =\u003e {\n        unroll!(@$v, $a, 29, $c);\n        unroll!(@$v, $a + 29, 29, $c);\n    };\n\n    (@$v:ident, $a:expr, 59, $c:block) =\u003e {\n        unroll!(@$v, $a, 58, $c);\n        { const $v: usize = $a + 58; $c }\n    };\n\n    (@$v:ident, $a:expr, 60, $c:block) =\u003e {\n        unroll!(@$v, $a, 30, $c);\n        unroll!(@$v, $a + 30, 30, $c);\n    };\n\n    (@$v:ident, $a:expr, 61, $c:block) =\u003e {\n        unroll!(@$v, $a, 60, $c);\n        { const $v: usize = $a + 60; $c }\n    };\n\n    (@$v:ident, $a:expr, 62, $c:block) =\u003e {\n        unroll!(@$v, $a, 31, $c);\n        unroll!(@$v, $a + 31, 31, $c);\n    };\n\n    (@$v:ident, $a:expr, 63, $c:block) =\u003e {\n        unroll!(@$v, $a, 62, $c);\n        { const $v: usize = $a + 62; $c }\n    };\n\n    (@$v:ident, $a:expr, 64, $c:block) =\u003e {\n        unroll!(@$v, $a, 32, $c);\n        unroll!(@$v, $a + 32, 32, $c);\n    };\n\n    (@$v:ident, $a:expr, 65, $c:block) =\u003e {\n        unroll!(@$v, $a, 64, $c);\n        { const $v: usize = $a + 64; $c }\n    };\n\n    (@$v:ident, $a:expr, 66, $c:block) =\u003e {\n        unroll!(@$v, $a, 33, $c);\n        unroll!(@$v, $a + 33, 33, $c);\n    };\n\n    (@$v:ident, $a:expr, 67, $c:block) =\u003e {\n        unroll!(@$v, $a, 66, $c);\n        { const $v: usize = $a + 66; $c }\n    };\n\n    (@$v:ident, $a:expr, 68, $c:block) =\u003e {\n        unroll!(@$v, $a, 34, $c);\n        unroll!(@$v, $a + 34, 34, $c);\n    };\n\n    (@$v:ident, $a:expr, 69, $c:block) =\u003e {\n        unroll!(@$v, $a, 68, $c);\n        { const $v: usize = $a + 68; $c }\n    };\n\n    (@$v:ident, $a:expr, 70, $c:block) =\u003e {\n        unroll!(@$v, $a, 35, $c);\n        unroll!(@$v, $a + 35, 35, $c);\n    };\n\n    (@$v:ident, $a:expr, 71, $c:block) =\u003e {\n        unroll!(@$v, $a, 70, $c);\n        { const $v: usize = $a + 70; $c }\n    };\n\n    (@$v:ident, $a:expr, 72, $c:block) =\u003e {\n        unroll!(@$v, $a, 36, $c);\n        unroll!(@$v, $a + 36, 36, $c);\n    };\n\n    (@$v:ident, $a:expr, 73, $c:block) =\u003e {\n        unroll!(@$v, $a, 72, $c);\n        { const $v: usize = $a + 72; $c }\n    };\n\n    (@$v:ident, $a:expr, 74, $c:block) =\u003e {\n        unroll!(@$v, $a, 37, $c);\n        unroll!(@$v, $a + 37, 37, $c);\n    };\n\n    (@$v:ident, $a:expr, 75, $c:block) =\u003e {\n        unroll!(@$v, $a, 74, $c);\n        { const $v: usize = $a + 74; $c }\n    };\n\n    (@$v:ident, $a:expr, 76, $c:block) =\u003e {\n        unroll!(@$v, $a, 38, $c);\n        unroll!(@$v, $a + 38, 38, $c);\n    };\n\n    (@$v:ident, $a:expr, 77, $c:block) =\u003e {\n        unroll!(@$v, $a, 76, $c);\n        { const $v: usize = $a + 76; $c }\n    };\n\n    (@$v:ident, $a:expr, 78, $c:block) =\u003e {\n        unroll!(@$v, $a, 39, $c);\n        unroll!(@$v, $a + 39, 39, $c);\n    };\n\n    (@$v:ident, $a:expr, 79, $c:block) =\u003e {\n        unroll!(@$v, $a, 78, $c);\n        { const $v: usize = $a + 78; $c }\n    };\n\n    (@$v:ident, $a:expr, 80, $c:block) =\u003e {\n        unroll!(@$v, $a, 40, $c);\n        unroll!(@$v, $a + 40, 40, $c);\n    };\n\n    (@$v:ident, $a:expr, 81, $c:block) =\u003e {\n        unroll!(@$v, $a, 80, $c);\n        { const $v: usize = $a + 80; $c }\n    };\n\n    (@$v:ident, $a:expr, 82, $c:block) =\u003e {\n        unroll!(@$v, $a, 41, $c);\n        unroll!(@$v, $a + 41, 41, $c);\n    };\n\n    (@$v:ident, $a:expr, 83, $c:block) =\u003e {\n        unroll!(@$v, $a, 82, $c);\n        { const $v: usize = $a + 82; $c }\n    };\n\n    (@$v:ident, $a:expr, 84, $c:block) =\u003e {\n        unroll!(@$v, $a, 42, $c);\n        unroll!(@$v, $a + 42, 42, $c);\n    };\n\n    (@$v:ident, $a:expr, 85, $c:block) =\u003e {\n        unroll!(@$v, $a, 84, $c);\n        { const $v: usize = $a + 84; $c }\n    };\n\n    (@$v:ident, $a:expr, 86, $c:block) =\u003e {\n        unroll!(@$v, $a, 43, $c);\n        unroll!(@$v, $a + 43, 43, $c);\n    };\n\n    (@$v:ident, $a:expr, 87, $c:block) =\u003e {\n        unroll!(@$v, $a, 86, $c);\n        { const $v: usize = $a + 86; $c }\n    };\n\n    (@$v:ident, $a:expr, 88, $c:block) =\u003e {\n        unroll!(@$v, $a, 44, $c);\n        unroll!(@$v, $a + 44, 44, $c);\n    };\n\n    (@$v:ident, $a:expr, 89, $c:block) =\u003e {\n        unroll!(@$v, $a, 88, $c);\n        { const $v: usize = $a + 88; $c }\n    };\n\n    (@$v:ident, $a:expr, 90, $c:block) =\u003e {\n        unroll!(@$v, $a, 45, $c);\n        unroll!(@$v, $a + 45, 45, $c);\n    };\n\n    (@$v:ident, $a:expr, 91, $c:block) =\u003e {\n        unroll!(@$v, $a, 90, $c);\n        { const $v: usize = $a + 90; $c }\n    };\n\n    (@$v:ident, $a:expr, 92, $c:block) =\u003e {\n        unroll!(@$v, $a, 46, $c);\n        unroll!(@$v, $a + 46, 46, $c);\n    };\n\n    (@$v:ident, $a:expr, 93, $c:block) =\u003e {\n        unroll!(@$v, $a, 92, $c);\n        { const $v: usize = $a + 92; $c }\n    };\n\n    (@$v:ident, $a:expr, 94, $c:block) =\u003e {\n        unroll!(@$v, $a, 47, $c);\n        unroll!(@$v, $a + 47, 47, $c);\n    };\n\n    (@$v:ident, $a:expr, 95, $c:block) =\u003e {\n        unroll!(@$v, $a, 94, $c);\n        { const $v: usize = $a + 94; $c }\n    };\n\n    (@$v:ident, $a:expr, 96, $c:block) =\u003e {\n        unroll!(@$v, $a, 48, $c);\n        unroll!(@$v, $a + 48, 48, $c);\n    };\n\n    (@$v:ident, $a:expr, 97, $c:block) =\u003e {\n        unroll!(@$v, $a, 96, $c);\n        { const $v: usize = $a + 96; $c }\n    };\n\n    (@$v:ident, $a:expr, 98, $c:block) =\u003e {\n        unroll!(@$v, $a, 49, $c);\n        unroll!(@$v, $a + 49, 49, $c);\n    };\n\n    (@$v:ident, $a:expr, 99, $c:block) =\u003e {\n        unroll!(@$v, $a, 98, $c);\n        { const $v: usize = $a + 98; $c }\n    };\n\n    (@$v:ident, $a:expr, 100, $c:block) =\u003e {\n        unroll!(@$v, $a, 50, $c);\n        unroll!(@$v, $a + 50, 50, $c);\n    };\n\n    (@$v:ident, $a:expr, 101, $c:block) =\u003e {\n        unroll!(@$v, $a, 100, $c);\n        { const $v: usize = $a + 100; $c }\n    };\n\n    (@$v:ident, $a:expr, 102, $c:block) =\u003e {\n        unroll!(@$v, $a, 51, $c);\n        unroll!(@$v, $a + 51, 51, $c);\n    };\n\n    (@$v:ident, $a:expr, 103, $c:block) =\u003e {\n        unroll!(@$v, $a, 102, $c);\n        { const $v: usize = $a + 102; $c }\n    };\n\n    (@$v:ident, $a:expr, 104, $c:block) =\u003e {\n        unroll!(@$v, $a, 52, $c);\n        unroll!(@$v, $a + 52, 52, $c);\n    };\n\n    (@$v:ident, $a:expr, 105, $c:block) =\u003e {\n        unroll!(@$v, $a, 104, $c);\n        { const $v: usize = $a + 104; $c }\n    };\n\n    (@$v:ident, $a:expr, 106, $c:block) =\u003e {\n        unroll!(@$v, $a, 53, $c);\n        unroll!(@$v, $a + 53, 53, $c);\n    };\n\n    (@$v:ident, $a:expr, 107, $c:block) =\u003e {\n        unroll!(@$v, $a, 106, $c);\n        { const $v: usize = $a + 106; $c }\n    };\n\n    (@$v:ident, $a:expr, 108, $c:block) =\u003e {\n        unroll!(@$v, $a, 54, $c);\n        unroll!(@$v, $a + 54, 54, $c);\n    };\n\n    (@$v:ident, $a:expr, 109, $c:block) =\u003e {\n        unroll!(@$v, $a, 108, $c);\n        { const $v: usize = $a + 108; $c }\n    };\n\n    (@$v:ident, $a:expr, 110, $c:block) =\u003e {\n        unroll!(@$v, $a, 55, $c);\n        unroll!(@$v, $a + 55, 55, $c);\n    };\n\n    (@$v:ident, $a:expr, 111, $c:block) =\u003e {\n        unroll!(@$v, $a, 110, $c);\n        { const $v: usize = $a + 110; $c }\n    };\n\n    (@$v:ident, $a:expr, 112, $c:block) =\u003e {\n        unroll!(@$v, $a, 56, $c);\n        unroll!(@$v, $a + 56, 56, $c);\n    };\n\n    (@$v:ident, $a:expr, 113, $c:block) =\u003e {\n        unroll!(@$v, $a, 112, $c);\n        { const $v: usize = $a + 112; $c }\n    };\n\n    (@$v:ident, $a:expr, 114, $c:block) =\u003e {\n        unroll!(@$v, $a, 57, $c);\n        unroll!(@$v, $a + 57, 57, $c);\n    };\n\n    (@$v:ident, $a:expr, 115, $c:block) =\u003e {\n        unroll!(@$v, $a, 114, $c);\n        { const $v: usize = $a + 114; $c }\n    };\n\n    (@$v:ident, $a:expr, 116, $c:block) =\u003e {\n        unroll!(@$v, $a, 58, $c);\n        unroll!(@$v, $a + 58, 58, $c);\n    };\n\n    (@$v:ident, $a:expr, 117, $c:block) =\u003e {\n        unroll!(@$v, $a, 116, $c);\n        { const $v: usize = $a + 116; $c }\n    };\n\n    (@$v:ident, $a:expr, 118, $c:block) =\u003e {\n        unroll!(@$v, $a, 59, $c);\n        unroll!(@$v, $a + 59, 59, $c);\n    };\n\n    (@$v:ident, $a:expr, 119, $c:block) =\u003e {\n        unroll!(@$v, $a, 118, $c);\n        { const $v: usize = $a + 118; $c }\n    };\n\n    (@$v:ident, $a:expr, 120, $c:block) =\u003e {\n        unroll!(@$v, $a, 60, $c);\n        unroll!(@$v, $a + 60, 60, $c);\n    };\n\n    (@$v:ident, $a:expr, 121, $c:block) =\u003e {\n        unroll!(@$v, $a, 120, $c);\n        { const $v: usize = $a + 120; $c }\n    };\n\n    (@$v:ident, $a:expr, 122, $c:block) =\u003e {\n        unroll!(@$v, $a, 61, $c);\n        unroll!(@$v, $a + 61, 61, $c);\n    };\n\n    (@$v:ident, $a:expr, 123, $c:block) =\u003e {\n        unroll!(@$v, $a, 122, $c);\n        { const $v: usize = $a + 122; $c }\n    };\n\n    (@$v:ident, $a:expr, 124, $c:block) =\u003e {\n        unroll!(@$v, $a, 62, $c);\n        unroll!(@$v, $a + 62, 62, $c);\n    };\n\n    (@$v:ident, $a:expr, 125, $c:block) =\u003e {\n        unroll!(@$v, $a, 124, $c);\n        { const $v: usize = $a + 124; $c }\n    };\n\n    (@$v:ident, $a:expr, 126, $c:block) =\u003e {\n        unroll!(@$v, $a, 63, $c);\n        unroll!(@$v, $a + 63, 63, $c);\n    };\n\n    (@$v:ident, $a:expr, 127, $c:block) =\u003e {\n        unroll!(@$v, $a, 126, $c);\n        { const $v: usize = $a + 126; $c }\n    };\n\n    (@$v:ident, $a:expr, 128, $c:block) =\u003e {\n        unroll!(@$v, $a, 64, $c);\n        unroll!(@$v, $a + 64, 64, $c);\n    };\n\n}\n\n\n#[cfg(all(test, feature = \"std\"))]\nmod tests {\n    #[test]\n    fn invalid_range() {\n        let mut a: Vec\u003cusize\u003e = vec![];\n        unroll! {\n                for i in (5..4) {\n                    a.push(i);\n                }\n            }\n        assert_eq!(a, vec![]);\n    }\n\n    #[test]\n    fn start_at_one_with_step() {\n        let mut a: Vec\u003cusize\u003e = vec![];\n        unroll! {\n                for i in (2..4).step_by(1) {\n                    a.push(i);\n                }\n            }\n        assert_eq!(a, vec![2, 3]);\n    }\n\n    #[test]\n    fn start_at_one() {\n        let mut a: Vec\u003cusize\u003e = vec![];\n        unroll! {\n                for i in 1..4 {\n                    a.push(i);\n                }\n            }\n        assert_eq!(a, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_all() {\n        {\n            let a: Vec\u003cusize\u003e = vec![];\n            unroll! {\n                for i in 0..0 {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..0).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            unroll! {\n                for i in 0..1 {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..1).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            unroll! {\n                for i in 0..128 {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..128).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            let start = 128 / 4;\n            let end = start * 3;\n            unroll! {\n                for i \u003c 128 in start..end {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (start..end).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            unroll! {\n                for i in (0..128).step_by(2) {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (0..128 / 2).map(|x| x * 2).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n        {\n            let mut a: Vec\u003cusize\u003e = vec![];\n            let start = 128 / 4;\n            let end = start * 3;\n            unroll! {\n                for i \u003c 128 in (start..end).step_by(2) {\n                    a.push(i);\n                }\n            }\n            assert_eq!(a, (start..end).filter(|x| x % 2 == 0).collect::\u003cVec\u003cusize\u003e\u003e());\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","target","debug","build","libsqlite3-sys-2f7385a33bbddb8a","out","bindgen.rs"],"content":"/* automatically generated by rust-bindgen 0.69.1 */\n\nextern \"C\" {\n    pub fn sqlite3_auto_extension(\n        xEntryPoint: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                db: *mut sqlite3,\n                pzErrMsg: *mut *const ::std::os::raw::c_char,\n                pThunk: *const sqlite3_api_routines,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_cancel_auto_extension(\n        xEntryPoint: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                db: *mut sqlite3,\n                pzErrMsg: *mut *const ::std::os::raw::c_char,\n                pThunk: *const sqlite3_api_routines,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\n\npub const SQLITE_VERSION: \u0026[u8; 7] = b\"3.44.0\\0\";\npub const SQLITE_VERSION_NUMBER: i32 = 3044000;\npub const SQLITE_SOURCE_ID: \u0026[u8; 85] =\n    b\"2023-11-01 11:23:50 17129ba1ff7f0daf37100ee82d507aef7827cf38de1866e2633096ae6ad81301\\0\";\npub const SQLITE_OK: i32 = 0;\npub const SQLITE_ERROR: i32 = 1;\npub const SQLITE_INTERNAL: i32 = 2;\npub const SQLITE_PERM: i32 = 3;\npub const SQLITE_ABORT: i32 = 4;\npub const SQLITE_BUSY: i32 = 5;\npub const SQLITE_LOCKED: i32 = 6;\npub const SQLITE_NOMEM: i32 = 7;\npub const SQLITE_READONLY: i32 = 8;\npub const SQLITE_INTERRUPT: i32 = 9;\npub const SQLITE_IOERR: i32 = 10;\npub const SQLITE_CORRUPT: i32 = 11;\npub const SQLITE_NOTFOUND: i32 = 12;\npub const SQLITE_FULL: i32 = 13;\npub const SQLITE_CANTOPEN: i32 = 14;\npub const SQLITE_PROTOCOL: i32 = 15;\npub const SQLITE_EMPTY: i32 = 16;\npub const SQLITE_SCHEMA: i32 = 17;\npub const SQLITE_TOOBIG: i32 = 18;\npub const SQLITE_CONSTRAINT: i32 = 19;\npub const SQLITE_MISMATCH: i32 = 20;\npub const SQLITE_MISUSE: i32 = 21;\npub const SQLITE_NOLFS: i32 = 22;\npub const SQLITE_AUTH: i32 = 23;\npub const SQLITE_FORMAT: i32 = 24;\npub const SQLITE_RANGE: i32 = 25;\npub const SQLITE_NOTADB: i32 = 26;\npub const SQLITE_NOTICE: i32 = 27;\npub const SQLITE_WARNING: i32 = 28;\npub const SQLITE_ROW: i32 = 100;\npub const SQLITE_DONE: i32 = 101;\npub const SQLITE_ERROR_MISSING_COLLSEQ: i32 = 257;\npub const SQLITE_ERROR_RETRY: i32 = 513;\npub const SQLITE_ERROR_SNAPSHOT: i32 = 769;\npub const SQLITE_IOERR_READ: i32 = 266;\npub const SQLITE_IOERR_SHORT_READ: i32 = 522;\npub const SQLITE_IOERR_WRITE: i32 = 778;\npub const SQLITE_IOERR_FSYNC: i32 = 1034;\npub const SQLITE_IOERR_DIR_FSYNC: i32 = 1290;\npub const SQLITE_IOERR_TRUNCATE: i32 = 1546;\npub const SQLITE_IOERR_FSTAT: i32 = 1802;\npub const SQLITE_IOERR_UNLOCK: i32 = 2058;\npub const SQLITE_IOERR_RDLOCK: i32 = 2314;\npub const SQLITE_IOERR_DELETE: i32 = 2570;\npub const SQLITE_IOERR_BLOCKED: i32 = 2826;\npub const SQLITE_IOERR_NOMEM: i32 = 3082;\npub const SQLITE_IOERR_ACCESS: i32 = 3338;\npub const SQLITE_IOERR_CHECKRESERVEDLOCK: i32 = 3594;\npub const SQLITE_IOERR_LOCK: i32 = 3850;\npub const SQLITE_IOERR_CLOSE: i32 = 4106;\npub const SQLITE_IOERR_DIR_CLOSE: i32 = 4362;\npub const SQLITE_IOERR_SHMOPEN: i32 = 4618;\npub const SQLITE_IOERR_SHMSIZE: i32 = 4874;\npub const SQLITE_IOERR_SHMLOCK: i32 = 5130;\npub const SQLITE_IOERR_SHMMAP: i32 = 5386;\npub const SQLITE_IOERR_SEEK: i32 = 5642;\npub const SQLITE_IOERR_DELETE_NOENT: i32 = 5898;\npub const SQLITE_IOERR_MMAP: i32 = 6154;\npub const SQLITE_IOERR_GETTEMPPATH: i32 = 6410;\npub const SQLITE_IOERR_CONVPATH: i32 = 6666;\npub const SQLITE_IOERR_VNODE: i32 = 6922;\npub const SQLITE_IOERR_AUTH: i32 = 7178;\npub const SQLITE_IOERR_BEGIN_ATOMIC: i32 = 7434;\npub const SQLITE_IOERR_COMMIT_ATOMIC: i32 = 7690;\npub const SQLITE_IOERR_ROLLBACK_ATOMIC: i32 = 7946;\npub const SQLITE_IOERR_DATA: i32 = 8202;\npub const SQLITE_IOERR_CORRUPTFS: i32 = 8458;\npub const SQLITE_IOERR_IN_PAGE: i32 = 8714;\npub const SQLITE_LOCKED_SHAREDCACHE: i32 = 262;\npub const SQLITE_LOCKED_VTAB: i32 = 518;\npub const SQLITE_BUSY_RECOVERY: i32 = 261;\npub const SQLITE_BUSY_SNAPSHOT: i32 = 517;\npub const SQLITE_BUSY_TIMEOUT: i32 = 773;\npub const SQLITE_CANTOPEN_NOTEMPDIR: i32 = 270;\npub const SQLITE_CANTOPEN_ISDIR: i32 = 526;\npub const SQLITE_CANTOPEN_FULLPATH: i32 = 782;\npub const SQLITE_CANTOPEN_CONVPATH: i32 = 1038;\npub const SQLITE_CANTOPEN_DIRTYWAL: i32 = 1294;\npub const SQLITE_CANTOPEN_SYMLINK: i32 = 1550;\npub const SQLITE_CORRUPT_VTAB: i32 = 267;\npub const SQLITE_CORRUPT_SEQUENCE: i32 = 523;\npub const SQLITE_CORRUPT_INDEX: i32 = 779;\npub const SQLITE_READONLY_RECOVERY: i32 = 264;\npub const SQLITE_READONLY_CANTLOCK: i32 = 520;\npub const SQLITE_READONLY_ROLLBACK: i32 = 776;\npub const SQLITE_READONLY_DBMOVED: i32 = 1032;\npub const SQLITE_READONLY_CANTINIT: i32 = 1288;\npub const SQLITE_READONLY_DIRECTORY: i32 = 1544;\npub const SQLITE_ABORT_ROLLBACK: i32 = 516;\npub const SQLITE_CONSTRAINT_CHECK: i32 = 275;\npub const SQLITE_CONSTRAINT_COMMITHOOK: i32 = 531;\npub const SQLITE_CONSTRAINT_FOREIGNKEY: i32 = 787;\npub const SQLITE_CONSTRAINT_FUNCTION: i32 = 1043;\npub const SQLITE_CONSTRAINT_NOTNULL: i32 = 1299;\npub const SQLITE_CONSTRAINT_PRIMARYKEY: i32 = 1555;\npub const SQLITE_CONSTRAINT_TRIGGER: i32 = 1811;\npub const SQLITE_CONSTRAINT_UNIQUE: i32 = 2067;\npub const SQLITE_CONSTRAINT_VTAB: i32 = 2323;\npub const SQLITE_CONSTRAINT_ROWID: i32 = 2579;\npub const SQLITE_CONSTRAINT_PINNED: i32 = 2835;\npub const SQLITE_CONSTRAINT_DATATYPE: i32 = 3091;\npub const SQLITE_NOTICE_RECOVER_WAL: i32 = 283;\npub const SQLITE_NOTICE_RECOVER_ROLLBACK: i32 = 539;\npub const SQLITE_NOTICE_RBU: i32 = 795;\npub const SQLITE_WARNING_AUTOINDEX: i32 = 284;\npub const SQLITE_AUTH_USER: i32 = 279;\npub const SQLITE_OK_LOAD_PERMANENTLY: i32 = 256;\npub const SQLITE_OK_SYMLINK: i32 = 512;\npub const SQLITE_OPEN_READONLY: i32 = 1;\npub const SQLITE_OPEN_READWRITE: i32 = 2;\npub const SQLITE_OPEN_CREATE: i32 = 4;\npub const SQLITE_OPEN_DELETEONCLOSE: i32 = 8;\npub const SQLITE_OPEN_EXCLUSIVE: i32 = 16;\npub const SQLITE_OPEN_AUTOPROXY: i32 = 32;\npub const SQLITE_OPEN_URI: i32 = 64;\npub const SQLITE_OPEN_MEMORY: i32 = 128;\npub const SQLITE_OPEN_MAIN_DB: i32 = 256;\npub const SQLITE_OPEN_TEMP_DB: i32 = 512;\npub const SQLITE_OPEN_TRANSIENT_DB: i32 = 1024;\npub const SQLITE_OPEN_MAIN_JOURNAL: i32 = 2048;\npub const SQLITE_OPEN_TEMP_JOURNAL: i32 = 4096;\npub const SQLITE_OPEN_SUBJOURNAL: i32 = 8192;\npub const SQLITE_OPEN_SUPER_JOURNAL: i32 = 16384;\npub const SQLITE_OPEN_NOMUTEX: i32 = 32768;\npub const SQLITE_OPEN_FULLMUTEX: i32 = 65536;\npub const SQLITE_OPEN_SHAREDCACHE: i32 = 131072;\npub const SQLITE_OPEN_PRIVATECACHE: i32 = 262144;\npub const SQLITE_OPEN_WAL: i32 = 524288;\npub const SQLITE_OPEN_NOFOLLOW: i32 = 16777216;\npub const SQLITE_OPEN_EXRESCODE: i32 = 33554432;\npub const SQLITE_OPEN_MASTER_JOURNAL: i32 = 16384;\npub const SQLITE_IOCAP_ATOMIC: i32 = 1;\npub const SQLITE_IOCAP_ATOMIC512: i32 = 2;\npub const SQLITE_IOCAP_ATOMIC1K: i32 = 4;\npub const SQLITE_IOCAP_ATOMIC2K: i32 = 8;\npub const SQLITE_IOCAP_ATOMIC4K: i32 = 16;\npub const SQLITE_IOCAP_ATOMIC8K: i32 = 32;\npub const SQLITE_IOCAP_ATOMIC16K: i32 = 64;\npub const SQLITE_IOCAP_ATOMIC32K: i32 = 128;\npub const SQLITE_IOCAP_ATOMIC64K: i32 = 256;\npub const SQLITE_IOCAP_SAFE_APPEND: i32 = 512;\npub const SQLITE_IOCAP_SEQUENTIAL: i32 = 1024;\npub const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN: i32 = 2048;\npub const SQLITE_IOCAP_POWERSAFE_OVERWRITE: i32 = 4096;\npub const SQLITE_IOCAP_IMMUTABLE: i32 = 8192;\npub const SQLITE_IOCAP_BATCH_ATOMIC: i32 = 16384;\npub const SQLITE_LOCK_NONE: i32 = 0;\npub const SQLITE_LOCK_SHARED: i32 = 1;\npub const SQLITE_LOCK_RESERVED: i32 = 2;\npub const SQLITE_LOCK_PENDING: i32 = 3;\npub const SQLITE_LOCK_EXCLUSIVE: i32 = 4;\npub const SQLITE_SYNC_NORMAL: i32 = 2;\npub const SQLITE_SYNC_FULL: i32 = 3;\npub const SQLITE_SYNC_DATAONLY: i32 = 16;\npub const SQLITE_FCNTL_LOCKSTATE: i32 = 1;\npub const SQLITE_FCNTL_GET_LOCKPROXYFILE: i32 = 2;\npub const SQLITE_FCNTL_SET_LOCKPROXYFILE: i32 = 3;\npub const SQLITE_FCNTL_LAST_ERRNO: i32 = 4;\npub const SQLITE_FCNTL_SIZE_HINT: i32 = 5;\npub const SQLITE_FCNTL_CHUNK_SIZE: i32 = 6;\npub const SQLITE_FCNTL_FILE_POINTER: i32 = 7;\npub const SQLITE_FCNTL_SYNC_OMITTED: i32 = 8;\npub const SQLITE_FCNTL_WIN32_AV_RETRY: i32 = 9;\npub const SQLITE_FCNTL_PERSIST_WAL: i32 = 10;\npub const SQLITE_FCNTL_OVERWRITE: i32 = 11;\npub const SQLITE_FCNTL_VFSNAME: i32 = 12;\npub const SQLITE_FCNTL_POWERSAFE_OVERWRITE: i32 = 13;\npub const SQLITE_FCNTL_PRAGMA: i32 = 14;\npub const SQLITE_FCNTL_BUSYHANDLER: i32 = 15;\npub const SQLITE_FCNTL_TEMPFILENAME: i32 = 16;\npub const SQLITE_FCNTL_MMAP_SIZE: i32 = 18;\npub const SQLITE_FCNTL_TRACE: i32 = 19;\npub const SQLITE_FCNTL_HAS_MOVED: i32 = 20;\npub const SQLITE_FCNTL_SYNC: i32 = 21;\npub const SQLITE_FCNTL_COMMIT_PHASETWO: i32 = 22;\npub const SQLITE_FCNTL_WIN32_SET_HANDLE: i32 = 23;\npub const SQLITE_FCNTL_WAL_BLOCK: i32 = 24;\npub const SQLITE_FCNTL_ZIPVFS: i32 = 25;\npub const SQLITE_FCNTL_RBU: i32 = 26;\npub const SQLITE_FCNTL_VFS_POINTER: i32 = 27;\npub const SQLITE_FCNTL_JOURNAL_POINTER: i32 = 28;\npub const SQLITE_FCNTL_WIN32_GET_HANDLE: i32 = 29;\npub const SQLITE_FCNTL_PDB: i32 = 30;\npub const SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: i32 = 31;\npub const SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: i32 = 32;\npub const SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: i32 = 33;\npub const SQLITE_FCNTL_LOCK_TIMEOUT: i32 = 34;\npub const SQLITE_FCNTL_DATA_VERSION: i32 = 35;\npub const SQLITE_FCNTL_SIZE_LIMIT: i32 = 36;\npub const SQLITE_FCNTL_CKPT_DONE: i32 = 37;\npub const SQLITE_FCNTL_RESERVE_BYTES: i32 = 38;\npub const SQLITE_FCNTL_CKPT_START: i32 = 39;\npub const SQLITE_FCNTL_EXTERNAL_READER: i32 = 40;\npub const SQLITE_FCNTL_CKSM_FILE: i32 = 41;\npub const SQLITE_FCNTL_RESET_CACHE: i32 = 42;\npub const SQLITE_GET_LOCKPROXYFILE: i32 = 2;\npub const SQLITE_SET_LOCKPROXYFILE: i32 = 3;\npub const SQLITE_LAST_ERRNO: i32 = 4;\npub const SQLITE_ACCESS_EXISTS: i32 = 0;\npub const SQLITE_ACCESS_READWRITE: i32 = 1;\npub const SQLITE_ACCESS_READ: i32 = 2;\npub const SQLITE_SHM_UNLOCK: i32 = 1;\npub const SQLITE_SHM_LOCK: i32 = 2;\npub const SQLITE_SHM_SHARED: i32 = 4;\npub const SQLITE_SHM_EXCLUSIVE: i32 = 8;\npub const SQLITE_SHM_NLOCK: i32 = 8;\npub const SQLITE_CONFIG_SINGLETHREAD: i32 = 1;\npub const SQLITE_CONFIG_MULTITHREAD: i32 = 2;\npub const SQLITE_CONFIG_SERIALIZED: i32 = 3;\npub const SQLITE_CONFIG_MALLOC: i32 = 4;\npub const SQLITE_CONFIG_GETMALLOC: i32 = 5;\npub const SQLITE_CONFIG_SCRATCH: i32 = 6;\npub const SQLITE_CONFIG_PAGECACHE: i32 = 7;\npub const SQLITE_CONFIG_HEAP: i32 = 8;\npub const SQLITE_CONFIG_MEMSTATUS: i32 = 9;\npub const SQLITE_CONFIG_MUTEX: i32 = 10;\npub const SQLITE_CONFIG_GETMUTEX: i32 = 11;\npub const SQLITE_CONFIG_LOOKASIDE: i32 = 13;\npub const SQLITE_CONFIG_PCACHE: i32 = 14;\npub const SQLITE_CONFIG_GETPCACHE: i32 = 15;\npub const SQLITE_CONFIG_LOG: i32 = 16;\npub const SQLITE_CONFIG_URI: i32 = 17;\npub const SQLITE_CONFIG_PCACHE2: i32 = 18;\npub const SQLITE_CONFIG_GETPCACHE2: i32 = 19;\npub const SQLITE_CONFIG_COVERING_INDEX_SCAN: i32 = 20;\npub const SQLITE_CONFIG_SQLLOG: i32 = 21;\npub const SQLITE_CONFIG_MMAP_SIZE: i32 = 22;\npub const SQLITE_CONFIG_WIN32_HEAPSIZE: i32 = 23;\npub const SQLITE_CONFIG_PCACHE_HDRSZ: i32 = 24;\npub const SQLITE_CONFIG_PMASZ: i32 = 25;\npub const SQLITE_CONFIG_STMTJRNL_SPILL: i32 = 26;\npub const SQLITE_CONFIG_SMALL_MALLOC: i32 = 27;\npub const SQLITE_CONFIG_SORTERREF_SIZE: i32 = 28;\npub const SQLITE_CONFIG_MEMDB_MAXSIZE: i32 = 29;\npub const SQLITE_DBCONFIG_MAINDBNAME: i32 = 1000;\npub const SQLITE_DBCONFIG_LOOKASIDE: i32 = 1001;\npub const SQLITE_DBCONFIG_ENABLE_FKEY: i32 = 1002;\npub const SQLITE_DBCONFIG_ENABLE_TRIGGER: i32 = 1003;\npub const SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER: i32 = 1004;\npub const SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION: i32 = 1005;\npub const SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE: i32 = 1006;\npub const SQLITE_DBCONFIG_ENABLE_QPSG: i32 = 1007;\npub const SQLITE_DBCONFIG_TRIGGER_EQP: i32 = 1008;\npub const SQLITE_DBCONFIG_RESET_DATABASE: i32 = 1009;\npub const SQLITE_DBCONFIG_DEFENSIVE: i32 = 1010;\npub const SQLITE_DBCONFIG_WRITABLE_SCHEMA: i32 = 1011;\npub const SQLITE_DBCONFIG_LEGACY_ALTER_TABLE: i32 = 1012;\npub const SQLITE_DBCONFIG_DQS_DML: i32 = 1013;\npub const SQLITE_DBCONFIG_DQS_DDL: i32 = 1014;\npub const SQLITE_DBCONFIG_ENABLE_VIEW: i32 = 1015;\npub const SQLITE_DBCONFIG_LEGACY_FILE_FORMAT: i32 = 1016;\npub const SQLITE_DBCONFIG_TRUSTED_SCHEMA: i32 = 1017;\npub const SQLITE_DBCONFIG_STMT_SCANSTATUS: i32 = 1018;\npub const SQLITE_DBCONFIG_REVERSE_SCANORDER: i32 = 1019;\npub const SQLITE_DBCONFIG_MAX: i32 = 1019;\npub const SQLITE_DENY: i32 = 1;\npub const SQLITE_IGNORE: i32 = 2;\npub const SQLITE_CREATE_INDEX: i32 = 1;\npub const SQLITE_CREATE_TABLE: i32 = 2;\npub const SQLITE_CREATE_TEMP_INDEX: i32 = 3;\npub const SQLITE_CREATE_TEMP_TABLE: i32 = 4;\npub const SQLITE_CREATE_TEMP_TRIGGER: i32 = 5;\npub const SQLITE_CREATE_TEMP_VIEW: i32 = 6;\npub const SQLITE_CREATE_TRIGGER: i32 = 7;\npub const SQLITE_CREATE_VIEW: i32 = 8;\npub const SQLITE_DELETE: i32 = 9;\npub const SQLITE_DROP_INDEX: i32 = 10;\npub const SQLITE_DROP_TABLE: i32 = 11;\npub const SQLITE_DROP_TEMP_INDEX: i32 = 12;\npub const SQLITE_DROP_TEMP_TABLE: i32 = 13;\npub const SQLITE_DROP_TEMP_TRIGGER: i32 = 14;\npub const SQLITE_DROP_TEMP_VIEW: i32 = 15;\npub const SQLITE_DROP_TRIGGER: i32 = 16;\npub const SQLITE_DROP_VIEW: i32 = 17;\npub const SQLITE_INSERT: i32 = 18;\npub const SQLITE_PRAGMA: i32 = 19;\npub const SQLITE_READ: i32 = 20;\npub const SQLITE_SELECT: i32 = 21;\npub const SQLITE_TRANSACTION: i32 = 22;\npub const SQLITE_UPDATE: i32 = 23;\npub const SQLITE_ATTACH: i32 = 24;\npub const SQLITE_DETACH: i32 = 25;\npub const SQLITE_ALTER_TABLE: i32 = 26;\npub const SQLITE_REINDEX: i32 = 27;\npub const SQLITE_ANALYZE: i32 = 28;\npub const SQLITE_CREATE_VTABLE: i32 = 29;\npub const SQLITE_DROP_VTABLE: i32 = 30;\npub const SQLITE_FUNCTION: i32 = 31;\npub const SQLITE_SAVEPOINT: i32 = 32;\npub const SQLITE_COPY: i32 = 0;\npub const SQLITE_RECURSIVE: i32 = 33;\npub const SQLITE_TRACE_STMT: i32 = 1;\npub const SQLITE_TRACE_PROFILE: i32 = 2;\npub const SQLITE_TRACE_ROW: i32 = 4;\npub const SQLITE_TRACE_CLOSE: i32 = 8;\npub const SQLITE_LIMIT_LENGTH: i32 = 0;\npub const SQLITE_LIMIT_SQL_LENGTH: i32 = 1;\npub const SQLITE_LIMIT_COLUMN: i32 = 2;\npub const SQLITE_LIMIT_EXPR_DEPTH: i32 = 3;\npub const SQLITE_LIMIT_COMPOUND_SELECT: i32 = 4;\npub const SQLITE_LIMIT_VDBE_OP: i32 = 5;\npub const SQLITE_LIMIT_FUNCTION_ARG: i32 = 6;\npub const SQLITE_LIMIT_ATTACHED: i32 = 7;\npub const SQLITE_LIMIT_LIKE_PATTERN_LENGTH: i32 = 8;\npub const SQLITE_LIMIT_VARIABLE_NUMBER: i32 = 9;\npub const SQLITE_LIMIT_TRIGGER_DEPTH: i32 = 10;\npub const SQLITE_LIMIT_WORKER_THREADS: i32 = 11;\npub const SQLITE_PREPARE_PERSISTENT: ::std::os::raw::c_uint = 1;\npub const SQLITE_PREPARE_NORMALIZE: ::std::os::raw::c_uint = 2;\npub const SQLITE_PREPARE_NO_VTAB: ::std::os::raw::c_uint = 4;\npub const SQLITE_INTEGER: i32 = 1;\npub const SQLITE_FLOAT: i32 = 2;\npub const SQLITE_BLOB: i32 = 4;\npub const SQLITE_NULL: i32 = 5;\npub const SQLITE_TEXT: i32 = 3;\npub const SQLITE3_TEXT: i32 = 3;\npub const SQLITE_UTF8: i32 = 1;\npub const SQLITE_UTF16LE: i32 = 2;\npub const SQLITE_UTF16BE: i32 = 3;\npub const SQLITE_UTF16: i32 = 4;\npub const SQLITE_ANY: i32 = 5;\npub const SQLITE_UTF16_ALIGNED: i32 = 8;\npub const SQLITE_DETERMINISTIC: i32 = 2048;\npub const SQLITE_DIRECTONLY: i32 = 524288;\npub const SQLITE_SUBTYPE: i32 = 1048576;\npub const SQLITE_INNOCUOUS: i32 = 2097152;\npub const SQLITE_WIN32_DATA_DIRECTORY_TYPE: i32 = 1;\npub const SQLITE_WIN32_TEMP_DIRECTORY_TYPE: i32 = 2;\npub const SQLITE_TXN_NONE: i32 = 0;\npub const SQLITE_TXN_READ: i32 = 1;\npub const SQLITE_TXN_WRITE: i32 = 2;\npub const SQLITE_INDEX_SCAN_UNIQUE: i32 = 1;\npub const SQLITE_INDEX_CONSTRAINT_EQ: i32 = 2;\npub const SQLITE_INDEX_CONSTRAINT_GT: i32 = 4;\npub const SQLITE_INDEX_CONSTRAINT_LE: i32 = 8;\npub const SQLITE_INDEX_CONSTRAINT_LT: i32 = 16;\npub const SQLITE_INDEX_CONSTRAINT_GE: i32 = 32;\npub const SQLITE_INDEX_CONSTRAINT_MATCH: i32 = 64;\npub const SQLITE_INDEX_CONSTRAINT_LIKE: i32 = 65;\npub const SQLITE_INDEX_CONSTRAINT_GLOB: i32 = 66;\npub const SQLITE_INDEX_CONSTRAINT_REGEXP: i32 = 67;\npub const SQLITE_INDEX_CONSTRAINT_NE: i32 = 68;\npub const SQLITE_INDEX_CONSTRAINT_ISNOT: i32 = 69;\npub const SQLITE_INDEX_CONSTRAINT_ISNOTNULL: i32 = 70;\npub const SQLITE_INDEX_CONSTRAINT_ISNULL: i32 = 71;\npub const SQLITE_INDEX_CONSTRAINT_IS: i32 = 72;\npub const SQLITE_INDEX_CONSTRAINT_LIMIT: i32 = 73;\npub const SQLITE_INDEX_CONSTRAINT_OFFSET: i32 = 74;\npub const SQLITE_INDEX_CONSTRAINT_FUNCTION: i32 = 150;\npub const SQLITE_MUTEX_FAST: i32 = 0;\npub const SQLITE_MUTEX_RECURSIVE: i32 = 1;\npub const SQLITE_MUTEX_STATIC_MAIN: i32 = 2;\npub const SQLITE_MUTEX_STATIC_MEM: i32 = 3;\npub const SQLITE_MUTEX_STATIC_MEM2: i32 = 4;\npub const SQLITE_MUTEX_STATIC_OPEN: i32 = 4;\npub const SQLITE_MUTEX_STATIC_PRNG: i32 = 5;\npub const SQLITE_MUTEX_STATIC_LRU: i32 = 6;\npub const SQLITE_MUTEX_STATIC_LRU2: i32 = 7;\npub const SQLITE_MUTEX_STATIC_PMEM: i32 = 7;\npub const SQLITE_MUTEX_STATIC_APP1: i32 = 8;\npub const SQLITE_MUTEX_STATIC_APP2: i32 = 9;\npub const SQLITE_MUTEX_STATIC_APP3: i32 = 10;\npub const SQLITE_MUTEX_STATIC_VFS1: i32 = 11;\npub const SQLITE_MUTEX_STATIC_VFS2: i32 = 12;\npub const SQLITE_MUTEX_STATIC_VFS3: i32 = 13;\npub const SQLITE_MUTEX_STATIC_MASTER: i32 = 2;\npub const SQLITE_TESTCTRL_FIRST: i32 = 5;\npub const SQLITE_TESTCTRL_PRNG_SAVE: i32 = 5;\npub const SQLITE_TESTCTRL_PRNG_RESTORE: i32 = 6;\npub const SQLITE_TESTCTRL_PRNG_RESET: i32 = 7;\npub const SQLITE_TESTCTRL_FK_NO_ACTION: i32 = 7;\npub const SQLITE_TESTCTRL_BITVEC_TEST: i32 = 8;\npub const SQLITE_TESTCTRL_FAULT_INSTALL: i32 = 9;\npub const SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: i32 = 10;\npub const SQLITE_TESTCTRL_PENDING_BYTE: i32 = 11;\npub const SQLITE_TESTCTRL_ASSERT: i32 = 12;\npub const SQLITE_TESTCTRL_ALWAYS: i32 = 13;\npub const SQLITE_TESTCTRL_RESERVE: i32 = 14;\npub const SQLITE_TESTCTRL_OPTIMIZATIONS: i32 = 15;\npub const SQLITE_TESTCTRL_ISKEYWORD: i32 = 16;\npub const SQLITE_TESTCTRL_SCRATCHMALLOC: i32 = 17;\npub const SQLITE_TESTCTRL_INTERNAL_FUNCTIONS: i32 = 17;\npub const SQLITE_TESTCTRL_LOCALTIME_FAULT: i32 = 18;\npub const SQLITE_TESTCTRL_EXPLAIN_STMT: i32 = 19;\npub const SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD: i32 = 19;\npub const SQLITE_TESTCTRL_NEVER_CORRUPT: i32 = 20;\npub const SQLITE_TESTCTRL_VDBE_COVERAGE: i32 = 21;\npub const SQLITE_TESTCTRL_BYTEORDER: i32 = 22;\npub const SQLITE_TESTCTRL_ISINIT: i32 = 23;\npub const SQLITE_TESTCTRL_SORTER_MMAP: i32 = 24;\npub const SQLITE_TESTCTRL_IMPOSTER: i32 = 25;\npub const SQLITE_TESTCTRL_PARSER_COVERAGE: i32 = 26;\npub const SQLITE_TESTCTRL_RESULT_INTREAL: i32 = 27;\npub const SQLITE_TESTCTRL_PRNG_SEED: i32 = 28;\npub const SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS: i32 = 29;\npub const SQLITE_TESTCTRL_SEEK_COUNT: i32 = 30;\npub const SQLITE_TESTCTRL_TRACEFLAGS: i32 = 31;\npub const SQLITE_TESTCTRL_TUNE: i32 = 32;\npub const SQLITE_TESTCTRL_LOGEST: i32 = 33;\npub const SQLITE_TESTCTRL_USELONGDOUBLE: i32 = 34;\npub const SQLITE_TESTCTRL_LAST: i32 = 34;\npub const SQLITE_STATUS_MEMORY_USED: i32 = 0;\npub const SQLITE_STATUS_PAGECACHE_USED: i32 = 1;\npub const SQLITE_STATUS_PAGECACHE_OVERFLOW: i32 = 2;\npub const SQLITE_STATUS_SCRATCH_USED: i32 = 3;\npub const SQLITE_STATUS_SCRATCH_OVERFLOW: i32 = 4;\npub const SQLITE_STATUS_MALLOC_SIZE: i32 = 5;\npub const SQLITE_STATUS_PARSER_STACK: i32 = 6;\npub const SQLITE_STATUS_PAGECACHE_SIZE: i32 = 7;\npub const SQLITE_STATUS_SCRATCH_SIZE: i32 = 8;\npub const SQLITE_STATUS_MALLOC_COUNT: i32 = 9;\npub const SQLITE_DBSTATUS_LOOKASIDE_USED: i32 = 0;\npub const SQLITE_DBSTATUS_CACHE_USED: i32 = 1;\npub const SQLITE_DBSTATUS_SCHEMA_USED: i32 = 2;\npub const SQLITE_DBSTATUS_STMT_USED: i32 = 3;\npub const SQLITE_DBSTATUS_LOOKASIDE_HIT: i32 = 4;\npub const SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE: i32 = 5;\npub const SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: i32 = 6;\npub const SQLITE_DBSTATUS_CACHE_HIT: i32 = 7;\npub const SQLITE_DBSTATUS_CACHE_MISS: i32 = 8;\npub const SQLITE_DBSTATUS_CACHE_WRITE: i32 = 9;\npub const SQLITE_DBSTATUS_DEFERRED_FKS: i32 = 10;\npub const SQLITE_DBSTATUS_CACHE_USED_SHARED: i32 = 11;\npub const SQLITE_DBSTATUS_CACHE_SPILL: i32 = 12;\npub const SQLITE_DBSTATUS_MAX: i32 = 12;\npub const SQLITE_STMTSTATUS_FULLSCAN_STEP: i32 = 1;\npub const SQLITE_STMTSTATUS_SORT: i32 = 2;\npub const SQLITE_STMTSTATUS_AUTOINDEX: i32 = 3;\npub const SQLITE_STMTSTATUS_VM_STEP: i32 = 4;\npub const SQLITE_STMTSTATUS_REPREPARE: i32 = 5;\npub const SQLITE_STMTSTATUS_RUN: i32 = 6;\npub const SQLITE_STMTSTATUS_FILTER_MISS: i32 = 7;\npub const SQLITE_STMTSTATUS_FILTER_HIT: i32 = 8;\npub const SQLITE_STMTSTATUS_MEMUSED: i32 = 99;\npub const SQLITE_CHECKPOINT_PASSIVE: i32 = 0;\npub const SQLITE_CHECKPOINT_FULL: i32 = 1;\npub const SQLITE_CHECKPOINT_RESTART: i32 = 2;\npub const SQLITE_CHECKPOINT_TRUNCATE: i32 = 3;\npub const SQLITE_VTAB_CONSTRAINT_SUPPORT: i32 = 1;\npub const SQLITE_VTAB_INNOCUOUS: i32 = 2;\npub const SQLITE_VTAB_DIRECTONLY: i32 = 3;\npub const SQLITE_VTAB_USES_ALL_SCHEMAS: i32 = 4;\npub const SQLITE_ROLLBACK: i32 = 1;\npub const SQLITE_FAIL: i32 = 3;\npub const SQLITE_REPLACE: i32 = 5;\npub const SQLITE_SCANSTAT_NLOOP: i32 = 0;\npub const SQLITE_SCANSTAT_NVISIT: i32 = 1;\npub const SQLITE_SCANSTAT_EST: i32 = 2;\npub const SQLITE_SCANSTAT_NAME: i32 = 3;\npub const SQLITE_SCANSTAT_EXPLAIN: i32 = 4;\npub const SQLITE_SCANSTAT_SELECTID: i32 = 5;\npub const SQLITE_SCANSTAT_PARENTID: i32 = 6;\npub const SQLITE_SCANSTAT_NCYCLE: i32 = 7;\npub const SQLITE_SCANSTAT_COMPLEX: i32 = 1;\npub const SQLITE_SERIALIZE_NOCOPY: ::std::os::raw::c_uint = 1;\npub const SQLITE_DESERIALIZE_FREEONCLOSE: ::std::os::raw::c_uint = 1;\npub const SQLITE_DESERIALIZE_RESIZEABLE: ::std::os::raw::c_uint = 2;\npub const SQLITE_DESERIALIZE_READONLY: ::std::os::raw::c_uint = 4;\npub const NOT_WITHIN: i32 = 0;\npub const PARTLY_WITHIN: i32 = 1;\npub const FULLY_WITHIN: i32 = 2;\npub const SQLITE_SESSION_OBJCONFIG_SIZE: i32 = 1;\npub const SQLITE_SESSION_OBJCONFIG_ROWID: i32 = 2;\npub const SQLITE_CHANGESETSTART_INVERT: i32 = 2;\npub const SQLITE_CHANGESETAPPLY_NOSAVEPOINT: i32 = 1;\npub const SQLITE_CHANGESETAPPLY_INVERT: i32 = 2;\npub const SQLITE_CHANGESETAPPLY_IGNORENOOP: i32 = 4;\npub const SQLITE_CHANGESETAPPLY_FKNOACTION: i32 = 8;\npub const SQLITE_CHANGESET_DATA: i32 = 1;\npub const SQLITE_CHANGESET_NOTFOUND: i32 = 2;\npub const SQLITE_CHANGESET_CONFLICT: i32 = 3;\npub const SQLITE_CHANGESET_CONSTRAINT: i32 = 4;\npub const SQLITE_CHANGESET_FOREIGN_KEY: i32 = 5;\npub const SQLITE_CHANGESET_OMIT: i32 = 0;\npub const SQLITE_CHANGESET_REPLACE: i32 = 1;\npub const SQLITE_CHANGESET_ABORT: i32 = 2;\npub const SQLITE_SESSION_CONFIG_STRMSIZE: i32 = 1;\npub const FTS5_TOKENIZE_QUERY: i32 = 1;\npub const FTS5_TOKENIZE_PREFIX: i32 = 2;\npub const FTS5_TOKENIZE_DOCUMENT: i32 = 4;\npub const FTS5_TOKENIZE_AUX: i32 = 8;\npub const FTS5_TOKEN_COLOCATED: i32 = 1;\nextern \"C\" {\n    pub static sqlite3_version: [::std::os::raw::c_char; 0usize];\n}\nextern \"C\" {\n    pub fn sqlite3_libversion() -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_sourceid() -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_libversion_number() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_compileoption_used(\n        zOptName: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_compileoption_get(N: ::std::os::raw::c_int) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_threadsafe() -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3 {\n    _unused: [u8; 0],\n}\npub type sqlite_int64 = ::std::os::raw::c_longlong;\npub type sqlite_uint64 = ::std::os::raw::c_ulonglong;\npub type sqlite3_int64 = sqlite_int64;\npub type sqlite3_uint64 = sqlite_uint64;\nextern \"C\" {\n    pub fn sqlite3_close(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_close_v2(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\npub type sqlite3_callback = ::std::option::Option\u003c\n    unsafe extern \"C\" fn(\n        arg1: *mut ::std::os::raw::c_void,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut *mut ::std::os::raw::c_char,\n        arg4: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int,\n\u003e;\nextern \"C\" {\n    pub fn sqlite3_exec(\n        arg1: *mut sqlite3,\n        sql: *const ::std::os::raw::c_char,\n        callback: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut ::std::os::raw::c_char,\n                arg4: *mut *mut ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n        errmsg: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_file {\n    pub pMethods: *const sqlite3_io_methods,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_io_methods {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xClose: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRead: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: *mut ::std::os::raw::c_void,\n            iAmt: ::std::os::raw::c_int,\n            iOfst: sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xWrite: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: *const ::std::os::raw::c_void,\n            iAmt: ::std::os::raw::c_int,\n            iOfst: sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xTruncate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file, size: sqlite3_int64) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSync: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            flags: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFileSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            pSize: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xLock: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xUnlock: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            arg2: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCheckReservedLock: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            pResOut: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFileControl: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            op: ::std::os::raw::c_int,\n            pArg: *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSectorSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDeviceCharacteristics: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_file) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShmMap: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            iPg: ::std::os::raw::c_int,\n            pgsz: ::std::os::raw::c_int,\n            arg2: ::std::os::raw::c_int,\n            arg3: *mut *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShmLock: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            offset: ::std::os::raw::c_int,\n            n: ::std::os::raw::c_int,\n            flags: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShmBarrier: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_file)\u003e,\n    pub xShmUnmap: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            deleteFlag: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFetch: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            iOfst: sqlite3_int64,\n            iAmt: ::std::os::raw::c_int,\n            pp: *mut *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xUnfetch: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_file,\n            iOfst: sqlite3_int64,\n            p: *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_mutex {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_api_routines {\n    _unused: [u8; 0],\n}\npub type sqlite3_filename = *const ::std::os::raw::c_char;\npub type sqlite3_syscall_ptr = ::std::option::Option\u003cunsafe extern \"C\" fn()\u003e;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_vfs {\n    pub iVersion: ::std::os::raw::c_int,\n    pub szOsFile: ::std::os::raw::c_int,\n    pub mxPathname: ::std::os::raw::c_int,\n    pub pNext: *mut sqlite3_vfs,\n    pub zName: *const ::std::os::raw::c_char,\n    pub pAppData: *mut ::std::os::raw::c_void,\n    pub xOpen: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: sqlite3_filename,\n            arg2: *mut sqlite3_file,\n            flags: ::std::os::raw::c_int,\n            pOutFlags: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDelete: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            syncDir: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xAccess: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            flags: ::std::os::raw::c_int,\n            pResOut: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFullPathname: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            nOut: ::std::os::raw::c_int,\n            zOut: *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDlOpen: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zFilename: *const ::std::os::raw::c_char,\n        ) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xDlError: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            nByte: ::std::os::raw::c_int,\n            zErrMsg: *mut ::std::os::raw::c_char,\n        ),\n    \u003e,\n    pub xDlSym: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            arg2: *mut ::std::os::raw::c_void,\n            zSymbol: *const ::std::os::raw::c_char,\n        ) -\u003e ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_vfs,\n                arg2: *mut ::std::os::raw::c_void,\n                zSymbol: *const ::std::os::raw::c_char,\n            ),\n        \u003e,\n    \u003e,\n    pub xDlClose: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vfs, arg2: *mut ::std::os::raw::c_void),\n    \u003e,\n    pub xRandomness: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            nByte: ::std::os::raw::c_int,\n            zOut: *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSleep: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            microseconds: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCurrentTime: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vfs, arg2: *mut f64) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xGetLastError: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            arg2: ::std::os::raw::c_int,\n            arg3: *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCurrentTimeInt64: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            arg2: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSetSystemCall: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n            arg2: sqlite3_syscall_ptr,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xGetSystemCall: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n        ) -\u003e sqlite3_syscall_ptr,\n    \u003e,\n    pub xNextSystemCall: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vfs,\n            zName: *const ::std::os::raw::c_char,\n        ) -\u003e *const ::std::os::raw::c_char,\n    \u003e,\n}\nextern \"C\" {\n    pub fn sqlite3_initialize() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_shutdown() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_os_init() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_os_end() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_config(arg1: ::std::os::raw::c_int, ...) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_config(\n        arg1: *mut sqlite3,\n        op: ::std::os::raw::c_int,\n        ...\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_mem_methods {\n    pub xMalloc: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: ::std::os::raw::c_int) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xFree: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub xRealloc: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            arg2: ::std::os::raw::c_int,\n        ) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRoundup: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: ::std::os::raw::c_int) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xInit: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShutdown: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub pAppData: *mut ::std::os::raw::c_void,\n}\nextern \"C\" {\n    pub fn sqlite3_extended_result_codes(\n        arg1: *mut sqlite3,\n        onoff: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_last_insert_rowid(arg1: *mut sqlite3) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_set_last_insert_rowid(arg1: *mut sqlite3, arg2: sqlite3_int64);\n}\nextern \"C\" {\n    pub fn sqlite3_changes(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_changes64(arg1: *mut sqlite3) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_total_changes(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_total_changes64(arg1: *mut sqlite3) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_interrupt(arg1: *mut sqlite3);\n}\nextern \"C\" {\n    pub fn sqlite3_is_interrupted(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_complete(sql: *const ::std::os::raw::c_char) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_complete16(sql: *const ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_busy_handler(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_busy_timeout(\n        arg1: *mut sqlite3,\n        ms: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_get_table(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        pazResult: *mut *mut *mut ::std::os::raw::c_char,\n        pnRow: *mut ::std::os::raw::c_int,\n        pnColumn: *mut ::std::os::raw::c_int,\n        pzErrmsg: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_free_table(result: *mut *mut ::std::os::raw::c_char);\n}\nextern \"C\" {\n    pub fn sqlite3_mprintf(arg1: *const ::std::os::raw::c_char, ...)\n        -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_snprintf(\n        arg1: ::std::os::raw::c_int,\n        arg2: *mut ::std::os::raw::c_char,\n        arg3: *const ::std::os::raw::c_char,\n        ...\n    ) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_malloc(arg1: ::std::os::raw::c_int) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_malloc64(arg1: sqlite3_uint64) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_realloc(\n        arg1: *mut ::std::os::raw::c_void,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_realloc64(\n        arg1: *mut ::std::os::raw::c_void,\n        arg2: sqlite3_uint64,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_free(arg1: *mut ::std::os::raw::c_void);\n}\nextern \"C\" {\n    pub fn sqlite3_msize(arg1: *mut ::std::os::raw::c_void) -\u003e sqlite3_uint64;\n}\nextern \"C\" {\n    pub fn sqlite3_memory_used() -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_memory_highwater(resetFlag: ::std::os::raw::c_int) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_randomness(N: ::std::os::raw::c_int, P: *mut ::std::os::raw::c_void);\n}\nextern \"C\" {\n    pub fn sqlite3_set_authorizer(\n        arg1: *mut sqlite3,\n        xAuth: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_char,\n                arg4: *const ::std::os::raw::c_char,\n                arg5: *const ::std::os::raw::c_char,\n                arg6: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pUserData: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_trace(\n        arg1: *mut sqlite3,\n        xTrace: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *const ::std::os::raw::c_char,\n            ),\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_profile(\n        arg1: *mut sqlite3,\n        xProfile: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *const ::std::os::raw::c_char,\n                arg3: sqlite3_uint64,\n            ),\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_trace_v2(\n        arg1: *mut sqlite3,\n        uMask: ::std::os::raw::c_uint,\n        xCallback: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: ::std::os::raw::c_uint,\n                arg2: *mut ::std::os::raw::c_void,\n                arg3: *mut ::std::os::raw::c_void,\n                arg4: *mut ::std::os::raw::c_void,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_progress_handler(\n        arg1: *mut sqlite3,\n        arg2: ::std::os::raw::c_int,\n        arg3: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg4: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_open(\n        filename: *const ::std::os::raw::c_char,\n        ppDb: *mut *mut sqlite3,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_open16(\n        filename: *const ::std::os::raw::c_void,\n        ppDb: *mut *mut sqlite3,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_open_v2(\n        filename: *const ::std::os::raw::c_char,\n        ppDb: *mut *mut sqlite3,\n        flags: ::std::os::raw::c_int,\n        zVfs: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_parameter(\n        z: sqlite3_filename,\n        zParam: *const ::std::os::raw::c_char,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_boolean(\n        z: sqlite3_filename,\n        zParam: *const ::std::os::raw::c_char,\n        bDefault: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_int64(\n        arg1: sqlite3_filename,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: sqlite3_int64,\n    ) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_uri_key(\n        z: sqlite3_filename,\n        N: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_filename_database(arg1: sqlite3_filename) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_filename_journal(arg1: sqlite3_filename) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_filename_wal(arg1: sqlite3_filename) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_database_file_object(arg1: *const ::std::os::raw::c_char) -\u003e *mut sqlite3_file;\n}\nextern \"C\" {\n    pub fn sqlite3_create_filename(\n        zDatabase: *const ::std::os::raw::c_char,\n        zJournal: *const ::std::os::raw::c_char,\n        zWal: *const ::std::os::raw::c_char,\n        nParam: ::std::os::raw::c_int,\n        azParam: *mut *const ::std::os::raw::c_char,\n    ) -\u003e sqlite3_filename;\n}\nextern \"C\" {\n    pub fn sqlite3_free_filename(arg1: sqlite3_filename);\n}\nextern \"C\" {\n    pub fn sqlite3_errcode(db: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_extended_errcode(db: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_errmsg(arg1: *mut sqlite3) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_errmsg16(arg1: *mut sqlite3) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_errstr(arg1: ::std::os::raw::c_int) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_error_offset(db: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_stmt {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_limit(\n        arg1: *mut sqlite3,\n        id: ::std::os::raw::c_int,\n        newVal: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        nByte: ::std::os::raw::c_int,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare_v2(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        nByte: ::std::os::raw::c_int,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare_v3(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_char,\n        nByte: ::std::os::raw::c_int,\n        prepFlags: ::std::os::raw::c_uint,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare16(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_void,\n        nByte: ::std::os::raw::c_int,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare16_v2(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_void,\n        nByte: ::std::os::raw::c_int,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_prepare16_v3(\n        db: *mut sqlite3,\n        zSql: *const ::std::os::raw::c_void,\n        nByte: ::std::os::raw::c_int,\n        prepFlags: ::std::os::raw::c_uint,\n        ppStmt: *mut *mut sqlite3_stmt,\n        pzTail: *mut *const ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_isexplain(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_explain(\n        pStmt: *mut sqlite3_stmt,\n        eMode: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_busy(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_value {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_context {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_bind_blob(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_void,\n        n: ::std::os::raw::c_int,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_blob64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_void,\n        arg4: sqlite3_uint64,\n        arg5: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_double(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: f64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_int(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_int64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: sqlite3_int64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_null(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_text(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_char,\n        arg4: ::std::os::raw::c_int,\n        arg5: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_text16(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_void,\n        arg4: ::std::os::raw::c_int,\n        arg5: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_text64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const ::std::os::raw::c_char,\n        arg4: sqlite3_uint64,\n        arg5: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        encoding: ::std::os::raw::c_uchar,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_value(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *const sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_pointer(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut ::std::os::raw::c_void,\n        arg4: *const ::std::os::raw::c_char,\n        arg5: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_zeroblob(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        n: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_zeroblob64(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n        arg3: sqlite3_uint64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_parameter_count(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_parameter_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_bind_parameter_index(\n        arg1: *mut sqlite3_stmt,\n        zName: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_clear_bindings(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_name(\n        arg1: *mut sqlite3_stmt,\n        N: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_name16(\n        arg1: *mut sqlite3_stmt,\n        N: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_column_database_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_database_name16(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_column_table_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_table_name16(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_column_origin_name(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_origin_name16(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_column_decltype(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_column_decltype16(\n        arg1: *mut sqlite3_stmt,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_step(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_data_count(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_blob(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_column_double(arg1: *mut sqlite3_stmt, iCol: ::std::os::raw::c_int) -\u003e f64;\n}\nextern \"C\" {\n    pub fn sqlite3_column_int(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_int64(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_column_text(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_uchar;\n}\nextern \"C\" {\n    pub fn sqlite3_column_text16(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_column_value(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e *mut sqlite3_value;\n}\nextern \"C\" {\n    pub fn sqlite3_column_bytes(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_bytes16(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_column_type(\n        arg1: *mut sqlite3_stmt,\n        iCol: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_function(\n        db: *mut sqlite3,\n        zFunctionName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n        eTextRep: ::std::os::raw::c_int,\n        pApp: *mut ::std::os::raw::c_void,\n        xFunc: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xStep: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xFinal: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_context)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_function16(\n        db: *mut sqlite3,\n        zFunctionName: *const ::std::os::raw::c_void,\n        nArg: ::std::os::raw::c_int,\n        eTextRep: ::std::os::raw::c_int,\n        pApp: *mut ::std::os::raw::c_void,\n        xFunc: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xStep: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xFinal: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_context)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_function_v2(\n        db: *mut sqlite3,\n        zFunctionName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n        eTextRep: ::std::os::raw::c_int,\n        pApp: *mut ::std::os::raw::c_void,\n        xFunc: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xStep: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xFinal: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_context)\u003e,\n        xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_window_function(\n        db: *mut sqlite3,\n        zFunctionName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n        eTextRep: ::std::os::raw::c_int,\n        pApp: *mut ::std::os::raw::c_void,\n        xStep: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xFinal: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_context)\u003e,\n        xValue: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_context)\u003e,\n        xInverse: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_context,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut *mut sqlite3_value,\n            ),\n        \u003e,\n        xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_aggregate_count(arg1: *mut sqlite3_context) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_expired(arg1: *mut sqlite3_stmt) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_transfer_bindings(\n        arg1: *mut sqlite3_stmt,\n        arg2: *mut sqlite3_stmt,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_global_recover() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_thread_cleanup();\n}\nextern \"C\" {\n    pub fn sqlite3_memory_alarm(\n        arg1: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: sqlite3_int64,\n                arg3: ::std::os::raw::c_int,\n            ),\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: sqlite3_int64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_blob(arg1: *mut sqlite3_value) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_value_double(arg1: *mut sqlite3_value) -\u003e f64;\n}\nextern \"C\" {\n    pub fn sqlite3_value_int(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_int64(arg1: *mut sqlite3_value) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_value_pointer(\n        arg1: *mut sqlite3_value,\n        arg2: *const ::std::os::raw::c_char,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_value_text(arg1: *mut sqlite3_value) -\u003e *const ::std::os::raw::c_uchar;\n}\nextern \"C\" {\n    pub fn sqlite3_value_text16(arg1: *mut sqlite3_value) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_value_text16le(arg1: *mut sqlite3_value) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_value_text16be(arg1: *mut sqlite3_value) -\u003e *const ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_value_bytes(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_bytes16(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_type(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_numeric_type(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_nochange(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_frombind(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_encoding(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_value_subtype(arg1: *mut sqlite3_value) -\u003e ::std::os::raw::c_uint;\n}\nextern \"C\" {\n    pub fn sqlite3_value_dup(arg1: *const sqlite3_value) -\u003e *mut sqlite3_value;\n}\nextern \"C\" {\n    pub fn sqlite3_value_free(arg1: *mut sqlite3_value);\n}\nextern \"C\" {\n    pub fn sqlite3_aggregate_context(\n        arg1: *mut sqlite3_context,\n        nBytes: ::std::os::raw::c_int,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_user_data(arg1: *mut sqlite3_context) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_context_db_handle(arg1: *mut sqlite3_context) -\u003e *mut sqlite3;\n}\nextern \"C\" {\n    pub fn sqlite3_get_auxdata(\n        arg1: *mut sqlite3_context,\n        N: ::std::os::raw::c_int,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_set_auxdata(\n        arg1: *mut sqlite3_context,\n        N: ::std::os::raw::c_int,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_get_clientdata(\n        arg1: *mut sqlite3,\n        arg2: *const ::std::os::raw::c_char,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_set_clientdata(\n        arg1: *mut sqlite3,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: *mut ::std::os::raw::c_void,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\npub type sqlite3_destructor_type =\n    ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e;\nextern \"C\" {\n    pub fn sqlite3_result_blob(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: ::std::os::raw::c_int,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_blob64(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: sqlite3_uint64,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_double(arg1: *mut sqlite3_context, arg2: f64);\n}\nextern \"C\" {\n    pub fn sqlite3_result_error(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: ::std::os::raw::c_int,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_error16(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: ::std::os::raw::c_int,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_error_toobig(arg1: *mut sqlite3_context);\n}\nextern \"C\" {\n    pub fn sqlite3_result_error_nomem(arg1: *mut sqlite3_context);\n}\nextern \"C\" {\n    pub fn sqlite3_result_error_code(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_result_int(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_result_int64(arg1: *mut sqlite3_context, arg2: sqlite3_int64);\n}\nextern \"C\" {\n    pub fn sqlite3_result_null(arg1: *mut sqlite3_context);\n}\nextern \"C\" {\n    pub fn sqlite3_result_text(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: ::std::os::raw::c_int,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_text64(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: sqlite3_uint64,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        encoding: ::std::os::raw::c_uchar,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_text16(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: ::std::os::raw::c_int,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_text16le(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: ::std::os::raw::c_int,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_text16be(\n        arg1: *mut sqlite3_context,\n        arg2: *const ::std::os::raw::c_void,\n        arg3: ::std::os::raw::c_int,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_value(arg1: *mut sqlite3_context, arg2: *mut sqlite3_value);\n}\nextern \"C\" {\n    pub fn sqlite3_result_pointer(\n        arg1: *mut sqlite3_context,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: *const ::std::os::raw::c_char,\n        arg4: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_result_zeroblob(arg1: *mut sqlite3_context, n: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_result_zeroblob64(\n        arg1: *mut sqlite3_context,\n        n: sqlite3_uint64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_result_subtype(arg1: *mut sqlite3_context, arg2: ::std::os::raw::c_uint);\n}\nextern \"C\" {\n    pub fn sqlite3_create_collation(\n        arg1: *mut sqlite3,\n        zName: *const ::std::os::raw::c_char,\n        eTextRep: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n        xCompare: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_void,\n                arg4: ::std::os::raw::c_int,\n                arg5: *const ::std::os::raw::c_void,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_collation_v2(\n        arg1: *mut sqlite3,\n        zName: *const ::std::os::raw::c_char,\n        eTextRep: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n        xCompare: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_void,\n                arg4: ::std::os::raw::c_int,\n                arg5: *const ::std::os::raw::c_void,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_collation16(\n        arg1: *mut sqlite3,\n        zName: *const ::std::os::raw::c_void,\n        eTextRep: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n        xCompare: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_void,\n                arg4: ::std::os::raw::c_int,\n                arg5: *const ::std::os::raw::c_void,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_collation_needed(\n        arg1: *mut sqlite3,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *mut sqlite3,\n                eTextRep: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_char,\n            ),\n        \u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_collation_needed16(\n        arg1: *mut sqlite3,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *mut sqlite3,\n                eTextRep: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_void,\n            ),\n        \u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_sleep(arg1: ::std::os::raw::c_int) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub static mut sqlite3_temp_directory: *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub static mut sqlite3_data_directory: *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_win32_set_directory(\n        type_: ::std::os::raw::c_ulong,\n        zValue: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_win32_set_directory8(\n        type_: ::std::os::raw::c_ulong,\n        zValue: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_win32_set_directory16(\n        type_: ::std::os::raw::c_ulong,\n        zValue: *const ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_get_autocommit(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_handle(arg1: *mut sqlite3_stmt) -\u003e *mut sqlite3;\n}\nextern \"C\" {\n    pub fn sqlite3_db_name(\n        db: *mut sqlite3,\n        N: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_db_filename(\n        db: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n    ) -\u003e sqlite3_filename;\n}\nextern \"C\" {\n    pub fn sqlite3_db_readonly(\n        db: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_txn_state(\n        arg1: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_next_stmt(pDb: *mut sqlite3, pStmt: *mut sqlite3_stmt) -\u003e *mut sqlite3_stmt;\n}\nextern \"C\" {\n    pub fn sqlite3_commit_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_rollback_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_autovacuum_pages(\n        db: *mut sqlite3,\n        arg1: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *const ::std::os::raw::c_char,\n                arg3: ::std::os::raw::c_uint,\n                arg4: ::std::os::raw::c_uint,\n                arg5: ::std::os::raw::c_uint,\n            ) -\u003e ::std::os::raw::c_uint,\n        \u003e,\n        arg2: *mut ::std::os::raw::c_void,\n        arg3: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_update_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: ::std::os::raw::c_int,\n                arg3: *const ::std::os::raw::c_char,\n                arg4: *const ::std::os::raw::c_char,\n                arg5: sqlite3_int64,\n            ),\n        \u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_enable_shared_cache(arg1: ::std::os::raw::c_int) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_release_memory(arg1: ::std::os::raw::c_int) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_release_memory(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_soft_heap_limit64(N: sqlite3_int64) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_hard_heap_limit64(N: sqlite3_int64) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3_soft_heap_limit(N: ::std::os::raw::c_int);\n}\nextern \"C\" {\n    pub fn sqlite3_table_column_metadata(\n        db: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n        zTableName: *const ::std::os::raw::c_char,\n        zColumnName: *const ::std::os::raw::c_char,\n        pzDataType: *mut *const ::std::os::raw::c_char,\n        pzCollSeq: *mut *const ::std::os::raw::c_char,\n        pNotNull: *mut ::std::os::raw::c_int,\n        pPrimaryKey: *mut ::std::os::raw::c_int,\n        pAutoinc: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_load_extension(\n        db: *mut sqlite3,\n        zFile: *const ::std::os::raw::c_char,\n        zProc: *const ::std::os::raw::c_char,\n        pzErrMsg: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_enable_load_extension(\n        db: *mut sqlite3,\n        onoff: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_reset_auto_extension();\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_module {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xCreate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3,\n            pAux: *mut ::std::os::raw::c_void,\n            argc: ::std::os::raw::c_int,\n            argv: *const *const ::std::os::raw::c_char,\n            ppVTab: *mut *mut sqlite3_vtab,\n            arg2: *mut *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xConnect: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3,\n            pAux: *mut ::std::os::raw::c_void,\n            argc: ::std::os::raw::c_int,\n            argv: *const *const ::std::os::raw::c_char,\n            ppVTab: *mut *mut sqlite3_vtab,\n            arg2: *mut *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xBestIndex: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: *mut sqlite3_index_info,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDisconnect: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDestroy: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xOpen: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            ppCursor: *mut *mut sqlite3_vtab_cursor,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xClose: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vtab_cursor) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFilter: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab_cursor,\n            idxNum: ::std::os::raw::c_int,\n            idxStr: *const ::std::os::raw::c_char,\n            argc: ::std::os::raw::c_int,\n            argv: *mut *mut sqlite3_value,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xNext: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vtab_cursor) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xEof: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_vtab_cursor) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xColumn: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab_cursor,\n            arg2: *mut sqlite3_context,\n            arg3: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRowid: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab_cursor,\n            pRowid: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xUpdate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_vtab,\n            arg2: ::std::os::raw::c_int,\n            arg3: *mut *mut sqlite3_value,\n            arg4: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xBegin: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSync: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCommit: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRollback: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(pVTab: *mut sqlite3_vtab) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFindFunction: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVtab: *mut sqlite3_vtab,\n            nArg: ::std::os::raw::c_int,\n            zName: *const ::std::os::raw::c_char,\n            pxFunc: *mut ::std::option::Option\u003c\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: ::std::os::raw::c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            \u003e,\n            ppArg: *mut *mut ::std::os::raw::c_void,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRename: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVtab: *mut sqlite3_vtab,\n            zNew: *const ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSavepoint: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRelease: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRollbackTo: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            arg1: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShadowName: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *const ::std::os::raw::c_char) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xIntegrity: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pVTab: *mut sqlite3_vtab,\n            zSchema: *const ::std::os::raw::c_char,\n            zTabName: *const ::std::os::raw::c_char,\n            mFlags: ::std::os::raw::c_int,\n            pzErr: *mut *mut ::std::os::raw::c_char,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_info {\n    pub nConstraint: ::std::os::raw::c_int,\n    pub aConstraint: *mut sqlite3_index_constraint,\n    pub nOrderBy: ::std::os::raw::c_int,\n    pub aOrderBy: *mut sqlite3_index_orderby,\n    pub aConstraintUsage: *mut sqlite3_index_constraint_usage,\n    pub idxNum: ::std::os::raw::c_int,\n    pub idxStr: *mut ::std::os::raw::c_char,\n    pub needToFreeIdxStr: ::std::os::raw::c_int,\n    pub orderByConsumed: ::std::os::raw::c_int,\n    pub estimatedCost: f64,\n    pub estimatedRows: sqlite3_int64,\n    pub idxFlags: ::std::os::raw::c_int,\n    pub colUsed: sqlite3_uint64,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_constraint {\n    pub iColumn: ::std::os::raw::c_int,\n    pub op: ::std::os::raw::c_uchar,\n    pub usable: ::std::os::raw::c_uchar,\n    pub iTermOffset: ::std::os::raw::c_int,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_orderby {\n    pub iColumn: ::std::os::raw::c_int,\n    pub desc: ::std::os::raw::c_uchar,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_index_constraint_usage {\n    pub argvIndex: ::std::os::raw::c_int,\n    pub omit: ::std::os::raw::c_uchar,\n}\nextern \"C\" {\n    pub fn sqlite3_create_module(\n        db: *mut sqlite3,\n        zName: *const ::std::os::raw::c_char,\n        p: *const sqlite3_module,\n        pClientData: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_create_module_v2(\n        db: *mut sqlite3,\n        zName: *const ::std::os::raw::c_char,\n        p: *const sqlite3_module,\n        pClientData: *mut ::std::os::raw::c_void,\n        xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_drop_modules(\n        db: *mut sqlite3,\n        azKeep: *mut *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_vtab {\n    pub pModule: *const sqlite3_module,\n    pub nRef: ::std::os::raw::c_int,\n    pub zErrMsg: *mut ::std::os::raw::c_char,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_vtab_cursor {\n    pub pVtab: *mut sqlite3_vtab,\n}\nextern \"C\" {\n    pub fn sqlite3_declare_vtab(\n        arg1: *mut sqlite3,\n        zSQL: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_overload_function(\n        arg1: *mut sqlite3,\n        zFuncName: *const ::std::os::raw::c_char,\n        nArg: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_blob {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_blob_open(\n        arg1: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        zTable: *const ::std::os::raw::c_char,\n        zColumn: *const ::std::os::raw::c_char,\n        iRow: sqlite3_int64,\n        flags: ::std::os::raw::c_int,\n        ppBlob: *mut *mut sqlite3_blob,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_reopen(\n        arg1: *mut sqlite3_blob,\n        arg2: sqlite3_int64,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_close(arg1: *mut sqlite3_blob) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_bytes(arg1: *mut sqlite3_blob) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_read(\n        arg1: *mut sqlite3_blob,\n        Z: *mut ::std::os::raw::c_void,\n        N: ::std::os::raw::c_int,\n        iOffset: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_blob_write(\n        arg1: *mut sqlite3_blob,\n        z: *const ::std::os::raw::c_void,\n        n: ::std::os::raw::c_int,\n        iOffset: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vfs_find(zVfsName: *const ::std::os::raw::c_char) -\u003e *mut sqlite3_vfs;\n}\nextern \"C\" {\n    pub fn sqlite3_vfs_register(\n        arg1: *mut sqlite3_vfs,\n        makeDflt: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vfs_unregister(arg1: *mut sqlite3_vfs) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_alloc(arg1: ::std::os::raw::c_int) -\u003e *mut sqlite3_mutex;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_free(arg1: *mut sqlite3_mutex);\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_enter(arg1: *mut sqlite3_mutex);\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_try(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_leave(arg1: *mut sqlite3_mutex);\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_mutex_methods {\n    pub xMutexInit: ::std::option::Option\u003cunsafe extern \"C\" fn() -\u003e ::std::os::raw::c_int\u003e,\n    pub xMutexEnd: ::std::option::Option\u003cunsafe extern \"C\" fn() -\u003e ::std::os::raw::c_int\u003e,\n    pub xMutexAlloc: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: ::std::os::raw::c_int) -\u003e *mut sqlite3_mutex,\n    \u003e,\n    pub xMutexFree: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_mutex)\u003e,\n    pub xMutexEnter: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_mutex)\u003e,\n    pub xMutexTry: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xMutexLeave: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_mutex)\u003e,\n    pub xMutexHeld: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xMutexNotheld: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_held(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_mutex_notheld(arg1: *mut sqlite3_mutex) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_mutex(arg1: *mut sqlite3) -\u003e *mut sqlite3_mutex;\n}\nextern \"C\" {\n    pub fn sqlite3_file_control(\n        arg1: *mut sqlite3,\n        zDbName: *const ::std::os::raw::c_char,\n        op: ::std::os::raw::c_int,\n        arg2: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_test_control(op: ::std::os::raw::c_int, ...) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_keyword_count() -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_keyword_name(\n        arg1: ::std::os::raw::c_int,\n        arg2: *mut *const ::std::os::raw::c_char,\n        arg3: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_keyword_check(\n        arg1: *const ::std::os::raw::c_char,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_str {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_str_new(arg1: *mut sqlite3) -\u003e *mut sqlite3_str;\n}\nextern \"C\" {\n    pub fn sqlite3_str_finish(arg1: *mut sqlite3_str) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_str_appendf(arg1: *mut sqlite3_str, zFormat: *const ::std::os::raw::c_char, ...);\n}\nextern \"C\" {\n    pub fn sqlite3_str_append(\n        arg1: *mut sqlite3_str,\n        zIn: *const ::std::os::raw::c_char,\n        N: ::std::os::raw::c_int,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_str_appendall(arg1: *mut sqlite3_str, zIn: *const ::std::os::raw::c_char);\n}\nextern \"C\" {\n    pub fn sqlite3_str_appendchar(\n        arg1: *mut sqlite3_str,\n        N: ::std::os::raw::c_int,\n        C: ::std::os::raw::c_char,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_str_reset(arg1: *mut sqlite3_str);\n}\nextern \"C\" {\n    pub fn sqlite3_str_errcode(arg1: *mut sqlite3_str) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_str_length(arg1: *mut sqlite3_str) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_str_value(arg1: *mut sqlite3_str) -\u003e *mut ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_status(\n        op: ::std::os::raw::c_int,\n        pCurrent: *mut ::std::os::raw::c_int,\n        pHighwater: *mut ::std::os::raw::c_int,\n        resetFlag: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_status64(\n        op: ::std::os::raw::c_int,\n        pCurrent: *mut sqlite3_int64,\n        pHighwater: *mut sqlite3_int64,\n        resetFlag: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_db_status(\n        arg1: *mut sqlite3,\n        op: ::std::os::raw::c_int,\n        pCur: *mut ::std::os::raw::c_int,\n        pHiwtr: *mut ::std::os::raw::c_int,\n        resetFlg: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_status(\n        arg1: *mut sqlite3_stmt,\n        op: ::std::os::raw::c_int,\n        resetFlg: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache_page {\n    pub pBuf: *mut ::std::os::raw::c_void,\n    pub pExtra: *mut ::std::os::raw::c_void,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache_methods2 {\n    pub iVersion: ::std::os::raw::c_int,\n    pub pArg: *mut ::std::os::raw::c_void,\n    pub xInit: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShutdown: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub xCreate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            szPage: ::std::os::raw::c_int,\n            szExtra: ::std::os::raw::c_int,\n            bPurgeable: ::std::os::raw::c_int,\n        ) -\u003e *mut sqlite3_pcache,\n    \u003e,\n    pub xCachesize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),\n    \u003e,\n    pub xPagecount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFetch: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            key: ::std::os::raw::c_uint,\n            createFlag: ::std::os::raw::c_int,\n        ) -\u003e *mut sqlite3_pcache_page,\n    \u003e,\n    pub xUnpin: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut sqlite3_pcache_page,\n            discard: ::std::os::raw::c_int,\n        ),\n    \u003e,\n    pub xRekey: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut sqlite3_pcache_page,\n            oldKey: ::std::os::raw::c_uint,\n            newKey: ::std::os::raw::c_uint,\n        ),\n    \u003e,\n    pub xTruncate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),\n    \u003e,\n    pub xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_pcache)\u003e,\n    pub xShrink: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_pcache)\u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_pcache_methods {\n    pub pArg: *mut ::std::os::raw::c_void,\n    pub xInit: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xShutdown: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub xCreate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            szPage: ::std::os::raw::c_int,\n            bPurgeable: ::std::os::raw::c_int,\n        ) -\u003e *mut sqlite3_pcache,\n    \u003e,\n    pub xCachesize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, nCachesize: ::std::os::raw::c_int),\n    \u003e,\n    pub xPagecount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFetch: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            key: ::std::os::raw::c_uint,\n            createFlag: ::std::os::raw::c_int,\n        ) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xUnpin: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut ::std::os::raw::c_void,\n            discard: ::std::os::raw::c_int,\n        ),\n    \u003e,\n    pub xRekey: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut sqlite3_pcache,\n            arg2: *mut ::std::os::raw::c_void,\n            oldKey: ::std::os::raw::c_uint,\n            newKey: ::std::os::raw::c_uint,\n        ),\n    \u003e,\n    pub xTruncate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut sqlite3_pcache, iLimit: ::std::os::raw::c_uint),\n    \u003e,\n    pub xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut sqlite3_pcache)\u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_backup {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3_backup_init(\n        pDest: *mut sqlite3,\n        zDestName: *const ::std::os::raw::c_char,\n        pSource: *mut sqlite3,\n        zSourceName: *const ::std::os::raw::c_char,\n    ) -\u003e *mut sqlite3_backup;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_step(\n        p: *mut sqlite3_backup,\n        nPage: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_finish(p: *mut sqlite3_backup) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_remaining(p: *mut sqlite3_backup) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_backup_pagecount(p: *mut sqlite3_backup) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_unlock_notify(\n        pBlocked: *mut sqlite3,\n        xNotify: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                apArg: *mut *mut ::std::os::raw::c_void,\n                nArg: ::std::os::raw::c_int,\n            ),\n        \u003e,\n        pNotifyArg: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stricmp(\n        arg1: *const ::std::os::raw::c_char,\n        arg2: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_strnicmp(\n        arg1: *const ::std::os::raw::c_char,\n        arg2: *const ::std::os::raw::c_char,\n        arg3: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_strglob(\n        zGlob: *const ::std::os::raw::c_char,\n        zStr: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_strlike(\n        zGlob: *const ::std::os::raw::c_char,\n        zStr: *const ::std::os::raw::c_char,\n        cEsc: ::std::os::raw::c_uint,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_log(\n        iErrCode: ::std::os::raw::c_int,\n        zFormat: *const ::std::os::raw::c_char,\n        ...\n    );\n}\nextern \"C\" {\n    pub fn sqlite3_wal_hook(\n        arg1: *mut sqlite3,\n        arg2: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut ::std::os::raw::c_void,\n                arg2: *mut sqlite3,\n                arg3: *const ::std::os::raw::c_char,\n                arg4: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        arg3: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_wal_autocheckpoint(\n        db: *mut sqlite3,\n        N: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_wal_checkpoint(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_wal_checkpoint_v2(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        eMode: ::std::os::raw::c_int,\n        pnLog: *mut ::std::os::raw::c_int,\n        pnCkpt: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_config(\n        arg1: *mut sqlite3,\n        op: ::std::os::raw::c_int,\n        ...\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_on_conflict(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_nochange(arg1: *mut sqlite3_context) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_collation(\n        arg1: *mut sqlite3_index_info,\n        arg2: ::std::os::raw::c_int,\n    ) -\u003e *const ::std::os::raw::c_char;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_distinct(arg1: *mut sqlite3_index_info) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_in(\n        arg1: *mut sqlite3_index_info,\n        iCons: ::std::os::raw::c_int,\n        bHandle: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_in_first(\n        pVal: *mut sqlite3_value,\n        ppOut: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_in_next(\n        pVal: *mut sqlite3_value,\n        ppOut: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_vtab_rhs_value(\n        arg1: *mut sqlite3_index_info,\n        arg2: ::std::os::raw::c_int,\n        ppVal: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_scanstatus(\n        pStmt: *mut sqlite3_stmt,\n        idx: ::std::os::raw::c_int,\n        iScanStatusOp: ::std::os::raw::c_int,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_scanstatus_v2(\n        pStmt: *mut sqlite3_stmt,\n        idx: ::std::os::raw::c_int,\n        iScanStatusOp: ::std::os::raw::c_int,\n        flags: ::std::os::raw::c_int,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_stmt_scanstatus_reset(arg1: *mut sqlite3_stmt);\n}\nextern \"C\" {\n    pub fn sqlite3_db_cacheflush(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_hook(\n        db: *mut sqlite3,\n        xPreUpdate: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                db: *mut sqlite3,\n                op: ::std::os::raw::c_int,\n                zDb: *const ::std::os::raw::c_char,\n                zName: *const ::std::os::raw::c_char,\n                iKey1: sqlite3_int64,\n                iKey2: sqlite3_int64,\n            ),\n        \u003e,\n        arg1: *mut ::std::os::raw::c_void,\n    ) -\u003e *mut ::std::os::raw::c_void;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_old(\n        arg1: *mut sqlite3,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_count(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_depth(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_new(\n        arg1: *mut sqlite3,\n        arg2: ::std::os::raw::c_int,\n        arg3: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_preupdate_blobwrite(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_system_errno(arg1: *mut sqlite3) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_snapshot {\n    pub hidden: [::std::os::raw::c_uchar; 48usize],\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_get(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        ppSnapshot: *mut *mut sqlite3_snapshot,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_open(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        pSnapshot: *mut sqlite3_snapshot,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_free(arg1: *mut sqlite3_snapshot);\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_cmp(\n        p1: *mut sqlite3_snapshot,\n        p2: *mut sqlite3_snapshot,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_snapshot_recover(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3_serialize(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        piSize: *mut sqlite3_int64,\n        mFlags: ::std::os::raw::c_uint,\n    ) -\u003e *mut ::std::os::raw::c_uchar;\n}\nextern \"C\" {\n    pub fn sqlite3_deserialize(\n        db: *mut sqlite3,\n        zSchema: *const ::std::os::raw::c_char,\n        pData: *mut ::std::os::raw::c_uchar,\n        szDb: sqlite3_int64,\n        szBuf: sqlite3_int64,\n        mFlags: ::std::os::raw::c_uint,\n    ) -\u003e ::std::os::raw::c_int;\n}\npub type sqlite3_rtree_dbl = f64;\nextern \"C\" {\n    pub fn sqlite3_rtree_geometry_callback(\n        db: *mut sqlite3,\n        zGeom: *const ::std::os::raw::c_char,\n        xGeom: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                arg1: *mut sqlite3_rtree_geometry,\n                arg2: ::std::os::raw::c_int,\n                arg3: *mut sqlite3_rtree_dbl,\n                arg4: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pContext: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_rtree_geometry {\n    pub pContext: *mut ::std::os::raw::c_void,\n    pub nParam: ::std::os::raw::c_int,\n    pub aParam: *mut sqlite3_rtree_dbl,\n    pub pUser: *mut ::std::os::raw::c_void,\n    pub xDelUser: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n}\nextern \"C\" {\n    pub fn sqlite3_rtree_query_callback(\n        db: *mut sqlite3,\n        zQueryFunc: *const ::std::os::raw::c_char,\n        xQueryFunc: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(arg1: *mut sqlite3_rtree_query_info) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pContext: *mut ::std::os::raw::c_void,\n        xDestructor: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_rtree_query_info {\n    pub pContext: *mut ::std::os::raw::c_void,\n    pub nParam: ::std::os::raw::c_int,\n    pub aParam: *mut sqlite3_rtree_dbl,\n    pub pUser: *mut ::std::os::raw::c_void,\n    pub xDelUser: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n    pub aCoord: *mut sqlite3_rtree_dbl,\n    pub anQueue: *mut ::std::os::raw::c_uint,\n    pub nCoord: ::std::os::raw::c_int,\n    pub iLevel: ::std::os::raw::c_int,\n    pub mxLevel: ::std::os::raw::c_int,\n    pub iRowid: sqlite3_int64,\n    pub rParentScore: sqlite3_rtree_dbl,\n    pub eParentWithin: ::std::os::raw::c_int,\n    pub eWithin: ::std::os::raw::c_int,\n    pub rScore: sqlite3_rtree_dbl,\n    pub apSqlParam: *mut *mut sqlite3_value,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_session {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_changeset_iter {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3session_create(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        ppSession: *mut *mut sqlite3_session,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_delete(pSession: *mut sqlite3_session);\n}\nextern \"C\" {\n    pub fn sqlite3session_object_config(\n        arg1: *mut sqlite3_session,\n        op: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_enable(\n        pSession: *mut sqlite3_session,\n        bEnable: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_indirect(\n        pSession: *mut sqlite3_session,\n        bIndirect: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_attach(\n        pSession: *mut sqlite3_session,\n        zTab: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_table_filter(\n        pSession: *mut sqlite3_session,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n    );\n}\nextern \"C\" {\n    pub fn sqlite3session_changeset(\n        pSession: *mut sqlite3_session,\n        pnChangeset: *mut ::std::os::raw::c_int,\n        ppChangeset: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_changeset_size(pSession: *mut sqlite3_session) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3session_diff(\n        pSession: *mut sqlite3_session,\n        zFromDb: *const ::std::os::raw::c_char,\n        zTbl: *const ::std::os::raw::c_char,\n        pzErrMsg: *mut *mut ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_patchset(\n        pSession: *mut sqlite3_session,\n        pnPatchset: *mut ::std::os::raw::c_int,\n        ppPatchset: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_isempty(pSession: *mut sqlite3_session) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_memory_used(pSession: *mut sqlite3_session) -\u003e sqlite3_int64;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start(\n        pp: *mut *mut sqlite3_changeset_iter,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start_v2(\n        pp: *mut *mut sqlite3_changeset_iter,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n        flags: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_next(pIter: *mut sqlite3_changeset_iter) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_op(\n        pIter: *mut sqlite3_changeset_iter,\n        pzTab: *mut *const ::std::os::raw::c_char,\n        pnCol: *mut ::std::os::raw::c_int,\n        pOp: *mut ::std::os::raw::c_int,\n        pbIndirect: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_pk(\n        pIter: *mut sqlite3_changeset_iter,\n        pabPK: *mut *mut ::std::os::raw::c_uchar,\n        pnCol: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_old(\n        pIter: *mut sqlite3_changeset_iter,\n        iVal: ::std::os::raw::c_int,\n        ppValue: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_new(\n        pIter: *mut sqlite3_changeset_iter,\n        iVal: ::std::os::raw::c_int,\n        ppValue: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_conflict(\n        pIter: *mut sqlite3_changeset_iter,\n        iVal: ::std::os::raw::c_int,\n        ppValue: *mut *mut sqlite3_value,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_fk_conflicts(\n        pIter: *mut sqlite3_changeset_iter,\n        pnOut: *mut ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_finalize(pIter: *mut sqlite3_changeset_iter) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_invert(\n        nIn: ::std::os::raw::c_int,\n        pIn: *const ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_concat(\n        nA: ::std::os::raw::c_int,\n        pA: *mut ::std::os::raw::c_void,\n        nB: ::std::os::raw::c_int,\n        pB: *mut ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_upgrade(\n        db: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n        nIn: ::std::os::raw::c_int,\n        pIn: *const ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_changegroup {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_new(pp: *mut *mut sqlite3_changegroup) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_schema(\n        arg1: *mut sqlite3_changegroup,\n        arg2: *mut sqlite3,\n        zDb: *const ::std::os::raw::c_char,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_add(\n        arg1: *mut sqlite3_changegroup,\n        nData: ::std::os::raw::c_int,\n        pData: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_output(\n        arg1: *mut sqlite3_changegroup,\n        pnData: *mut ::std::os::raw::c_int,\n        ppData: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_delete(arg1: *mut sqlite3_changegroup);\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply(\n        db: *mut sqlite3,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xConflict: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply_v2(\n        db: *mut sqlite3,\n        nChangeset: ::std::os::raw::c_int,\n        pChangeset: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xConflict: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n        ppRebase: *mut *mut ::std::os::raw::c_void,\n        pnRebase: *mut ::std::os::raw::c_int,\n        flags: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct sqlite3_rebaser {\n    _unused: [u8; 0],\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_create(ppNew: *mut *mut sqlite3_rebaser) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_configure(\n        arg1: *mut sqlite3_rebaser,\n        nRebase: ::std::os::raw::c_int,\n        pRebase: *const ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_rebase(\n        arg1: *mut sqlite3_rebaser,\n        nIn: ::std::os::raw::c_int,\n        pIn: *const ::std::os::raw::c_void,\n        pnOut: *mut ::std::os::raw::c_int,\n        ppOut: *mut *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_delete(p: *mut sqlite3_rebaser);\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply_strm(\n        db: *mut sqlite3,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xConflict: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_apply_v2_strm(\n        db: *mut sqlite3,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        xFilter: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                zTab: *const ::std::os::raw::c_char,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        xConflict: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pCtx: *mut ::std::os::raw::c_void,\n                eConflict: ::std::os::raw::c_int,\n                p: *mut sqlite3_changeset_iter,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pCtx: *mut ::std::os::raw::c_void,\n        ppRebase: *mut *mut ::std::os::raw::c_void,\n        pnRebase: *mut ::std::os::raw::c_int,\n        flags: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_concat_strm(\n        xInputA: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pInA: *mut ::std::os::raw::c_void,\n        xInputB: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pInB: *mut ::std::os::raw::c_void,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_invert_strm(\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start_strm(\n        pp: *mut *mut sqlite3_changeset_iter,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changeset_start_v2_strm(\n        pp: *mut *mut sqlite3_changeset_iter,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        flags: ::std::os::raw::c_int,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_changeset_strm(\n        pSession: *mut sqlite3_session,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_patchset_strm(\n        pSession: *mut sqlite3_session,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_add_strm(\n        arg1: *mut sqlite3_changegroup,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3changegroup_output_strm(\n        arg1: *mut sqlite3_changegroup,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3rebaser_rebase_strm(\n        pRebaser: *mut sqlite3_rebaser,\n        xInput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pIn: *mut ::std::os::raw::c_void,\n                pData: *mut ::std::os::raw::c_void,\n                pnData: *mut ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pIn: *mut ::std::os::raw::c_void,\n        xOutput: ::std::option::Option\u003c\n            unsafe extern \"C\" fn(\n                pOut: *mut ::std::os::raw::c_void,\n                pData: *const ::std::os::raw::c_void,\n                nData: ::std::os::raw::c_int,\n            ) -\u003e ::std::os::raw::c_int,\n        \u003e,\n        pOut: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\nextern \"C\" {\n    pub fn sqlite3session_config(\n        op: ::std::os::raw::c_int,\n        pArg: *mut ::std::os::raw::c_void,\n    ) -\u003e ::std::os::raw::c_int;\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5Context {\n    _unused: [u8; 0],\n}\npub type fts5_extension_function = ::std::option::Option\u003c\n    unsafe extern \"C\" fn(\n        pApi: *const Fts5ExtensionApi,\n        pFts: *mut Fts5Context,\n        pCtx: *mut sqlite3_context,\n        nVal: ::std::os::raw::c_int,\n        apVal: *mut *mut sqlite3_value,\n    ),\n\u003e;\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5PhraseIter {\n    pub a: *const ::std::os::raw::c_uchar,\n    pub b: *const ::std::os::raw::c_uchar,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5ExtensionApi {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xUserData: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut Fts5Context) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xColumnCount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut Fts5Context) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRowCount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pnRow: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xColumnTotalSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iCol: ::std::os::raw::c_int,\n            pnToken: *mut sqlite3_int64,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xTokenize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pText: *const ::std::os::raw::c_char,\n            nText: ::std::os::raw::c_int,\n            pCtx: *mut ::std::os::raw::c_void,\n            xToken: ::std::option::Option\u003c\n                unsafe extern \"C\" fn(\n                    arg1: *mut ::std::os::raw::c_void,\n                    arg2: ::std::os::raw::c_int,\n                    arg3: *const ::std::os::raw::c_char,\n                    arg4: ::std::os::raw::c_int,\n                    arg5: ::std::os::raw::c_int,\n                    arg6: ::std::os::raw::c_int,\n                ) -\u003e ::std::os::raw::c_int,\n            \u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xPhraseCount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(arg1: *mut Fts5Context) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xPhraseSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xInstCount: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pnInst: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xInst: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iIdx: ::std::os::raw::c_int,\n            piPhrase: *mut ::std::os::raw::c_int,\n            piCol: *mut ::std::os::raw::c_int,\n            piOff: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xRowid:\n        ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut Fts5Context) -\u003e sqlite3_int64\u003e,\n    pub xColumnText: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iCol: ::std::os::raw::c_int,\n            pz: *mut *const ::std::os::raw::c_char,\n            pn: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xColumnSize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iCol: ::std::os::raw::c_int,\n            pnToken: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xQueryPhrase: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            pUserData: *mut ::std::os::raw::c_void,\n            arg2: ::std::option::Option\u003c\n                unsafe extern \"C\" fn(\n                    arg1: *const Fts5ExtensionApi,\n                    arg2: *mut Fts5Context,\n                    arg3: *mut ::std::os::raw::c_void,\n                ) -\u003e ::std::os::raw::c_int,\n            \u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xSetAuxdata: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            pAux: *mut ::std::os::raw::c_void,\n            xDelete: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xGetAuxdata: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            bClear: ::std::os::raw::c_int,\n        ) -\u003e *mut ::std::os::raw::c_void,\n    \u003e,\n    pub xPhraseFirst: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            arg2: *mut Fts5PhraseIter,\n            arg3: *mut ::std::os::raw::c_int,\n            arg4: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xPhraseNext: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            arg2: *mut Fts5PhraseIter,\n            piCol: *mut ::std::os::raw::c_int,\n            piOff: *mut ::std::os::raw::c_int,\n        ),\n    \u003e,\n    pub xPhraseFirstColumn: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            iPhrase: ::std::os::raw::c_int,\n            arg2: *mut Fts5PhraseIter,\n            arg3: *mut ::std::os::raw::c_int,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xPhraseNextColumn: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Context,\n            arg2: *mut Fts5PhraseIter,\n            piCol: *mut ::std::os::raw::c_int,\n        ),\n    \u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Fts5Tokenizer {\n    _unused: [u8; 0],\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct fts5_tokenizer {\n    pub xCreate: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut ::std::os::raw::c_void,\n            azArg: *mut *const ::std::os::raw::c_char,\n            nArg: ::std::os::raw::c_int,\n            ppOut: *mut *mut Fts5Tokenizer,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xDelete: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut Fts5Tokenizer)\u003e,\n    pub xTokenize: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            arg1: *mut Fts5Tokenizer,\n            pCtx: *mut ::std::os::raw::c_void,\n            flags: ::std::os::raw::c_int,\n            pText: *const ::std::os::raw::c_char,\n            nText: ::std::os::raw::c_int,\n            xToken: ::std::option::Option\u003c\n                unsafe extern \"C\" fn(\n                    pCtx: *mut ::std::os::raw::c_void,\n                    tflags: ::std::os::raw::c_int,\n                    pToken: *const ::std::os::raw::c_char,\n                    nToken: ::std::os::raw::c_int,\n                    iStart: ::std::os::raw::c_int,\n                    iEnd: ::std::os::raw::c_int,\n                ) -\u003e ::std::os::raw::c_int,\n            \u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct fts5_api {\n    pub iVersion: ::std::os::raw::c_int,\n    pub xCreateTokenizer: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pApi: *mut fts5_api,\n            zName: *const ::std::os::raw::c_char,\n            pUserData: *mut ::std::os::raw::c_void,\n            pTokenizer: *mut fts5_tokenizer,\n            xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xFindTokenizer: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pApi: *mut fts5_api,\n            zName: *const ::std::os::raw::c_char,\n            ppUserData: *mut *mut ::std::os::raw::c_void,\n            pTokenizer: *mut fts5_tokenizer,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n    pub xCreateFunction: ::std::option::Option\u003c\n        unsafe extern \"C\" fn(\n            pApi: *mut fts5_api,\n            zName: *const ::std::os::raw::c_char,\n            pUserData: *mut ::std::os::raw::c_void,\n            xFunction: fts5_extension_function,\n            xDestroy: ::std::option::Option\u003cunsafe extern \"C\" fn(arg1: *mut ::std::os::raw::c_void)\u003e,\n        ) -\u003e ::std::os::raw::c_int,\n    \u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","target","debug","build","serde-1d23b1b528bc7c0e","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\nuse serde_core::__private228 as serde_core_private;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","target","debug","build","serde_core-61d3b947ad305302","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private228 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","target","debug","build","thiserror-b7b13111b4c58511","out","private.rs"],"content":"#[doc(hidden)]\npub mod __private17 {\n    #[doc(hidden)]\n    pub use crate::private::*;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","target","debug","build","typenum-f643354aeae9adba","out","tests.rs"],"content":"\nuse typenum::*;\nuse core::ops::*;\nuse core::cmp::Ordering;\n\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Sub_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0SubU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_0() {\n    type A = UTerm;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_PartialDiv_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU3 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU4 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU5 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU2 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU2 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U24 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU24\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU3 as Unsigned\u003e::to_u64(), \u003cU24 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU3 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U27 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU27\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU3 as Unsigned\u003e::to_u64(), \u003cU27 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U48 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU48\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU4 as Unsigned\u003e::to_u64(), \u003cU48 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU4 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U81 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU81\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU4 as Unsigned\u003e::to_u64(), \u003cU81 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U96 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU96\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU5 as Unsigned\u003e::to_u64(), \u003cU96 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU5 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU5 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U243 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU243\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU5 as Unsigned\u003e::to_u64(), \u003cU243 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU1 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU3 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU3 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU3 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU4 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U256 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU256\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU4 as Unsigned\u003e::to_u64(), \u003cU256 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U128 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU128\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU5 as Unsigned\u003e::to_u64(), \u003cU128 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU5 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU5 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1024 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU5 as Unsigned\u003e::to_u64(), \u003cU1024 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU1 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU2 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU2 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU2 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U40 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU40\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU3 as Unsigned\u003e::to_u64(), \u003cU40 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU3 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU3 as Unsigned\u003e::to_u64(), \u003cU125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U80 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU80\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU4 as Unsigned\u003e::to_u64(), \u003cU80 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU4 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU4 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U625 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU625\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU4 as Unsigned\u003e::to_u64(), \u003cU625 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U160 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU160\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU5 as Unsigned\u003e::to_u64(), \u003cU160 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU5 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU5 as Unsigned\u003e::to_u64(), \u003cU3125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Add_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Sub_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Min_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP3 as Integer\u003e::to_i64(), \u003cN125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP5 as Integer\u003e::to_i64(), \u003cN3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Add_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Sub_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Min_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N64 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN64\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP3 as Integer\u003e::to_i64(), \u003cN64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1024 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP5 as Integer\u003e::to_i64(), \u003cN1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Add_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Sub_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Min_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N27 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN27\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP3 as Integer\u003e::to_i64(), \u003cN27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N243 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN243\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP5 as Integer\u003e::to_i64(), \u003cN243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Add_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Sub_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Min_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N32 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN32\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP5 as Integer\u003e::to_i64(), \u003cN32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Add_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Sub_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Min_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Add_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Sub_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Gcd_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow__0() {\n    type A = Z0;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp__0() {\n    type A = Z0;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0Cmp_0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Add_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Sub_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Max_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Add_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Sub_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Max_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P32 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP32\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP5 as Integer\u003e::to_i64(), \u003cP32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Add_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Sub_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Max_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P27 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP27\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP3 as Integer\u003e::to_i64(), \u003cP27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P243 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP243\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP5 as Integer\u003e::to_i64(), \u003cP243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Add_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Sub_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Max_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P64 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP64\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP3 as Integer\u003e::to_i64(), \u003cP64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1024 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP5 as Integer\u003e::to_i64(), \u003cP1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Add_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Sub_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Max_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP3 as Integer\u003e::to_i64(), \u003cP125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP5 as Integer\u003e::to_i64(), \u003cP3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cNegN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cNegN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cNegN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cNegN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Neg() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cNegN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Abs() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Neg() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Neg_0 = \u003c\u003cA as Neg\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cNeg_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Abs() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Abs_0 = \u003c\u003cA as Abs\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cAbs_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Neg() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n    assert_eq!(\u003cNegP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Abs() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n    assert_eq!(\u003cNegP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n    assert_eq!(\u003cNegP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n    assert_eq!(\u003cNegP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n    assert_eq!(\u003cNegP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","tests","common","mod.rs"],"content":"use governance_app::database::Database;\nuse governance_app::crypto::{SignatureManager, MultisigManager};\nuse secp256k1::{SecretKey, Secp256k1, PublicKey};\nuse rand::rngs::OsRng;\nuse std::collections::HashMap;\nuse chrono::{DateTime, Utc, Duration};\n\n/// Setup an in-memory SQLite database for testing\npub async fn setup_test_db() -\u003e Database {\n    Database::new_in_memory().await.expect(\"Failed to create test database\")\n}\n\n/// Create a test signature manager\npub fn create_test_signature_manager() -\u003e SignatureManager {\n    SignatureManager::new()\n}\n\n/// Create a test multisig manager\npub fn create_test_multisig_manager() -\u003e MultisigManager {\n    MultisigManager::new()\n}\n\n/// Generate test keypairs for testing\npub fn generate_test_keypairs(count: usize) -\u003e Vec\u003c(String, SecretKey, PublicKey)\u003e {\n    let secp = Secp256k1::new();\n    let mut keypairs = Vec::new();\n    \n    for i in 0..count {\n        let secret_key = SecretKey::new(\u0026mut OsRng);\n        let public_key = PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n        let username = format!(\"testuser{}\", i);\n        \n        keypairs.push((username, secret_key, public_key));\n    }\n    \n    keypairs\n}\n\n/// Create test maintainers data\npub fn create_test_maintainers() -\u003e Vec\u003c(String, String, i32)\u003e {\n    vec![\n        (\"alice\".to_string(), \"pubkey_alice\".to_string(), 1),\n        (\"bob\".to_string(), \"pubkey_bob\".to_string(), 1),\n        (\"charlie\".to_string(), \"pubkey_charlie\".to_string(), 2),\n        (\"dave\".to_string(), \"pubkey_dave\".to_string(), 2),\n        (\"eve\".to_string(), \"pubkey_eve\".to_string(), 3),\n    ]\n}\n\n/// Create test emergency keyholders\npub fn create_test_emergency_keyholders() -\u003e Vec\u003c(String, String)\u003e {\n    vec![\n        (\"emergency_alice\".to_string(), \"emergency_pubkey_alice\".to_string()),\n        (\"emergency_bob\".to_string(), \"emergency_pubkey_bob\".to_string()),\n        (\"emergency_charlie\".to_string(), \"emergency_pubkey_charlie\".to_string()),\n        (\"emergency_dave\".to_string(), \"emergency_pubkey_dave\".to_string()),\n        (\"emergency_eve\".to_string(), \"emergency_pubkey_eve\".to_string()),\n        (\"emergency_frank\".to_string(), \"emergency_pubkey_frank\".to_string()),\n        (\"emergency_grace\".to_string(), \"emergency_pubkey_grace\".to_string()),\n    ]\n}\n\n/// Create test pull request data\npub fn create_test_pull_request(\n    repo_name: \u0026str,\n    pr_number: i32,\n    layer: i32,\n    opened_days_ago: i64,\n) -\u003e (String, i32, String, i32, DateTime\u003cUtc\u003e) {\n    let opened_at = Utc::now() - Duration::days(opened_days_ago);\n    let head_sha = format!(\"abc123def456{}\", pr_number);\n    \n    (repo_name.to_string(), pr_number, head_sha, layer, opened_at)\n}\n\n/// Create test cross-layer rules\npub fn create_test_cross_layer_rules() -\u003e Vec\u003cserde_json::Value\u003e {\n    vec![\n        serde_json::json!({\n            \"source_repo\": \"BTCDecoded/consensus-proof\",\n            \"source_pattern\": \"src/consensus/**\",\n            \"target_repo\": \"BTCDecoded/protocol-engine\",\n            \"target_pattern\": \"src/validation/**\",\n            \"validation_type\": \"corresponding_file_exists\"\n        }),\n        serde_json::json!({\n            \"source_repo\": \"BTCDecoded/protocol-engine\",\n            \"source_pattern\": \"src/network/**\",\n            \"target_repo\": \"BTCDecoded/reference-node\",\n            \"target_pattern\": \"src/network/**\",\n            \"validation_type\": \"references_latest_version\"\n        }),\n    ]\n}\n\n/// Create test signatures for a pull request\npub fn create_test_signatures(signers: \u0026[String]) -\u003e Vec\u003cserde_json::Value\u003e {\n    signers.iter().map(|signer| {\n        serde_json::json!({\n            \"signer\": signer,\n            \"signature\": format!(\"signature_{}\", signer),\n            \"timestamp\": Utc::now()\n        })\n    }).collect()\n}\n\n/// Mock GitHub webhook payloads\npub mod github_mocks {\n    use serde_json::Value;\n    \n    pub fn pull_request_opened_payload(repo: \u0026str, pr_number: u64) -\u003e Value {\n        serde_json::json!({\n            \"action\": \"opened\",\n            \"repository\": {\n                \"full_name\": repo\n            },\n            \"pull_request\": {\n                \"number\": pr_number,\n                \"head\": {\n                    \"sha\": \"abc123def456\"\n                }\n            }\n        })\n    }\n    \n    pub fn pull_request_synchronize_payload(repo: \u0026str, pr_number: u64) -\u003e Value {\n        serde_json::json!({\n            \"action\": \"synchronize\",\n            \"repository\": {\n                \"full_name\": repo\n            },\n            \"pull_request\": {\n                \"number\": pr_number,\n                \"head\": {\n                    \"sha\": \"def456ghi789\"\n                }\n            }\n        })\n    }\n    \n    pub fn review_submitted_payload(repo: \u0026str, pr_number: u64, reviewer: \u0026str, state: \u0026str) -\u003e Value {\n        serde_json::json!({\n            \"action\": \"submitted\",\n            \"repository\": {\n                \"full_name\": repo\n            },\n            \"pull_request\": {\n                \"number\": pr_number\n            },\n            \"review\": {\n                \"user\": {\n                    \"login\": reviewer\n                },\n                \"state\": state\n            }\n        })\n    }\n    \n    pub fn comment_created_payload(repo: \u0026str, pr_number: u64, commenter: \u0026str, body: \u0026str) -\u003e Value {\n        serde_json::json!({\n            \"action\": \"created\",\n            \"repository\": {\n                \"full_name\": repo\n            },\n            \"issue\": {\n                \"number\": pr_number\n            },\n            \"comment\": {\n                \"user\": {\n                    \"login\": commenter\n                },\n                \"body\": body\n            }\n        })\n    }\n    \n    pub fn push_payload(repo: \u0026str, pusher: \u0026str, ref_name: \u0026str) -\u003e Value {\n        serde_json::json!({\n            \"repository\": {\n                \"full_name\": repo\n            },\n            \"pusher\": {\n                \"name\": pusher\n            },\n            \"ref\": ref_name\n        })\n    }\n}\n\n/// Test data fixtures\npub mod fixtures {\n    use super::*;\n    \n    pub async fn setup_test_database_with_data() -\u003e Database {\n        let db = setup_test_db().await;\n        \n        // Insert test maintainers\n        let maintainers = create_test_maintainers();\n        for (username, public_key, layer) in maintainers {\n            // This would use actual database insertion in a real implementation\n            // For now, we'll just return the database\n        }\n        \n        // Insert test emergency keyholders\n        let keyholders = create_test_emergency_keyholders();\n        for (username, public_key) in keyholders {\n            // This would use actual database insertion in a real implementation\n        }\n        \n        db\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","tests","integration","e2e_tests.rs"],"content":"use governance_app::database::Database;\nuse governance_app::validation::*;\nuse governance_app::enforcement::*;\nuse governance_app::crypto::*;\nuse chrono::{DateTime, Utc, Duration};\nuse secp256k1::{SecretKey, Secp256k1, PublicKey};\nuse rand::rngs::OsRng;\nuse std::collections::HashMap;\n\nmod common;\nuse common::*;\n\n#[tokio::test]\nasync fn test_complete_pr_lifecycle() {\n    let db = setup_test_db().await;\n    let signature_manager = create_test_signature_manager();\n    let multisig_manager = create_test_multisig_manager();\n    \n    // Step 1: Create a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 123;\n    let head_sha = \"abc123def456\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Step 2: Add signatures from maintainers\n    let keypairs = generate_test_keypairs(3);\n    let mut public_keys = HashMap::new();\n    \n    for (username, secret_key, public_key) in \u0026keypairs {\n        public_keys.insert(username.clone(), public_key.to_string());\n        \n        let message = format!(\"governance-signature:{}\", username);\n        let signature = signature_manager.create_signature(\u0026message, secret_key).unwrap();\n        \n        db.add_signature(repo_name, pr_number, username, \u0026signature.to_string()).await.unwrap();\n    }\n    \n    // Step 3: Verify signatures meet threshold\n    let pr = db.get_pull_request(repo_name, pr_number).await.unwrap().unwrap();\n    let signatures: Vec\u003c(String, String)\u003e = pr.signatures.iter().map(|s| (s.signer.clone(), s.signature.clone())).collect();\n    \n    let (required, total) = ThresholdValidator::get_threshold_for_layer(layer);\n    let result = multisig_manager.verify_multisig(\n        \"governance-signature:test\",\n        \u0026signatures,\n        \u0026public_keys,\n        (required, total),\n    );\n    \n    assert!(result.is_ok());\n    \n    // Step 4: Check review period\n    let review_period_days = ThresholdValidator::get_review_period_for_layer(layer, false);\n    let opened_at = pr.opened_at;\n    let review_period_met = ReviewPeriodValidator::validate_review_period(opened_at, review_period_days, false).is_ok();\n    \n    // Step 5: Check if merge should be blocked\n    let signatures_met = result.unwrap();\n    let should_block = MergeBlocker::should_block_merge(review_period_met, signatures_met, false).unwrap();\n    \n    // For a new PR, it should be blocked due to review period\n    assert!(should_block);\n}\n\n#[tokio::test]\nasync fn test_emergency_mode_activation() {\n    let db = setup_test_db().await;\n    \n    // Step 1: Create a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 456;\n    let head_sha = \"def456ghi789\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Step 2: Activate emergency mode\n    let emergency_details = serde_json::json!({\n        \"activated_by\": \"emergency_alice\",\n        \"reason\": \"Critical security vulnerability\",\n        \"evidence\": \"Detailed evidence of the critical security vulnerability that requires immediate attention\",\n        \"timestamp\": Utc::now()\n    });\n    \n    db.log_governance_event(\n        \"emergency_mode_activated\",\n        Some(repo_name),\n        Some(pr_number),\n        Some(\"emergency_alice\"),\n        \u0026emergency_details,\n    ).await.unwrap();\n    \n    // Step 3: Add emergency signatures\n    let emergency_keypairs = generate_test_keypairs(5);\n    let mut emergency_public_keys = HashMap::new();\n    \n    for (username, secret_key, public_key) in \u0026emergency_keypairs {\n        emergency_public_keys.insert(username.clone(), public_key.to_string());\n        \n        let message = format!(\"emergency-signature:{}\", username);\n        let signature = create_test_signature_manager().create_signature(\u0026message, secret_key).unwrap();\n        \n        db.add_signature(repo_name, pr_number, username, \u0026signature.to_string()).await.unwrap();\n    }\n    \n    // Step 4: Verify emergency mode requirements\n    let pr = db.get_pull_request(repo_name, pr_number).await.unwrap().unwrap();\n    let signatures: Vec\u003c(String, String)\u003e = pr.signatures.iter().map(|s| (s.signer.clone(), s.signature.clone())).collect();\n    \n    // In emergency mode, only signatures matter (review period is reduced to 30 days)\n    let review_period_days = ThresholdValidator::get_review_period_for_layer(layer, true);\n    assert_eq!(review_period_days, 30);\n    \n    // Emergency mode should allow faster processing\n    let review_period_met = ReviewPeriodValidator::validate_review_period(pr.opened_at, review_period_days, true).is_ok();\n    let signatures_met = signatures.len() \u003e= 4; // Emergency threshold\n    \n    let should_block = MergeBlocker::should_block_merge(review_period_met, signatures_met, true).unwrap();\n    \n    // Should not be blocked in emergency mode if signatures are met\n    assert!(!should_block);\n}\n\n#[tokio::test]\nasync fn test_cross_layer_synchronization() {\n    let db = setup_test_db().await;\n    \n    // Step 1: Create PRs in different layers\n    let consensus_pr = (123, \"BTCDecoded/consensus-proof\", 2);\n    let protocol_pr = (456, \"BTCDecoded/protocol-engine\", 3);\n    \n    db.create_pull_request(consensus_pr.1, consensus_pr.0, \"sha1\", consensus_pr.2).await.unwrap();\n    db.create_pull_request(protocol_pr.1, protocol_pr.0, \"sha2\", protocol_pr.2).await.unwrap();\n    \n    // Step 2: Add cross-layer rules\n    let cross_layer_rules = create_test_cross_layer_rules();\n    \n    // Step 3: Validate cross-layer dependencies\n    let changed_files = vec![\"src/consensus/block.rs\".to_string()];\n    let result = CrossLayerValidator::validate_cross_layer_dependencies(\n        consensus_pr.1,\n        \u0026changed_files,\n        \u0026cross_layer_rules,\n    );\n    \n    assert!(result.is_ok());\n    \n    // Step 4: Log cross-layer synchronization\n    let sync_details = serde_json::json!({\n        \"source_repo\": consensus_pr.1,\n        \"target_repo\": protocol_pr.1,\n        \"validation_type\": \"corresponding_file_exists\",\n        \"timestamp\": Utc::now()\n    });\n    \n    db.log_governance_event(\n        \"cross_layer_sync\",\n        Some(consensus_pr.1),\n        Some(consensus_pr.0),\n        None,\n        \u0026sync_details,\n    ).await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_signature_threshold_validation_across_layers() {\n    let db = setup_test_db().await;\n    \n    // Test all layers\n    for layer in 1..=5 {\n        let repo_name = format!(\"BTCDecoded/test-repo-{}\", layer);\n        let pr_number = layer as i32 * 100;\n        let head_sha = format!(\"sha{}\", layer);\n        \n        db.create_pull_request(\u0026repo_name, pr_number, \u0026head_sha, layer).await.unwrap();\n        \n        // Get threshold for this layer\n        let (required, total) = ThresholdValidator::get_threshold_for_layer(layer);\n        \n        // Add exactly the required number of signatures\n        let keypairs = generate_test_keypairs(required);\n        let mut public_keys = HashMap::new();\n        \n        for (username, secret_key, public_key) in \u0026keypairs {\n            public_keys.insert(username.clone(), public_key.to_string());\n            \n            let message = format!(\"governance-signature:{}\", username);\n            let signature = create_test_signature_manager().create_signature(\u0026message, secret_key).unwrap();\n            \n            db.add_signature(\u0026repo_name, pr_number, username, \u0026signature.to_string()).await.unwrap();\n        }\n        \n        // Verify threshold is met\n        let pr = db.get_pull_request(\u0026repo_name, pr_number).await.unwrap().unwrap();\n        let signatures: Vec\u003c(String, String)\u003e = pr.signatures.iter().map(|s| (s.signer.clone(), s.signature.clone())).collect();\n        \n        let result = create_test_multisig_manager().verify_multisig(\n            \"governance-signature:test\",\n            \u0026signatures,\n            \u0026public_keys,\n            (required, total),\n        );\n        \n        assert!(result.is_ok());\n        assert!(result.unwrap());\n    }\n}\n\n#[tokio::test]\nasync fn test_review_period_with_emergency_tier_override() {\n    let db = setup_test_db().await;\n    \n    // Step 1: Create a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 789;\n    let head_sha = \"ghi789jkl012\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Step 2: Test normal review period\n    let normal_period = ThresholdValidator::get_review_period_for_layer(layer, false);\n    assert_eq!(normal_period, 90); // Layer 2 normal period\n    \n    // Step 3: Test emergency review period\n    let emergency_period = ThresholdValidator::get_review_period_for_layer(layer, true);\n    assert_eq!(emergency_period, 30); // Emergency mode period\n    \n    // Step 4: Test with different emergency tiers\n    use governance_app::validation::emergency::*;\n    \n    // Critical tier (0 days review)\n    assert_eq!(EmergencyTier::Critical.review_period_days(), 0);\n    \n    // Urgent tier (7 days review)\n    assert_eq!(EmergencyTier::Urgent.review_period_days(), 7);\n    \n    // Elevated tier (30 days review)\n    assert_eq!(EmergencyTier::Elevated.review_period_days(), 30);\n    \n    // Step 5: Test review period validation with emergency override\n    let pr = db.get_pull_request(repo_name, pr_number).await.unwrap().unwrap();\n    let opened_at = pr.opened_at;\n    \n    // Normal mode - should fail for new PR\n    let normal_result = ReviewPeriodValidator::validate_review_period(opened_at, normal_period, false);\n    assert!(normal_result.is_err());\n    \n    // Emergency mode - should pass for new PR (30 days)\n    let emergency_result = ReviewPeriodValidator::validate_review_period(opened_at, emergency_period, true);\n    assert!(emergency_result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_multi_pr_tracking_across_repos() {\n    let db = setup_test_db().await;\n    \n    // Create PRs in multiple repositories\n    let repos = vec![\n        (\"BTCDecoded/consensus-proof\", 2),\n        (\"BTCDecoded/protocol-engine\", 3),\n        (\"BTCDecoded/reference-node\", 4),\n        (\"BTCDecoded/developer-sdk\", 5),\n    ];\n    \n    for (repo_name, layer) in \u0026repos {\n        let pr_number = 100 + layer;\n        let head_sha = format!(\"sha_{}\", layer);\n        \n        db.create_pull_request(repo_name, pr_number, \u0026head_sha, *layer).await.unwrap();\n        \n        // Add some signatures\n        let keypairs = generate_test_keypairs(2);\n        for (username, secret_key, _) in \u0026keypairs {\n            let message = format!(\"governance-signature:{}\", username);\n            let signature = create_test_signature_manager().create_signature(\u0026message, secret_key).unwrap();\n            \n            db.add_signature(repo_name, pr_number, username, \u0026signature.to_string()).await.unwrap();\n        }\n    }\n    \n    // Verify all PRs were created and have signatures\n    for (repo_name, layer) in \u0026repos {\n        let pr_number = 100 + layer;\n        let pr = db.get_pull_request(repo_name, pr_number).await.unwrap().unwrap();\n        \n        assert_eq!(pr.repo_name, *repo_name);\n        assert_eq!(pr.layer, *layer);\n        assert_eq!(pr.signatures.len(), 2);\n    }\n}\n\n#[tokio::test]\nasync fn test_concurrent_signature_additions() {\n    let db = setup_test_db().await;\n    \n    // Create a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 999;\n    let head_sha = \"concurrent_test_sha\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Add signatures concurrently\n    let keypairs = generate_test_keypairs(5);\n    let handles: Vec\u003c_\u003e = keypairs.iter().map(|(username, secret_key, _)| {\n        let db = \u0026db;\n        let repo_name = repo_name.to_string();\n        let pr_number = pr_number;\n        let username = username.clone();\n        \n        tokio::spawn(async move {\n            let message = format!(\"governance-signature:{}\", username);\n            let signature = create_test_signature_manager().create_signature(\u0026message, secret_key).unwrap();\n            \n            db.add_signature(\u0026repo_name, pr_number, \u0026username, \u0026signature.to_string()).await\n        })\n    }).collect();\n    \n    // Wait for all signatures to be added\n    for handle in handles {\n        let result = handle.await.unwrap();\n        assert!(result.is_ok());\n    }\n    \n    // Verify all signatures were added\n    let pr = db.get_pull_request(repo_name, pr_number).await.unwrap().unwrap();\n    assert_eq!(pr.signatures.len(), 5);\n}\n\n#[tokio::test]\nasync fn test_event_log_consistency() {\n    let db = setup_test_db().await;\n    \n    // Create a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 888;\n    let head_sha = \"event_log_sha\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Log various events\n    let events = vec![\n        (\"pr_created\", None, None, None),\n        (\"signature_added\", Some(\"alice\"), Some(pr_number), Some(\"alice\")),\n        (\"review_submitted\", Some(\"bob\"), Some(pr_number), Some(\"bob\")),\n        (\"status_updated\", Some(\"system\"), Some(pr_number), None),\n    ];\n    \n    for (event_type, repo, pr, maintainer) in events {\n        let details = serde_json::json!({\n            \"timestamp\": Utc::now(),\n            \"event_type\": event_type\n        });\n        \n        db.log_governance_event(\n            event_type,\n            repo.as_deref(),\n            pr,\n            maintainer.as_deref(),\n            \u0026details,\n        ).await.unwrap();\n    }\n    \n    // Verify all events were logged\n    let logged_events = db.get_governance_events(10).await.unwrap();\n    assert_eq!(logged_events.len(), 4);\n    \n    // Verify event types\n    let event_types: Vec\u003cString\u003e = logged_events.iter().map(|e| e.event_type.clone()).collect();\n    assert!(event_types.contains(\u0026\"pr_created\".to_string()));\n    assert!(event_types.contains(\u0026\"signature_added\".to_string()));\n    assert!(event_types.contains(\u0026\"review_submitted\".to_string()));\n    assert!(event_types.contains(\u0026\"status_updated\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_migration_rollback_scenarios() {\n    // Test that migrations can be rolled back and reapplied\n    let db = setup_test_db().await;\n    \n    // Verify database was created successfully\n    assert!(db.pool.is_closed() == false);\n    \n    // Test that we can create and query data\n    let repo_name = \"BTCDecoded/test-migration\";\n    let pr_number = 777;\n    let head_sha = \"migration_test_sha\";\n    let layer = 1;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    let pr = db.get_pull_request(repo_name, pr_number).await.unwrap().unwrap();\n    assert_eq!(pr.repo_name, repo_name);\n    assert_eq!(pr.pr_number, pr_number);\n    assert_eq!(pr.layer, layer);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","tests","integration","webhook_tests.rs"],"content":"use governance_app::webhooks::github;\nuse governance_app::database::Database;\nuse serde_json::Value;\nuse axum::http::StatusCode;\n\nmod common;\nuse common::*;\n\n#[tokio::test]\nasync fn test_pull_request_opened_webhook() {\n    let db = setup_test_db().await;\n    let payload = github_mocks::pull_request_opened_payload(\"BTCDecoded/consensus-proof\", 123);\n    \n    // Test webhook processing\n    let result = governance_app::webhooks::pull_request::handle_pull_request_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n    \n    // Verify PR was stored in database\n    let pr = db.get_pull_request(\"BTCDecoded/consensus-proof\", 123).await;\n    assert!(pr.is_ok());\n    if let Ok(Some(pull_request)) = pr {\n        assert_eq!(pull_request.repo_name, \"BTCDecoded/consensus-proof\");\n        assert_eq!(pull_request.pr_number, 123);\n        assert_eq!(pull_request.layer, 2); // consensus-proof is layer 2\n    }\n}\n\n#[tokio::test]\nasync fn test_pull_request_synchronize_webhook() {\n    let db = setup_test_db().await;\n    let payload = github_mocks::pull_request_synchronize_payload(\"BTCDecoded/protocol-engine\", 456);\n    \n    // Test webhook processing\n    let result = governance_app::webhooks::pull_request::handle_pull_request_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n    \n    // Verify PR was updated in database\n    let pr = db.get_pull_request(\"BTCDecoded/protocol-engine\", 456).await;\n    assert!(pr.is_ok());\n    if let Ok(Some(pull_request)) = pr {\n        assert_eq!(pull_request.repo_name, \"BTCDecoded/protocol-engine\");\n        assert_eq!(pull_request.pr_number, 456);\n        assert_eq!(pull_request.layer, 3); // protocol-engine is layer 3\n    }\n}\n\n#[tokio::test]\nasync fn test_review_submitted_webhook() {\n    let db = setup_test_db().await;\n    let payload = github_mocks::review_submitted_payload(\"BTCDecoded/reference-node\", 789, \"alice\", \"approved\");\n    \n    // Test webhook processing\n    let result = governance_app::webhooks::review::handle_review_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_review_dismissed_webhook() {\n    let db = setup_test_db().await;\n    let payload = github_mocks::review_submitted_payload(\"BTCDecoded/developer-sdk\", 101, \"bob\", \"dismissed\");\n    \n    // Test webhook processing\n    let result = governance_app::webhooks::review::handle_review_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_comment_governance_signature() {\n    let db = setup_test_db().await;\n    let signature_body = \"/governance-sign signature_abc123def456\";\n    let payload = github_mocks::comment_created_payload(\"BTCDecoded/consensus-proof\", 123, \"alice\", signature_body);\n    \n    // Test webhook processing\n    let result = governance_app::webhooks::comment::handle_comment_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n    \n    // Verify signature was added to database\n    let pr = db.get_pull_request(\"BTCDecoded/consensus-proof\", 123).await;\n    assert!(pr.is_ok());\n    if let Ok(Some(pull_request)) = pr {\n        assert!(!pull_request.signatures.is_empty());\n        assert_eq!(pull_request.signatures[0].signer, \"alice\");\n    }\n}\n\n#[tokio::test]\nasync fn test_comment_empty_signature() {\n    let db = setup_test_db().await;\n    let empty_signature_body = \"/governance-sign\";\n    let payload = github_mocks::comment_created_payload(\"BTCDecoded/consensus-proof\", 123, \"alice\", empty_signature_body);\n    \n    // Test webhook processing\n    let result = governance_app::webhooks::comment::handle_comment_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n    \n    // Verify no signature was added\n    let pr = db.get_pull_request(\"BTCDecoded/consensus-proof\", 123).await;\n    assert!(pr.is_ok());\n    if let Ok(Some(pull_request)) = pr {\n        assert!(pull_request.signatures.is_empty());\n    }\n}\n\n#[tokio::test]\nasync fn test_comment_non_governance() {\n    let db = setup_test_db().await;\n    let regular_comment = \"This looks good to me!\";\n    let payload = github_mocks::comment_created_payload(\"BTCDecoded/consensus-proof\", 123, \"alice\", regular_comment);\n    \n    // Test webhook processing\n    let result = governance_app::webhooks::comment::handle_comment_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n    \n    // Verify no signature was added\n    let pr = db.get_pull_request(\"BTCDecoded/consensus-proof\", 123).await;\n    assert!(pr.is_ok());\n    if let Ok(Some(pull_request)) = pr {\n        assert!(pull_request.signatures.is_empty());\n    }\n}\n\n#[tokio::test]\nasync fn test_push_to_main_detection() {\n    let db = setup_test_db().await;\n    let payload = github_mocks::push_payload(\"BTCDecoded/consensus-proof\", \"alice\", \"refs/heads/main\");\n    \n    // Test webhook processing\n    let result = governance_app::webhooks::push::handle_push_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n    \n    // Verify bypass attempt was logged\n    let events = db.get_governance_events(10).await;\n    assert!(events.is_ok());\n    if let Ok(events) = events {\n        assert!(!events.is_empty());\n        assert!(events.iter().any(|e| e.event_type == \"direct_push_detected\"));\n    }\n}\n\n#[tokio::test]\nasync fn test_push_to_feature_branch() {\n    let db = setup_test_db().await;\n    let payload = github_mocks::push_payload(\"BTCDecoded/consensus-proof\", \"alice\", \"refs/heads/feature/new-feature\");\n    \n    // Test webhook processing\n    let result = governance_app::webhooks::push::handle_push_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n    \n    // Verify no bypass attempt was logged\n    let events = db.get_governance_events(10).await;\n    assert!(events.is_ok());\n    if let Ok(events) = events {\n        assert!(events.is_empty() || !events.iter().any(|e| e.event_type == \"direct_push_detected\"));\n    }\n}\n\n#[tokio::test]\nasync fn test_webhook_hmac_verification() {\n    // Test HMAC signature verification\n    let webhook_secret = \"test_secret\";\n    let payload = r#\"{\"action\":\"opened\",\"repository\":{\"full_name\":\"BTCDecoded/consensus-proof\"}}\"#;\n    let signature = \"sha256=test_signature\";\n    \n    // This would test HMAC verification in a real implementation\n    // For now, we'll just test that the signature format is correct\n    assert!(signature.starts_with(\"sha256=\"));\n}\n\n#[tokio::test]\nasync fn test_webhook_invalid_payload() {\n    let db = setup_test_db().await;\n    let invalid_payload = serde_json::json!({\n        \"invalid\": \"payload\"\n    });\n    \n    // Test webhook processing with invalid payload\n    let result = governance_app::webhooks::pull_request::handle_pull_request_event(\u0026db, \u0026invalid_payload).await;\n    // Should handle gracefully\n    assert!(result.is_ok() || result.is_err());\n}\n\n#[tokio::test]\nasync fn test_webhook_malformed_json() {\n    let db = setup_test_db().await;\n    let malformed_payload = serde_json::json!({\n        \"action\": \"opened\",\n        \"repository\": {\n            \"full_name\": null  // Invalid null value\n        },\n        \"pull_request\": {\n            \"number\": \"not_a_number\"  // Invalid type\n        }\n    });\n    \n    // Test webhook processing with malformed payload\n    let result = governance_app::webhooks::pull_request::handle_pull_request_event(\u0026db, \u0026malformed_payload).await;\n    // Should handle gracefully\n    assert!(result.is_ok() || result.is_err());\n}\n\n#[tokio::test]\nasync fn test_webhook_unknown_repository() {\n    let db = setup_test_db().await;\n    let payload = github_mocks::pull_request_opened_payload(\"Unknown/Repository\", 123);\n    \n    // Test webhook processing with unknown repository\n    let result = governance_app::webhooks::pull_request::handle_pull_request_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n    \n    // Should return unknown_repo status\n    if let Ok(response) = result {\n        assert!(response.get(\"status\").is_some());\n    }\n}\n\n#[tokio::test]\nasync fn test_webhook_concurrent_processing() {\n    let db = setup_test_db().await;\n    \n    // Test concurrent webhook processing\n    let handles: Vec\u003c_\u003e = (0..10).map(|i| {\n        let db = \u0026db;\n        let payload = github_mocks::pull_request_opened_payload(\"BTCDecoded/consensus-proof\", i as u64);\n        \n        tokio::spawn(async move {\n            governance_app::webhooks::pull_request::handle_pull_request_event(db, \u0026payload).await\n        })\n    }).collect();\n    \n    // Wait for all webhooks to be processed\n    for handle in handles {\n        let result = handle.await.unwrap();\n        assert!(result.is_ok());\n    }\n}\n\n#[tokio::test]\nasync fn test_webhook_database_transaction_rollback() {\n    let db = setup_test_db().await;\n    \n    // Test that database transactions are properly handled\n    let payload = github_mocks::pull_request_opened_payload(\"BTCDecoded/consensus-proof\", 999);\n    \n    // Process webhook\n    let result = governance_app::webhooks::pull_request::handle_pull_request_event(\u0026db, \u0026payload).await;\n    assert!(result.is_ok());\n    \n    // Verify data consistency\n    let pr = db.get_pull_request(\"BTCDecoded/consensus-proof\", 999).await;\n    assert!(pr.is_ok());\n    if let Ok(Some(pull_request)) = pr {\n        assert_eq!(pull_request.repo_name, \"BTCDecoded/consensus-proof\");\n        assert_eq!(pull_request.pr_number, 999);\n    }\n}\n\n#[tokio::test]\nasync fn test_signature_verification_workflow() {\n    use secp256k1::{SecretKey, Secp256k1};\n    use rand::rngs::OsRng;\n    \n    let secp = Secp256k1::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    let public_key = secp256k1::PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n    \n    let message = \"governance-signature:testuser\";\n    let signature = secp.sign_ecdsa(\n        \u0026secp256k1::Message::from_slice(\u0026sha2::Sha256::digest(message.as_bytes())).unwrap(),\n        \u0026secret_key\n    );\n    \n    // Verify the signature\n    let is_valid = secp.verify_ecdsa(\n        \u0026secp256k1::Message::from_slice(\u0026sha2::Sha256::digest(message.as_bytes())).unwrap(),\n        \u0026signature,\n        \u0026public_key\n    );\n    \n    assert!(is_valid.is_ok());\n}\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","tests","unit","crypto_tests.rs"],"content":"use governance_app::crypto::*;\nuse secp256k1::{SecretKey, Secp256k1, PublicKey};\nuse rand::rngs::OsRng;\nuse std::collections::HashMap;\n\nmod common;\nuse common::*;\n\n#[tokio::test]\nasync fn test_signature_creation_and_verification() {\n    let secp = Secp256k1::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    let public_key = PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n    \n    let signature_manager = SignatureManager::new();\n    let message = \"test message\";\n    \n    // Create signature\n    let signature = signature_manager.create_signature(message, \u0026secret_key).unwrap();\n    \n    // Verify signature\n    let is_valid = signature_manager.verify_signature(message, \u0026signature, \u0026public_key).unwrap();\n    assert!(is_valid);\n    \n    // Test with wrong message\n    let wrong_message = \"wrong message\";\n    let is_valid = signature_manager.verify_signature(wrong_message, \u0026signature, \u0026public_key).unwrap();\n    assert!(!is_valid);\n}\n\n#[tokio::test]\nasync fn test_signature_edge_cases() {\n    let signature_manager = SignatureManager::new();\n    let secp = Secp256k1::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    let public_key = PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n    \n    // Test empty message\n    let empty_message = \"\";\n    let signature = signature_manager.create_signature(empty_message, \u0026secret_key).unwrap();\n    let is_valid = signature_manager.verify_signature(empty_message, \u0026signature, \u0026public_key).unwrap();\n    assert!(is_valid);\n    \n    // Test very long message\n    let long_message = \"a\".repeat(10000);\n    let signature = signature_manager.create_signature(\u0026long_message, \u0026secret_key).unwrap();\n    let is_valid = signature_manager.verify_signature(\u0026long_message, \u0026signature, \u0026public_key).unwrap();\n    assert!(is_valid);\n    \n    // Test message with special characters\n    let special_message = \"Hello, ‰∏ñÁïå! üåç\\n\\t\\r\\0\";\n    let signature = signature_manager.create_signature(special_message, \u0026secret_key).unwrap();\n    let is_valid = signature_manager.verify_signature(special_message, \u0026signature, \u0026public_key).unwrap();\n    assert!(is_valid);\n}\n\n#[tokio::test]\nasync fn test_signature_tampering() {\n    let signature_manager = SignatureManager::new();\n    let secp = Secp256k1::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    let public_key = PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n    \n    let message = \"original message\";\n    let signature = signature_manager.create_signature(message, \u0026secret_key).unwrap();\n    \n    // Test tampered message\n    let tampered_message = \"tampered message\";\n    let is_valid = signature_manager.verify_signature(tampered_message, \u0026signature, \u0026public_key).unwrap();\n    assert!(!is_valid);\n    \n    // Test tampered signature (modify one byte)\n    let mut tampered_signature = signature;\n    let signature_bytes = tampered_signature.serialize_der();\n    let mut modified_bytes = signature_bytes.to_vec();\n    if !modified_bytes.is_empty() {\n        modified_bytes[0] = modified_bytes[0].wrapping_add(1);\n    }\n    // This would create an invalid signature, but we can't easily create a valid but different signature\n    // So we'll test with a completely different signature\n    let different_secret = SecretKey::new(\u0026mut OsRng);\n    let different_signature = signature_manager.create_signature(\"different message\", \u0026different_secret).unwrap();\n    let is_valid = signature_manager.verify_signature(message, \u0026different_signature, \u0026public_key).unwrap();\n    assert!(!is_valid);\n}\n\n#[tokio::test]\nasync fn test_multisig_verification() {\n    let secp = Secp256k1::new();\n    let multisig_manager = MultisigManager::new();\n    \n    // Create test keypairs\n    let keypairs = generate_test_keypairs(3);\n    let mut public_keys = HashMap::new();\n    \n    for (username, _, public_key) in \u0026keypairs {\n        public_keys.insert(username.clone(), public_key.to_string());\n    }\n    \n    let message = \"multisig test message\";\n    \n    // Create signatures\n    let signature_manager = SignatureManager::new();\n    let signatures: Vec\u003c(String, String)\u003e = keypairs.iter().map(|(username, secret_key, _)| {\n        let signature = signature_manager.create_signature(message, secret_key).unwrap();\n        (username.clone(), signature.to_string())\n    }).collect();\n    \n    // Test multisig verification\n    let result = multisig_manager.verify_multisig(\n        message,\n        \u0026signatures,\n        \u0026public_keys,\n        (2, 3), // 2-of-3\n    );\n    \n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_multisig_threshold_boundaries() {\n    let secp = Secp256k1::new();\n    let multisig_manager = MultisigManager::new();\n    let signature_manager = SignatureManager::new();\n    \n    // Create 5 keypairs\n    let keypairs = generate_test_keypairs(5);\n    let mut public_keys = HashMap::new();\n    \n    for (username, _, public_key) in \u0026keypairs {\n        public_keys.insert(username.clone(), public_key.to_string());\n    }\n    \n    let message = \"threshold test message\";\n    \n    // Test exactly at threshold (3-of-5)\n    let signatures: Vec\u003c(String, String)\u003e = keypairs[0..3].iter().map(|(username, secret_key, _)| {\n        let signature = signature_manager.create_signature(message, secret_key).unwrap();\n        (username.clone(), signature.to_string())\n    }).collect();\n    \n    let result = multisig_manager.verify_multisig(\n        message,\n        \u0026signatures,\n        \u0026public_keys,\n        (3, 5),\n    );\n    assert!(result.is_ok());\n    \n    // Test one below threshold (2-of-5)\n    let insufficient_signatures = \u0026signatures[0..2];\n    let result = multisig_manager.verify_multisig(\n        message,\n        insufficient_signatures,\n        \u0026public_keys,\n        (3, 5),\n    );\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_multisig_duplicate_signers() {\n    let secp = Secp256k1::new();\n    let multisig_manager = MultisigManager::new();\n    let signature_manager = SignatureManager::new();\n    \n    let keypairs = generate_test_keypairs(2);\n    let mut public_keys = HashMap::new();\n    \n    for (username, _, public_key) in \u0026keypairs {\n        public_keys.insert(username.clone(), public_key.to_string());\n    }\n    \n    let message = \"duplicate signer test\";\n    let (username, secret_key, _) = \u0026keypairs[0];\n    let signature = signature_manager.create_signature(message, secret_key).unwrap();\n    \n    // Create duplicate signatures from the same signer\n    let signatures = vec![\n        (username.clone(), signature.to_string()),\n        (username.clone(), signature.to_string()),\n    ];\n    \n    // This should still work - duplicate signatures are allowed\n    let result = multisig_manager.verify_multisig(\n        message,\n        \u0026signatures,\n        \u0026public_keys,\n        (2, 2),\n    );\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_multisig_missing_keys() {\n    let secp = Secp256k1::new();\n    let multisig_manager = MultisigManager::new();\n    let signature_manager = SignatureManager::new();\n    \n    let keypairs = generate_test_keypairs(3);\n    let mut public_keys = HashMap::new();\n    \n    // Only add 2 of the 3 public keys\n    for (username, _, public_key) in \u0026keypairs[0..2] {\n        public_keys.insert(username.clone(), public_key.to_string());\n    }\n    \n    let message = \"missing key test\";\n    let signatures: Vec\u003c(String, String)\u003e = keypairs.iter().map(|(username, secret_key, _)| {\n        let signature = signature_manager.create_signature(message, secret_key).unwrap();\n        (username.clone(), signature.to_string())\n    }).collect();\n    \n    // This should fail because we don't have the public key for the third signer\n    let result = multisig_manager.verify_multisig(\n        message,\n        \u0026signatures,\n        \u0026public_keys,\n        (2, 3),\n    );\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_multisig_invalid_signatures() {\n    let secp = Secp256k1::new();\n    let multisig_manager = MultisigManager::new();\n    \n    let keypairs = generate_test_keypairs(2);\n    let mut public_keys = HashMap::new();\n    \n    for (username, _, public_key) in \u0026keypairs {\n        public_keys.insert(username.clone(), public_key.to_string());\n    }\n    \n    let message = \"invalid signature test\";\n    \n    // Create signatures with invalid data\n    let signatures = vec![\n        (\"testuser0\".to_string(), \"invalid_signature_1\".to_string()),\n        (\"testuser1\".to_string(), \"invalid_signature_2\".to_string()),\n    ];\n    \n    let result = multisig_manager.verify_multisig(\n        message,\n        \u0026signatures,\n        \u0026public_keys,\n        (2, 2),\n    );\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_multisig_verified_signers() {\n    let secp = Secp256k1::new();\n    let multisig_manager = MultisigManager::new();\n    let signature_manager = SignatureManager::new();\n    \n    let keypairs = generate_test_keypairs(3);\n    let mut public_keys = HashMap::new();\n    \n    for (username, _, public_key) in \u0026keypairs {\n        public_keys.insert(username.clone(), public_key.to_string());\n    }\n    \n    let message = \"verified signers test\";\n    let signatures: Vec\u003c(String, String)\u003e = keypairs.iter().map(|(username, secret_key, _)| {\n        let signature = signature_manager.create_signature(message, secret_key).unwrap();\n        (username.clone(), signature.to_string())\n    }).collect();\n    \n    let verified_signers = multisig_manager.get_verified_signers(\n        message,\n        \u0026signatures,\n        \u0026public_keys,\n    ).unwrap();\n    \n    assert_eq!(verified_signers.len(), 3);\n    assert!(verified_signers.contains(\u0026\"testuser0\".to_string()));\n    assert!(verified_signers.contains(\u0026\"testuser1\".to_string()));\n    assert!(verified_signers.contains(\u0026\"testuser2\".to_string()));\n}\n\n#[tokio::test]\nasync fn test_bitcoin_compatible_signatures() {\n    let signature_manager = SignatureManager::new();\n    let secp = Secp256k1::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    let public_key = PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n    \n    // Test Bitcoin-style message signing\n    let message = \"governance-signature:alice\";\n    let signature = signature_manager.create_signature(message, \u0026secret_key).unwrap();\n    \n    // Verify the signature\n    let is_valid = signature_manager.verify_signature(message, \u0026signature, \u0026public_key).unwrap();\n    assert!(is_valid);\n    \n    // Test that the signature is deterministic for the same input\n    let signature2 = signature_manager.create_signature(message, \u0026secret_key).unwrap();\n    assert_eq!(signature, signature2);\n}\n\n#[tokio::test]\nasync fn test_public_key_derivation() {\n    let signature_manager = SignatureManager::new();\n    let secp = Secp256k1::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    \n    let derived_public_key = signature_manager.public_key_from_secret(\u0026secret_key);\n    let expected_public_key = PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n    \n    assert_eq!(derived_public_key, expected_public_key);\n}\n\n#[tokio::test]\nasync fn test_signature_serialization() {\n    let signature_manager = SignatureManager::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    \n    let message = \"serialization test\";\n    let signature = signature_manager.create_signature(message, \u0026secret_key).unwrap();\n    \n    // Test that signature can be serialized and deserialized\n    let signature_string = signature.to_string();\n    let deserialized_signature = signature_string.parse::\u003csecp256k1::Signature\u003e().unwrap();\n    \n    assert_eq!(signature, deserialized_signature);\n}\n\n#[tokio::test]\nasync fn test_multisig_large_threshold() {\n    let secp = Secp256k1::new();\n    let multisig_manager = MultisigManager::new();\n    let signature_manager = SignatureManager::new();\n    \n    // Create 10 keypairs for a large multisig\n    let keypairs = generate_test_keypairs(10);\n    let mut public_keys = HashMap::new();\n    \n    for (username, _, public_key) in \u0026keypairs {\n        public_keys.insert(username.clone(), public_key.to_string());\n    }\n    \n    let message = \"large multisig test\";\n    let signatures: Vec\u003c(String, String)\u003e = keypairs.iter().map(|(username, secret_key, _)| {\n        let signature = signature_manager.create_signature(message, secret_key).unwrap();\n        (username.clone(), signature.to_string())\n    }).collect();\n    \n    // Test 7-of-10 threshold\n    let result = multisig_manager.verify_multisig(\n        message,\n        \u0026signatures,\n        \u0026public_keys,\n        (7, 10),\n    );\n    assert!(result.is_ok());\n    \n    // Test with only 6 signatures (should fail)\n    let insufficient_signatures = \u0026signatures[0..6];\n    let result = multisig_manager.verify_multisig(\n        message,\n        insufficient_signatures,\n        \u0026public_keys,\n        (7, 10),\n    );\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_crypto_error_handling() {\n    let signature_manager = SignatureManager::new();\n    \n    // Test with invalid secret key (this should not happen in practice, but test error handling)\n    // Note: SecretKey::new() always creates valid keys, so we'll test other error conditions\n    \n    // Test signature verification with malformed data\n    let secp = Secp256k1::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    let public_key = PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n    \n    // Test with invalid signature format\n    let result = signature_manager.verify_signature(\"message\", \"invalid\", \u0026public_key.to_string());\n    assert!(result.is_err());\n    \n    // Test with invalid public key format\n    let result = signature_manager.verify_signature(\"message\", \"signature\", \"invalid_key\");\n    assert!(result.is_err());\n}\n\n\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","tests","unit","database_tests.rs"],"content":"use governance_app::database::Database;\nuse governance_app::database::models::*;\nuse chrono::{DateTime, Utc, Duration};\nuse serde_json::json;\n\nmod common;\nuse common::*;\n\n#[tokio::test]\nasync fn test_database_creation_and_migration() {\n    let db = setup_test_db().await;\n    \n    // Test that database was created successfully\n    assert!(db.pool.is_closed() == false);\n}\n\n#[tokio::test]\nasync fn test_pull_request_crud() {\n    let db = setup_test_db().await;\n    \n    // Test creating a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 123;\n    let head_sha = \"abc123def456\";\n    let layer = 2;\n    \n    let result = db.create_pull_request(repo_name, pr_number, head_sha, layer).await;\n    assert!(result.is_ok());\n    \n    // Test retrieving the pull request\n    let pr = db.get_pull_request(repo_name, pr_number).await;\n    assert!(pr.is_ok());\n    \n    if let Ok(Some(pull_request)) = pr {\n        assert_eq!(pull_request.repo_name, repo_name);\n        assert_eq!(pull_request.pr_number, pr_number);\n        assert_eq!(pull_request.head_sha, head_sha);\n        assert_eq!(pull_request.layer, layer);\n        assert_eq!(pull_request.governance_status, \"pending\");\n    }\n}\n\n#[tokio::test]\nasync fn test_signature_storage_and_retrieval() {\n    let db = setup_test_db().await;\n    \n    // Create a pull request first\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 123;\n    let head_sha = \"abc123def456\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Add signatures\n    let signer1 = \"alice\";\n    let signature1 = \"signature_alice_123\";\n    let signer2 = \"bob\";\n    let signature2 = \"signature_bob_456\";\n    \n    db.add_signature(repo_name, pr_number, signer1, signature1).await.unwrap();\n    db.add_signature(repo_name, pr_number, signer2, signature2).await.unwrap();\n    \n    // Retrieve and verify signatures\n    let pr = db.get_pull_request(repo_name, pr_number).await.unwrap().unwrap();\n    assert_eq!(pr.signatures.len(), 2);\n    \n    let signers: Vec\u003cString\u003e = pr.signatures.iter().map(|s| s.signer.clone()).collect();\n    assert!(signers.contains(\u0026signer1.to_string()));\n    assert!(signers.contains(\u0026signer2.to_string()));\n}\n\n#[tokio::test]\nasync fn test_governance_event_logging() {\n    let db = setup_test_db().await;\n    \n    let event_type = \"signature_added\";\n    let repo_name = Some(\"BTCDecoded/consensus-proof\");\n    let pr_number = Some(123);\n    let maintainer = Some(\"alice\");\n    let details = json!({\n        \"signature\": \"signature_alice_123\",\n        \"timestamp\": Utc::now()\n    });\n    \n    let result = db.log_governance_event(\n        event_type,\n        repo_name.as_deref(),\n        pr_number,\n        maintainer.as_deref(),\n        \u0026details,\n    ).await;\n    \n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_concurrent_signature_additions() {\n    let db = setup_test_db().await;\n    \n    // Create a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 123;\n    let head_sha = \"abc123def456\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Add signatures concurrently\n    let handles: Vec\u003c_\u003e = (0..5).map(|i| {\n        let db = \u0026db;\n        let repo_name = repo_name.to_string();\n        let pr_number = pr_number;\n        let signer = format!(\"signer{}\", i);\n        let signature = format!(\"signature_{}\", i);\n        \n        tokio::spawn(async move {\n            db.add_signature(\u0026repo_name, pr_number, \u0026signer, \u0026signature).await\n        })\n    }).collect();\n    \n    // Wait for all signatures to be added\n    for handle in handles {\n        let result = handle.await.unwrap();\n        assert!(result.is_ok());\n    }\n    \n    // Verify all signatures were added\n    let pr = db.get_pull_request(repo_name, pr_number).await.unwrap().unwrap();\n    assert_eq!(pr.signatures.len(), 5);\n}\n\n#[tokio::test]\nasync fn test_review_status_updates() {\n    let db = setup_test_db().await;\n    \n    // Create a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 123;\n    let head_sha = \"abc123def456\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Update review status\n    let reviewer = \"alice\";\n    let state = \"approved\";\n    \n    let result = db.update_review_status(repo_name, pr_number, reviewer, state).await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_emergency_mode_tracking() {\n    let db = setup_test_db().await;\n    \n    // Create a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 123;\n    let head_sha = \"abc123def456\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Test emergency mode activation\n    let emergency_details = json!({\n        \"activated_by\": \"emergency_alice\",\n        \"reason\": \"Critical security vulnerability\",\n        \"timestamp\": Utc::now()\n    });\n    \n    let result = db.log_governance_event(\n        \"emergency_mode_activated\",\n        Some(repo_name),\n        Some(pr_number),\n        Some(\"emergency_alice\"),\n        \u0026emergency_details,\n    ).await;\n    \n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_cross_layer_dependencies() {\n    let db = setup_test_db().await;\n    \n    // Test cross-layer rule storage and retrieval\n    let rule_data = json!({\n        \"source_repo\": \"BTCDecoded/consensus-proof\",\n        \"source_pattern\": \"src/consensus/**\",\n        \"target_repo\": \"BTCDecoded/protocol-engine\",\n        \"target_pattern\": \"src/validation/**\",\n        \"validation_type\": \"corresponding_file_exists\"\n    });\n    \n    let result = db.log_governance_event(\n        \"cross_layer_rule_created\",\n        None,\n        None,\n        None,\n        \u0026rule_data,\n    ).await;\n    \n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_migration_execution() {\n    // Test that migrations run successfully\n    let db = setup_test_db().await;\n    \n    // If we get here without error, migrations executed successfully\n    assert!(db.pool.is_closed() == false);\n}\n\n#[tokio::test]\nasync fn test_json_serialization_for_signatures() {\n    let db = setup_test_db().await;\n    \n    // Create a pull request\n    let repo_name = \"BTCDecoded/consensus-proof\";\n    let pr_number = 123;\n    let head_sha = \"abc123def456\";\n    let layer = 2;\n    \n    db.create_pull_request(repo_name, pr_number, head_sha, layer).await.unwrap();\n    \n    // Add a signature with complex JSON data\n    let complex_signature = json!({\n        \"signer\": \"alice\",\n        \"signature\": \"signature_alice_123\",\n        \"timestamp\": Utc::now(),\n        \"metadata\": {\n            \"key_id\": \"key_123\",\n            \"algorithm\": \"secp256k1\",\n            \"version\": \"1.0\"\n        }\n    });\n    \n    let signature_str = serde_json::to_string(\u0026complex_signature).unwrap();\n    let result = db.add_signature(repo_name, pr_number, \"alice\", \u0026signature_str).await;\n    assert!(result.is_ok());\n    \n    // Verify the signature was stored correctly\n    let pr = db.get_pull_request(repo_name, pr_number).await.unwrap().unwrap();\n    assert_eq!(pr.signatures.len(), 1);\n    \n    let stored_signature = \u0026pr.signatures[0];\n    assert_eq!(stored_signature.signer, \"alice\");\n}\n\n#[tokio::test]\nasync fn test_database_connection_pooling() {\n    // Test that multiple operations can run concurrently\n    let db = setup_test_db().await;\n    \n    let handles: Vec\u003c_\u003e = (0..10).map(|i| {\n        let db = \u0026db;\n        let repo_name = format!(\"BTCDecoded/repo{}\", i);\n        let pr_number = i as i32;\n        let head_sha = format!(\"sha{}\", i);\n        let layer = (i % 5) + 1;\n        \n        tokio::spawn(async move {\n            db.create_pull_request(\u0026repo_name, pr_number, \u0026head_sha, layer).await\n        })\n    }).collect();\n    \n    // Wait for all operations to complete\n    for handle in handles {\n        let result = handle.await.unwrap();\n        assert!(result.is_ok());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","tests","unit","enforcement_tests.rs"],"content":"use governance_app::enforcement::*;\nuse governance_app::enforcement::status_checks::StatusCheckGenerator;\nuse governance_app::enforcement::merge_block::MergeBlocker;\nuse governance_app::validation::emergency::*;\nuse chrono::{DateTime, Utc, Duration};\n\nmod common;\nuse common::*;\n\n#[tokio::test]\nasync fn test_status_check_generation() {\n    let opened_at = Utc::now() - Duration::days(100);\n    let required_days = 90;\n    let emergency_mode = false;\n    \n    let status = StatusCheckGenerator::generate_review_period_status(\n        opened_at,\n        required_days,\n        emergency_mode,\n    );\n    \n    assert!(status.contains(\"‚úÖ Governance: Review Period Met\"));\n}\n\n#[tokio::test]\nasync fn test_status_check_insufficient_review_period() {\n    let opened_at = Utc::now() - Duration::days(10);\n    let required_days = 90;\n    let emergency_mode = false;\n    \n    let status = StatusCheckGenerator::generate_review_period_status(\n        opened_at,\n        required_days,\n        emergency_mode,\n    );\n    \n    assert!(status.contains(\"‚ùå Governance: Review Period Not Met\"));\n    assert!(status.contains(\"Required: 90 days\"));\n    assert!(status.contains(\"Elapsed: 10 days\"));\n}\n\n#[tokio::test]\nasync fn test_status_check_emergency_mode() {\n    let opened_at = Utc::now() - Duration::days(35);\n    let required_days = 90;\n    let emergency_mode = true;\n    \n    let status = StatusCheckGenerator::generate_review_period_status(\n        opened_at,\n        required_days,\n        emergency_mode,\n    );\n    \n    assert!(status.contains(\"‚úÖ Governance: Review Period Met\"));\n}\n\n#[tokio::test]\nasync fn test_signature_status_complete() {\n    let current_signatures = 5;\n    let required_signatures = 4;\n    let total_maintainers = 7;\n    let signers = vec![\"alice\".to_string(), \"bob\".to_string(), \"charlie\".to_string(), \"dave\".to_string(), \"eve\".to_string()];\n    let pending = vec![\"frank\".to_string(), \"grace\".to_string()];\n    \n    let status = StatusCheckGenerator::generate_signature_status(\n        current_signatures,\n        required_signatures,\n        total_maintainers,\n        \u0026signers,\n        \u0026pending,\n    );\n    \n    assert!(status.contains(\"‚úÖ Governance: Signatures Complete\"));\n}\n\n#[tokio::test]\nasync fn test_signature_status_incomplete() {\n    let current_signatures = 2;\n    let required_signatures = 4;\n    let total_maintainers = 7;\n    let signers = vec![\"alice\".to_string(), \"bob\".to_string()];\n    let pending = vec![\"charlie\".to_string(), \"dave\".to_string(), \"eve\".to_string(), \"frank\".to_string(), \"grace\".to_string()];\n    \n    let status = StatusCheckGenerator::generate_signature_status(\n        current_signatures,\n        required_signatures,\n        total_maintainers,\n        \u0026signers,\n        \u0026pending,\n    );\n    \n    assert!(status.contains(\"‚ùå Governance: Signatures Missing\"));\n    assert!(status.contains(\"Required: 4-of-7\"));\n    assert!(status.contains(\"Current: 2/7\"));\n    assert!(status.contains(\"alice, bob\"));\n    assert!(status.contains(\"charlie, dave, eve, frank, grace\"));\n}\n\n#[tokio::test]\nasync fn test_combined_status_all_met() {\n    let review_period_met = true;\n    let signatures_met = true;\n    let review_period_status = \"‚úÖ Governance: Review Period Met\";\n    let signature_status = \"‚úÖ Governance: Signatures Complete\";\n    \n    let status = StatusCheckGenerator::generate_combined_status(\n        review_period_met,\n        signatures_met,\n        review_period_status,\n        signature_status,\n    );\n    \n    assert!(status.contains(\"‚úÖ Governance: All Requirements Met - Ready to Merge\"));\n}\n\n#[tokio::test]\nasync fn test_combined_status_not_met() {\n    let review_period_met = false;\n    let signatures_met = false;\n    let review_period_status = \"‚ùå Governance: Review Period Not Met\";\n    let signature_status = \"‚ùå Governance: Signatures Missing\";\n    \n    let status = StatusCheckGenerator::generate_combined_status(\n        review_period_met,\n        signatures_met,\n        review_period_status,\n        signature_status,\n    );\n    \n    assert!(status.contains(\"‚ùå Governance: Requirements Not Met\"));\n    assert!(status.contains(\"Review Period Not Met\"));\n    assert!(status.contains(\"Signatures Missing\"));\n}\n\n#[tokio::test]\nasync fn test_emergency_status_generation() {\n    let emergency = ActiveEmergency {\n        id: 1,\n        tier: EmergencyTier::Critical,\n        activated_by: \"emergency_alice\".to_string(),\n        reason: \"Critical security vulnerability\".to_string(),\n        activated_at: Utc::now() - Duration::days(2),\n        expires_at: Utc::now() + Duration::days(5),\n        extended: false,\n        extension_count: 0,\n    };\n    \n    let status = StatusCheckGenerator::generate_emergency_status(\u0026emergency);\n    \n    assert!(status.contains(\"üö® Emergency Tier Active: Critical Emergency\"));\n    assert!(status.contains(\"4-of-7 signatures\"));\n    assert!(status.contains(\"0 day review period\"));\n    assert!(status.contains(\"Critical security vulnerability\"));\n    assert!(status.contains(\"emergency_alice\"));\n}\n\n#[tokio::test]\nasync fn test_emergency_expiration_warning() {\n    let emergency = ActiveEmergency {\n        id: 1,\n        tier: EmergencyTier::Urgent,\n        activated_by: \"emergency_alice\".to_string(),\n        reason: \"Urgent security issue\".to_string(),\n        activated_at: Utc::now() - Duration::days(20),\n        expires_at: Utc::now() + Duration::hours(12), // Less than 24 hours\n        extended: false,\n        extension_count: 0,\n    };\n    \n    let warning = StatusCheckGenerator::generate_emergency_expiration_warning(\u0026emergency);\n    \n    assert!(warning.contains(\"‚ö†Ô∏è ‚ö†Ô∏è Emergency Tier Expiring Soon\"));\n    assert!(warning.contains(\"Less than 24 hours remaining\"));\n}\n\n#[tokio::test]\nasync fn test_emergency_extension_info() {\n    let emergency = ActiveEmergency {\n        id: 1,\n        tier: EmergencyTier::Elevated,\n        activated_by: \"emergency_alice\".to_string(),\n        reason: \"Elevated priority issue\".to_string(),\n        activated_at: Utc::now() - Duration::days(10),\n        expires_at: Utc::now() + Duration::days(20),\n        extended: false,\n        extension_count: 0,\n    };\n    \n    let status = StatusCheckGenerator::generate_emergency_status(\u0026emergency);\n    \n    assert!(status.contains(\"üì¢ Emergency Tier Active: Elevated Priority\"));\n    assert!(status.contains(\"Extensions: 0 of 2 used\"));\n    assert!(status.contains(\"can extend by 30 days\"));\n}\n\n#[tokio::test]\nasync fn test_combined_status_with_emergency() {\n    let emergency = ActiveEmergency {\n        id: 1,\n        tier: EmergencyTier::Urgent,\n        activated_by: \"emergency_alice\".to_string(),\n        reason: \"Urgent security issue\".to_string(),\n        activated_at: Utc::now() - Duration::days(5),\n        expires_at: Utc::now() + Duration::days(25),\n        extended: false,\n        extension_count: 0,\n    };\n    \n    let status = StatusCheckGenerator::generate_combined_status_with_emergency(\n        true, // review_period_met\n        true, // signatures_met\n        \"‚úÖ Governance: Review Period Met\",\n        \"‚úÖ Governance: Signatures Complete\",\n        Some(\u0026emergency),\n    );\n    \n    assert!(status.contains(\"‚ö†Ô∏è Emergency Tier Active: Urgent Security Issue\"));\n    assert!(status.contains(\"‚úÖ Governance: All Requirements Met - Ready to Merge\"));\n}\n\n#[tokio::test]\nasync fn test_post_emergency_requirements() {\n    let tier = EmergencyTier::Critical;\n    let post_mortem_published = false;\n    let post_mortem_deadline = Utc::now() + Duration::days(25);\n    let security_audit_completed = false;\n    let security_audit_deadline = Some(Utc::now() + Duration::days(55));\n    \n    let status = StatusCheckGenerator::generate_post_emergency_requirements(\n        tier,\n        post_mortem_published,\n        post_mortem_deadline,\n        security_audit_completed,\n        security_audit_deadline,\n    );\n    \n    assert!(status.contains(\"üìã Post-Emergency Requirements for Critical Emergency\"));\n    assert!(status.contains(\"‚è≥ Post-mortem pending\"));\n    assert!(status.contains(\"‚è≥ Security audit pending\"));\n}\n\n#[tokio::test]\nasync fn test_merge_blocker_normal_mode() {\n    // Test normal mode - both requirements must be met\n    let result = MergeBlocker::should_block_merge(true, true, false);\n    assert!(result.is_ok());\n    assert!(!result.unwrap()); // Should not block\n    \n    let result = MergeBlocker::should_block_merge(false, true, false);\n    assert!(result.is_ok());\n    assert!(result.unwrap()); // Should block\n    \n    let result = MergeBlocker::should_block_merge(true, false, false);\n    assert!(result.is_ok());\n    assert!(result.unwrap()); // Should block\n    \n    let result = MergeBlocker::should_block_merge(false, false, false);\n    assert!(result.is_ok());\n    assert!(result.unwrap()); // Should block\n}\n\n#[tokio::test]\nasync fn test_merge_blocker_emergency_mode() {\n    // Test emergency mode - only signatures matter\n    let result = MergeBlocker::should_block_merge(false, true, true);\n    assert!(result.is_ok());\n    assert!(!result.unwrap()); // Should not block (signatures met)\n    \n    let result = MergeBlocker::should_block_merge(true, false, true);\n    assert!(result.is_ok());\n    assert!(result.unwrap()); // Should block (signatures not met)\n    \n    let result = MergeBlocker::should_block_merge(false, false, true);\n    assert!(result.is_ok());\n    assert!(result.unwrap()); // Should block (signatures not met)\n}\n\n#[tokio::test]\nasync fn test_merge_blocker_reasons() {\n    // Test normal mode reasons\n    let reason = MergeBlocker::get_block_reason(false, false, false);\n    assert!(reason.contains(\"Both review period and signature requirements not met\"));\n    \n    let reason = MergeBlocker::get_block_reason(false, true, false);\n    assert!(reason.contains(\"Review period requirement not met\"));\n    \n    let reason = MergeBlocker::get_block_reason(true, false, false);\n    assert!(reason.contains(\"Signature threshold requirement not met\"));\n    \n    let reason = MergeBlocker::get_block_reason(true, true, false);\n    assert!(reason.contains(\"All governance requirements met\"));\n    \n    // Test emergency mode reasons\n    let reason = MergeBlocker::get_block_reason(false, false, true);\n    assert!(reason.contains(\"Emergency mode: Signature threshold not met\"));\n    \n    let reason = MergeBlocker::get_block_reason(false, true, true);\n    assert!(reason.contains(\"Emergency mode: All requirements met\"));\n}\n\n#[tokio::test]\nasync fn test_status_check_edge_cases() {\n    // Test exactly at boundary\n    let opened_at = Utc::now() - Duration::days(90);\n    let required_days = 90;\n    let emergency_mode = false;\n    \n    let status = StatusCheckGenerator::generate_review_period_status(\n        opened_at,\n        required_days,\n        emergency_mode,\n    );\n    \n    assert!(status.contains(\"‚úÖ Governance: Review Period Met\"));\n    \n    // Test one day before boundary\n    let opened_at = Utc::now() - Duration::days(89);\n    let status = StatusCheckGenerator::generate_review_period_status(\n        opened_at,\n        required_days,\n        emergency_mode,\n    );\n    \n    assert!(status.contains(\"‚ùå Governance: Review Period Not Met\"));\n}\n\n#[tokio::test]\nasync fn test_emergency_tier_display_properties() {\n    // Test Critical tier\n    assert_eq!(EmergencyTier::Critical.emoji(), \"üö®\");\n    assert_eq!(EmergencyTier::Critical.name(), \"Critical Emergency\");\n    assert!(EmergencyTier::Critical.description().contains(\"Network-threatening\"));\n    \n    // Test Urgent tier\n    assert_eq!(EmergencyTier::Urgent.emoji(), \"‚ö†Ô∏è\");\n    assert_eq!(EmergencyTier::Urgent.name(), \"Urgent Security Issue\");\n    assert!(EmergencyTier::Urgent.description().contains(\"Serious security\"));\n    \n    // Test Elevated tier\n    assert_eq!(EmergencyTier::Elevated.emoji(), \"üì¢\");\n    assert_eq!(EmergencyTier::Elevated.name(), \"Elevated Priority\");\n    assert!(EmergencyTier::Elevated.description().contains(\"Important priority\"));\n}\n\n#[tokio::test]\nasync fn test_emergency_extension_calculations() {\n    let emergency = ActiveEmergency {\n        id: 1,\n        tier: EmergencyTier::Urgent,\n        activated_by: \"emergency_alice\".to_string(),\n        reason: \"Test\".to_string(),\n        activated_at: Utc::now() - Duration::days(5),\n        expires_at: Utc::now() + Duration::days(25),\n        extended: false,\n        extension_count: 0,\n    };\n    \n    // Test extension calculation\n    let new_expiration = emergency.calculate_extension_expiration();\n    assert!(new_expiration.is_some());\n    \n    let expected_expiration = emergency.expires_at + Duration::days(30);\n    assert_eq!(new_expiration.unwrap(), expected_expiration);\n    \n    // Test max extensions reached\n    let maxed_emergency = ActiveEmergency {\n        extension_count: 1, // Urgent allows only 1 extension\n        ..emergency\n    };\n    \n    assert!(!maxed_emergency.can_extend());\n    assert!(maxed_emergency.calculate_extension_expiration().is_none());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","tests","unit","github_tests.rs"],"content":"use governance_app::github::client::GitHubClient;\nuse wiremock::{Mock, MockServer, ResponseTemplate};\nuse wiremock::matchers::{method, path, header, body_json};\nuse serde_json::json;\n\nmod common;\nuse common::*;\n\n#[tokio::test]\nasync fn test_github_client_creation() {\n    // Test client creation with valid parameters\n    let temp_dir = tempfile::tempdir().unwrap();\n    let private_key_path = temp_dir.path().join(\"test_key.pem\");\n    std::fs::write(\u0026private_key_path, \"-----BEGIN PRIVATE KEY-----\\nMOCK_KEY\\n-----END PRIVATE KEY-----\").unwrap();\n    \n    let client = GitHubClient::new(123456, private_key_path.to_str().unwrap());\n    assert!(client.is_ok());\n}\n\n#[tokio::test]\nasync fn test_github_client_invalid_key_path() {\n    // Test client creation with invalid key path\n    let client = GitHubClient::new(123456, \"/nonexistent/path/key.pem\");\n    assert!(client.is_err());\n}\n\n#[tokio::test]\nasync fn test_post_status_check() {\n    let mock_server = MockServer::start().await;\n    let temp_dir = tempfile::tempdir().unwrap();\n    let private_key_path = temp_dir.path().join(\"test_key.pem\");\n    std::fs::write(\u0026private_key_path, \"-----BEGIN PRIVATE KEY-----\\nMOCK_KEY\\n-----END PRIVATE KEY-----\").unwrap();\n    \n    let client = GitHubClient::new(123456, private_key_path.to_str().unwrap()).unwrap();\n    \n    // Mock the status check endpoint\n    Mock::given(method(\"POST\"))\n        .and(path(\"/repos/owner/repo/statuses/abc123\"))\n        .respond_with(ResponseTemplate::new(201))\n        .mount(\u0026mock_server)\n        .await;\n    \n    let result = client.post_status_check(\n        \"owner\",\n        \"repo\",\n        \"abc123\",\n        \"success\",\n        \"All checks passed\",\n        \"governance-check\",\n    ).await;\n    \n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_get_repository_info() {\n    let mock_server = MockServer::start().await;\n    let temp_dir = tempfile::tempdir().unwrap();\n    let private_key_path = temp_dir.path().join(\"test_key.pem\");\n    std::fs::write(\u0026private_key_path, \"-----BEGIN PRIVATE KEY-----\\nMOCK_KEY\\n-----END PRIVATE KEY-----\").unwrap();\n    \n    let client = GitHubClient::new(123456, private_key_path.to_str().unwrap()).unwrap();\n    \n    // Mock the repository info endpoint\n    let mock_response = json!({\n        \"id\": 12345,\n        \"name\": \"test-repo\",\n        \"full_name\": \"owner/test-repo\",\n        \"private\": false,\n        \"default_branch\": \"main\"\n    });\n    \n    Mock::given(method(\"GET\"))\n        .and(path(\"/repos/owner/repo\"))\n        .respond_with(ResponseTemplate::new(200).set_body_json(\u0026mock_response))\n        .mount(\u0026mock_server)\n        .await;\n    \n    let result = client.get_repository_info(\"owner\", \"repo\").await;\n    assert!(result.is_ok());\n    \n    let repo_info = result.unwrap();\n    assert_eq!(repo_info[\"name\"], \"test-repo\");\n    assert_eq!(repo_info[\"full_name\"], \"owner/test-repo\");\n}\n\n#[tokio::test]\nasync fn test_github_api_error_handling() {\n    let mock_server = MockServer::start().await;\n    let temp_dir = tempfile::tempdir().unwrap();\n    let private_key_path = temp_dir.path().join(\"test_key.pem\");\n    std::fs::write(\u0026private_key_path, \"-----BEGIN PRIVATE KEY-----\\nMOCK_KEY\\n-----END PRIVATE KEY-----\").unwrap();\n    \n    let client = GitHubClient::new(123456, private_key_path.to_str().unwrap()).unwrap();\n    \n    // Mock a 404 error response\n    Mock::given(method(\"GET\"))\n        .and(path(\"/repos/owner/nonexistent\"))\n        .respond_with(ResponseTemplate::new(404))\n        .mount(\u0026mock_server)\n        .await;\n    \n    let result = client.get_repository_info(\"owner\", \"nonexistent\").await;\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_status_check_different_states() {\n    let mock_server = MockServer::start().await;\n    let temp_dir = tempfile::tempdir().unwrap();\n    let private_key_path = temp_dir.path().join(\"test_key.pem\");\n    std::fs::write(\u0026private_key_path, \"-----BEGIN PRIVATE KEY-----\\nMOCK_KEY\\n-----END PRIVATE KEY-----\").unwrap();\n    \n    let client = GitHubClient::new(123456, private_key_path.to_str().unwrap()).unwrap();\n    \n    // Test different status states\n    let states = vec![\"pending\", \"success\", \"error\", \"failure\"];\n    \n    for state in states {\n        Mock::given(method(\"POST\"))\n            .and(path(\"/repos/owner/repo/statuses/abc123\"))\n            .respond_with(ResponseTemplate::new(201))\n            .mount(\u0026mock_server)\n            .await;\n        \n        let result = client.post_status_check(\n            \"owner\",\n            \"repo\",\n            \"abc123\",\n            state,\n            \u0026format!(\"Status: {}\", state),\n            \"governance-check\",\n        ).await;\n        \n        assert!(result.is_ok());\n    }\n}\n\n#[tokio::test]\nasync fn test_github_client_retry_behavior() {\n    let mock_server = MockServer::start().await;\n    let temp_dir = tempfile::tempdir().unwrap();\n    let private_key_path = temp_dir.path().join(\"test_key.pem\");\n    std::fs::write(\u0026private_key_path, \"-----BEGIN PRIVATE KEY-----\\nMOCK_KEY\\n-----END PRIVATE KEY-----\").unwrap();\n    \n    let client = GitHubClient::new(123456, private_key_path.to_str().unwrap()).unwrap();\n    \n    // Mock a 500 error followed by success\n    Mock::given(method(\"GET\"))\n        .and(path(\"/repos/owner/repo\"))\n        .respond_with(ResponseTemplate::new(500))\n        .up_to_n_times(1)\n        .then()\n        .respond_with(ResponseTemplate::new(200).set_body_json(json!({\"name\": \"test-repo\"})))\n        .mount(\u0026mock_server)\n        .await;\n    \n    // The client should handle retries (implementation dependent)\n    let result = client.get_repository_info(\"owner\", \"repo\").await;\n    // This test assumes the client has retry logic - adjust based on actual implementation\n    assert!(result.is_ok() || result.is_err()); // Either retry succeeded or failed\n}\n\n#[tokio::test]\nasync fn test_github_client_authentication() {\n    let mock_server = MockServer::start().await;\n    let temp_dir = tempfile::tempdir().unwrap();\n    let private_key_path = temp_dir.path().join(\"test_key.pem\");\n    std::fs::write(\u0026private_key_path, \"-----BEGIN PRIVATE KEY-----\\nMOCK_KEY\\n-----END PRIVATE KEY-----\").unwrap();\n    \n    let client = GitHubClient::new(123456, private_key_path.to_str().unwrap()).unwrap();\n    \n    // Mock endpoint that requires authentication\n    Mock::given(method(\"GET\"))\n        .and(path(\"/repos/owner/private-repo\"))\n        .and(header(\"authorization\", \"Bearer\"))\n        .respond_with(ResponseTemplate::new(200).set_body_json(json!({\"name\": \"private-repo\"})))\n        .mount(\u0026mock_server)\n        .await;\n    \n    let result = client.get_repository_info(\"owner\", \"private-repo\").await;\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_github_client_rate_limiting() {\n    let mock_server = MockServer::start().await;\n    let temp_dir = tempfile::tempdir().unwrap();\n    let private_key_path = temp_dir.path().join(\"test_key.pem\");\n    std::fs::write(\u0026private_key_path, \"-----BEGIN PRIVATE KEY-----\\nMOCK_KEY\\n-----END PRIVATE KEY-----\").unwrap();\n    \n    let client = GitHubClient::new(123456, private_key_path.to_str().unwrap()).unwrap();\n    \n    // Mock rate limit response\n    Mock::given(method(\"GET\"))\n        .and(path(\"/repos/owner/repo\"))\n        .respond_with(ResponseTemplate::new(429).insert_header(\"x-ratelimit-remaining\", \"0\"))\n        .mount(\u0026mock_server)\n        .await;\n    \n    let result = client.get_repository_info(\"owner\", \"repo\").await;\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_github_client_network_timeout() {\n    let mock_server = MockServer::start().await;\n    let temp_dir = tempfile::tempdir().unwrap();\n    let private_key_path = temp_dir.path().join(\"test_key.pem\");\n    std::fs::write(\u0026private_key_path, \"-----BEGIN PRIVATE KEY-----\\nMOCK_KEY\\n-----END PRIVATE KEY-----\").unwrap();\n    \n    let client = GitHubClient::new(123456, private_key_path.to_str().unwrap()).unwrap();\n    \n    // Mock a slow response\n    Mock::given(method(\"GET\"))\n        .and(path(\"/repos/owner/repo\"))\n        .respond_with(ResponseTemplate::new(200).set_body_json(json!({\"name\": \"test-repo\"})).set_delay(std::time::Duration::from_secs(10)))\n        .mount(\u0026mock_server)\n        .await;\n    \n    let result = client.get_repository_info(\"owner\", \"repo\").await;\n    // This should timeout or succeed depending on client timeout configuration\n    assert!(result.is_ok() || result.is_err());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","user","src","BTCDecoded","governance-app","tests","unit","validation_tests.rs"],"content":"use governance_app::validation::*;\nuse governance_app::validation::signatures::SignatureValidator;\nuse governance_app::validation::cross_layer::CrossLayerValidator;\nuse governance_app::validation::emergency::*;\nuse chrono::{DateTime, Utc, Duration};\nuse secp256k1::{SecretKey, Secp256k1, PublicKey};\nuse rand::rngs::OsRng;\nuse std::collections::HashMap;\nuse serde_json::Value;\n\nmod common;\nuse common::*;\n\n#[tokio::test]\nasync fn test_review_period_validation() {\n    let now = Utc::now();\n    let opened_at = now - Duration::days(100); // 100 days ago\n    \n    // Test normal mode\n    let result = ReviewPeriodValidator::validate_review_period(opened_at, 90, false);\n    assert!(result.is_ok());\n    \n    // Test emergency mode\n    let result = ReviewPeriodValidator::validate_review_period(opened_at, 90, true);\n    assert!(result.is_ok());\n    \n    // Test insufficient time\n    let opened_recently = now - Duration::days(10);\n    let result = ReviewPeriodValidator::validate_review_period(opened_recently, 90, false);\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_review_period_edge_cases() {\n    let now = Utc::now();\n    \n    // Test exactly at the boundary\n    let opened_at = now - Duration::days(90);\n    let result = ReviewPeriodValidator::validate_review_period(opened_at, 90, false);\n    assert!(result.is_ok());\n    \n    // Test one day before boundary\n    let opened_at = now - Duration::days(89);\n    let result = ReviewPeriodValidator::validate_review_period(opened_at, 90, false);\n    assert!(result.is_err());\n    \n    // Test emergency mode with 30-day requirement\n    let opened_at = now - Duration::days(30);\n    let result = ReviewPeriodValidator::validate_review_period(opened_at, 90, true);\n    assert!(result.is_ok());\n    \n    let opened_at = now - Duration::days(29);\n    let result = ReviewPeriodValidator::validate_review_period(opened_at, 90, true);\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_review_period_calculations() {\n    let now = Utc::now();\n    let opened_at = now - Duration::days(50);\n    \n    // Test earliest merge date calculation\n    let earliest_merge = ReviewPeriodValidator::get_earliest_merge_date(opened_at, 90, false);\n    let expected = opened_at + Duration::days(90);\n    assert_eq!(earliest_merge, expected);\n    \n    // Test remaining days calculation\n    let remaining = ReviewPeriodValidator::get_remaining_days(opened_at, 90, false);\n    assert_eq!(remaining, 40);\n    \n    // Test emergency mode calculations\n    let earliest_merge_emergency = ReviewPeriodValidator::get_earliest_merge_date(opened_at, 90, true);\n    let expected_emergency = opened_at + Duration::days(30);\n    assert_eq!(earliest_merge_emergency, expected_emergency);\n}\n\n#[tokio::test]\nasync fn test_threshold_validation() {\n    // Test valid threshold\n    let result = ThresholdValidator::validate_threshold(5, 4, 7);\n    assert!(result.is_ok());\n    \n    // Test invalid threshold\n    let result = ThresholdValidator::validate_threshold(3, 4, 7);\n    assert!(result.is_err());\n    \n    // Test layer-specific thresholds\n    let (required, total) = ThresholdValidator::get_threshold_for_layer(1);\n    assert_eq!((required, total), (6, 7));\n    \n    let (required, total) = ThresholdValidator::get_threshold_for_layer(3);\n    assert_eq!((required, total), (4, 5));\n}\n\n#[tokio::test]\nasync fn test_threshold_all_layers() {\n    // Test all layer thresholds\n    for layer in 1..=5 {\n        let (required, total) = ThresholdValidator::get_threshold_for_layer(layer);\n        assert!(required \u003c= total);\n        assert!(required \u003e 0);\n        assert!(total \u003e 0);\n    }\n    \n    // Test review periods for all layers\n    for layer in 1..=5 {\n        let normal_period = ThresholdValidator::get_review_period_for_layer(layer, false);\n        let emergency_period = ThresholdValidator::get_review_period_for_layer(layer, true);\n        \n        assert!(normal_period \u003e 0);\n        assert_eq!(emergency_period, 30); // All layers use 30 days in emergency mode\n    }\n}\n\n#[tokio::test]\nasync fn test_threshold_status_formatting() {\n    let signers = vec![\"alice\".to_string(), \"bob\".to_string()];\n    let pending = vec![\"charlie\".to_string(), \"dave\".to_string()];\n    \n    let status = ThresholdValidator::format_threshold_status(2, 4, 5, \u0026signers, \u0026pending);\n    assert!(status.contains(\"Required: 4-of-5\"));\n    assert!(status.contains(\"Current: 2/5\"));\n    assert!(status.contains(\"alice, bob\"));\n    assert!(status.contains(\"charlie, dave\"));\n}\n\n#[tokio::test]\nasync fn test_signature_validation() {\n    let validator = SignatureValidator::new();\n    let secp = Secp256k1::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    let public_key = PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n    \n    let message = \"test message\";\n    let signature = secp.sign_ecdsa(\n        \u0026secp256k1::Message::from_slice(\u0026sha2::Sha256::digest(message.as_bytes())).unwrap(),\n        \u0026secret_key\n    );\n    \n    // Test valid signature\n    let result = validator.verify_signature(message, \u0026signature.to_string(), \u0026public_key.to_string());\n    assert!(result.is_ok());\n    assert!(result.unwrap());\n    \n    // Test invalid signature\n    let wrong_message = \"wrong message\";\n    let result = validator.verify_signature(wrong_message, \u0026signature.to_string(), \u0026public_key.to_string());\n    assert!(result.is_ok());\n    assert!(!result.unwrap());\n}\n\n#[tokio::test]\nasync fn test_signature_validation_edge_cases() {\n    let validator = SignatureValidator::new();\n    \n    // Test malformed public key\n    let result = validator.verify_signature(\"message\", \"signature\", \"invalid_key\");\n    assert!(result.is_err());\n    \n    // Test malformed signature\n    let secp = Secp256k1::new();\n    let secret_key = SecretKey::new(\u0026mut OsRng);\n    let public_key = PublicKey::from_secret_key(\u0026secp, \u0026secret_key);\n    \n    let result = validator.verify_signature(\"message\", \"invalid_signature\", \u0026public_key.to_string());\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_multisig_threshold_validation() {\n    let validator = SignatureValidator::new();\n    let secp = Secp256k1::new();\n    \n    // Create test keypairs\n    let keypairs = generate_test_keypairs(3);\n    let mut maintainer_keys = HashMap::new();\n    \n    for (username, _, public_key) in \u0026keypairs {\n        maintainer_keys.insert(username.clone(), public_key.to_string());\n    }\n    \n    // Create signatures\n    let message = \"governance-signature:test\";\n    let signatures: Vec\u003c(String, String)\u003e = keypairs.iter().map(|(username, secret_key, _)| {\n        let signature = secp.sign_ecdsa(\n            \u0026secp256k1::Message::from_slice(\u0026sha2::Sha256::digest(message.as_bytes())).unwrap(),\n            secret_key\n        );\n        (username.clone(), signature.to_string())\n    }).collect();\n    \n    // Test 2-of-3 threshold\n    let result = validator.verify_multisig_threshold(\u0026signatures, (2, 3), \u0026maintainer_keys);\n    assert!(result.is_ok());\n    assert!(result.unwrap());\n    \n    // Test insufficient signatures\n    let insufficient_signatures = \u0026signatures[0..1];\n    let result = validator.verify_multisig_threshold(insufficient_signatures, (2, 3), \u0026maintainer_keys);\n    assert!(result.is_ok());\n    assert!(!result.unwrap());\n}\n\n#[tokio::test]\nasync fn test_cross_layer_validation() {\n    let changed_files = vec![\n        \"src/consensus/block.rs\".to_string(),\n        \"src/consensus/transaction.rs\".to_string(),\n    ];\n    \n    let cross_layer_rules = create_test_cross_layer_rules();\n    \n    // Test matching pattern\n    let result = CrossLayerValidator::validate_cross_layer_dependencies(\n        \"BTCDecoded/consensus-proof\",\n        \u0026changed_files,\n        \u0026cross_layer_rules,\n    );\n    assert!(result.is_ok());\n    \n    // Test non-matching pattern\n    let non_matching_files = vec![\"src/other/file.rs\".to_string()];\n    let result = CrossLayerValidator::validate_cross_layer_dependencies(\n        \"BTCDecoded/consensus-proof\",\n        \u0026non_matching_files,\n        \u0026cross_layer_rules,\n    );\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_cross_layer_pattern_matching() {\n    // Test glob pattern matching\n    let files = vec![\"src/consensus/block.rs\".to_string()];\n    \n    // Test exact match\n    assert!(CrossLayerValidator::matches_pattern(\u0026files, \"src/consensus/block.rs\"));\n    \n    // Test wildcard match\n    assert!(CrossLayerValidator::matches_pattern(\u0026files, \"src/consensus/*\"));\n    \n    // Test double wildcard match\n    assert!(CrossLayerValidator::matches_pattern(\u0026files, \"src/**\"));\n    \n    // Test non-match\n    assert!(!CrossLayerValidator::matches_pattern(\u0026files, \"src/other/*\"));\n}\n\n#[tokio::test]\nasync fn test_emergency_tier_properties() {\n    // Test Critical tier\n    assert_eq!(EmergencyTier::Critical.review_period_days(), 0);\n    assert_eq!(EmergencyTier::Critical.signature_threshold(), (4, 7));\n    assert_eq!(EmergencyTier::Critical.max_duration_days(), 7);\n    assert!(!EmergencyTier::Critical.allows_extensions());\n    assert!(EmergencyTier::Critical.requires_security_audit());\n    \n    // Test Urgent tier\n    assert_eq!(EmergencyTier::Urgent.review_period_days(), 7);\n    assert_eq!(EmergencyTier::Urgent.signature_threshold(), (5, 7));\n    assert_eq!(EmergencyTier::Urgent.max_duration_days(), 30);\n    assert!(EmergencyTier::Urgent.allows_extensions());\n    assert!(!EmergencyTier::Urgent.requires_security_audit());\n    \n    // Test Elevated tier\n    assert_eq!(EmergencyTier::Elevated.review_period_days(), 30);\n    assert_eq!(EmergencyTier::Elevated.signature_threshold(), (6, 7));\n    assert_eq!(EmergencyTier::Elevated.max_duration_days(), 90);\n    assert!(EmergencyTier::Elevated.allows_extensions());\n    assert!(!EmergencyTier::Elevated.requires_security_audit());\n}\n\n#[tokio::test]\nasync fn test_emergency_tier_parsing() {\n    assert_eq!(EmergencyTier::from_i32(1).unwrap(), EmergencyTier::Critical);\n    assert_eq!(EmergencyTier::from_i32(2).unwrap(), EmergencyTier::Urgent);\n    assert_eq!(EmergencyTier::from_i32(3).unwrap(), EmergencyTier::Elevated);\n    assert!(EmergencyTier::from_i32(4).is_err());\n    assert!(EmergencyTier::from_i32(0).is_err());\n}\n\n#[tokio::test]\nasync fn test_emergency_activation_validation() {\n    let activation = EmergencyActivation {\n        tier: EmergencyTier::Critical,\n        activated_by: \"emergency_alice\".to_string(),\n        reason: \"Critical security vulnerability\".to_string(),\n        evidence: \"Detailed evidence of the critical security vulnerability that requires immediate attention\".to_string(),\n        signatures: vec![],\n    };\n    \n    // Test insufficient evidence\n    let mut short_evidence = activation.clone();\n    short_evidence.evidence = \"Short\".to_string();\n    let result = EmergencyValidator::validate_activation(\u0026short_evidence);\n    assert!(result.is_err());\n    \n    // Test sufficient evidence\n    let result = EmergencyValidator::validate_activation(\u0026activation);\n    assert!(result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_active_emergency_expiration() {\n    let emergency = ActiveEmergency {\n        id: 1,\n        tier: EmergencyTier::Critical,\n        activated_by: \"emergency_alice\".to_string(),\n        reason: \"Test\".to_string(),\n        activated_at: Utc::now() - Duration::days(10),\n        expires_at: Utc::now() - Duration::days(1),\n        extended: false,\n        extension_count: 0,\n    };\n    \n    assert!(emergency.is_expired());\n    assert!(!emergency.can_extend()); // Critical doesn't allow extensions\n    \n    let non_expired = ActiveEmergency {\n        id: 2,\n        tier: EmergencyTier::Urgent,\n        activated_by: \"emergency_bob\".to_string(),\n        reason: \"Test\".to_string(),\n        activated_at: Utc::now() - Duration::days(5),\n        expires_at: Utc::now() + Duration::days(25),\n        extended: false,\n        extension_count: 0,\n    };\n    \n    assert!(!non_expired.is_expired());\n    assert!(non_expired.can_extend()); // Urgent allows 1 extension\n}\n\n#[tokio::test]\nasync fn test_emergency_extension_validation() {\n    let emergency = ActiveEmergency {\n        id: 1,\n        tier: EmergencyTier::Urgent,\n        activated_by: \"emergency_alice\".to_string(),\n        reason: \"Test\".to_string(),\n        activated_at: Utc::now() - Duration::days(5),\n        expires_at: Utc::now() + Duration::days(25),\n        extended: false,\n        extension_count: 0,\n    };\n    \n    let signatures = vec![];\n    \n    // Test valid extension\n    let result = EmergencyValidator::validate_extension(\u0026emergency, \u0026signatures);\n    assert!(result.is_ok());\n    \n    // Test extension on Critical tier (not allowed)\n    let critical_emergency = ActiveEmergency {\n        tier: EmergencyTier::Critical,\n        ..emergency\n    };\n    \n    let result = EmergencyValidator::validate_extension(\u0026critical_emergency, \u0026signatures);\n    assert!(result.is_err());\n}\n\n\n\n\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, 'üåô'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = 'üåô';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '‚òÄÔ∏è';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = 'üåô';
    }
  });
})();
</script>
</body>
</html>